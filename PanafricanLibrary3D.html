<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Panafrican Library Will Not Be Colonized | Reading Room 3D</title>
    <meta name="description" content="A curatorial Reading Room conceived as a living archive of panafrican and diasporic publishing. Interactive 3D simulation.">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background: #1a1a1a;
            color: #fff;
            overflow: hidden;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px;
            border-radius: 8px;
            max-width: 320px;
            z-index: 100;
            border: 1px solid rgba(255,255,255,0.1);
        }
        /* Mobile responsive styles */
        @media (max-width: 768px) {
            #info-panel {
                top: 10px;
                left: 10px;
                right: 10px;
                max-width: none;
                padding: 12px;
            }
            #info-panel h1 { font-size: 14px; }
            #info-panel h2 { font-size: 9px; margin-bottom: 10px; }
            #info-panel p { font-size: 11px; margin-bottom: 10px; }
            .room-btn { padding: 6px 10px; font-size: 10px; }
            #controls-panel {
                top: auto;
                bottom: 180px;
                right: 10px;
                left: 10px;
                max-height: 40vh;
                display: flex;
                flex-wrap: wrap;
                gap: 5px;
                padding: 10px;
            }
            .control-section {
                flex: 1 1 45%;
                min-width: 140px;
                margin-bottom: 5px;
                padding-bottom: 5px;
            }
            .control-btn { padding: 6px 8px; font-size: 10px; }
            .section-title { font-size: 9px; margin-bottom: 5px; }
            #dimensions-panel { display: none; }
            #credits {
                bottom: 10px;
                right: 10px;
                left: auto;
                padding: 8px 10px;
                font-size: 8px;
            }
            #help-text {
                bottom: 150px;
                font-size: 10px;
                padding: 6px 12px;
            }
            #toggle-btns {
                bottom: 100px;
                padding: 0 10px;
            }
            .toggle-btn { padding: 5px 8px; font-size: 9px; }
            #capture-btn {
                bottom: 60px;
                padding: 8px 15px;
                font-size: 11px;
            }
        }
        @media (max-width: 480px) {
            #info-panel {
                padding: 10px;
            }
            #info-panel h1 { font-size: 12px; }
            #info-panel p { display: none; }
            #controls-panel {
                max-height: 35vh;
            }
            .control-section { flex: 1 1 100%; }
            #credits { display: none; }
        }
        #info-panel h1 {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        #info-panel h2 {
            font-size: 11px;
            font-weight: 400;
            color: #888;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        #info-panel p {
            font-size: 13px;
            line-height: 1.6;
            color: #ccc;
            margin-bottom: 15px;
        }
        .room-btn {
            display: inline-block;
            padding: 8px 14px;
            margin: 4px 4px 4px 0;
            background: rgba(100, 149, 237, 0.3);
            border: 1px solid cornflowerblue;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }
        .room-btn:hover {
            background: cornflowerblue;
        }
        #controls-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            border: 1px solid rgba(255,255,255,0.1);
            max-height: 80vh;
            overflow-y: auto;
        }
        .control-section {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .control-section:last-child { border-bottom: none; }
        .section-title {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }
        .control-btn {
            display: block;
            width: 100%;
            padding: 8px 12px;
            margin: 4px 0;
            background: rgba(255,255,255,0.1);
            border: none;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            text-align: left;
            transition: all 0.3s;
        }
        .control-btn:hover {
            background: rgba(255,255,255,0.2);
        }
        .control-btn.active {
            background: rgba(100, 149, 237, 0.4);
            border: 1px solid cornflowerblue;
        }
        #dimensions-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.85);
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            border: 1px solid rgba(255,255,255,0.1);
            font-size: 11px;
            max-width: 420px;
        }
        #dimensions-panel h3 {
            font-size: 12px;
            margin-bottom: 10px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .dim-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .dim-row:last-child { border-bottom: none; }
        .dim-label { color: #888; }
        .dim-value { color: #fff; font-family: monospace; }
        #credits {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 12px 15px;
            border-radius: 8px;
            z-index: 100;
            border: 1px solid rgba(255,255,255,0.1);
            font-size: 10px;
            text-align: right;
        }
        #credits a { color: cornflowerblue; text-decoration: none; }
        #credits a:hover { text-decoration: underline; }
        #help-text {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 12px;
            color: #888;
            z-index: 100;
        }
        #toggle-btns {
            position: absolute;
            bottom: 130px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
            z-index: 100;
            max-width: 500px;
        }
        .toggle-btn {
            padding: 6px 12px;
            background: rgba(0,0,0,0.7);
            border: 1px solid rgba(255,255,255,0.2);
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }
        .toggle-btn.active {
            background: rgba(100, 149, 237, 0.5);
            border-color: cornflowerblue;
        }
        #capture-btn {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background: cornflowerblue;
            border: none;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            z-index: 100;
        }
        .icon { margin-right: 6px; }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div id="info-panel">
        <h1>The Panafrican Library Will Not Be Colonized</h1>
        <h2>Reading Room ‚Ä¢ Interactive 3D</h2>
        <p>A curatorial Reading Room conceived as a living archive of panafrican and diasporic publishing. A space to read, listen, and slow down.</p>
        <button class="room-btn" onclick="focusRoom('room5202')">Room 5202 ‚Äî Special Special</button>
        <button class="room-btn" onclick="focusRoom('room5203')">Room 5203 ‚Äî Reading Room</button>
    </div>

    <div id="controls-panel">
        <div class="control-section">
            <div class="section-title">Overview</div>
            <button class="control-btn" onclick="setView('overview')"><span class="icon">üè†</span>Bird's Eye</button>
            <button class="control-btn" onclick="setView('floorPlan')"><span class="icon">üìê</span>Floor Plan View</button>
        </div>
        <div class="control-section">
            <div class="section-title">Room 5202 - Special Special</div>
            <button class="control-btn" onclick="setView('room5202Entry')"><span class="icon">üö™</span>Entry Vestibule</button>
            <button class="control-btn" onclick="setView('room5202Inside')"><span class="icon">üîä</span>Inside View</button>
            <button class="control-btn" onclick="setView('room5202Windows')"><span class="icon">ü™ü</span>Window Wall</button>
            <button class="control-btn" onclick="setView('room5202Table')"><span class="icon">üìö</span>Display Table</button>
        </div>
        <div class="control-section">
            <div class="section-title">Room 5203 - Reading Room</div>
            <button class="control-btn" onclick="setView('room5203Entry')"><span class="icon">üö™</span>Entry (from door)</button>
            <button class="control-btn" onclick="setView('room5203Inside')"><span class="icon">üìñ</span>Inside View</button>
            <button class="control-btn" onclick="setView('room5203Windows')"><span class="icon">ü™ü</span>Arched Windows</button>
            <button class="control-btn" onclick="setView('room5203Seating')"><span class="icon">üõãÔ∏è</span>Seating Area</button>
            <button class="control-btn" onclick="setView('room5203Shelves')"><span class="icon">üìö</span>Book Displays</button>
        </div>
        <div class="control-section">
            <button class="control-btn" onclick="startTour()"><span class="icon">üé¨</span>Auto Tour</button>
        </div>
    </div>

    <div id="dimensions-panel">
        <h3>Room Dimensions (from floor plan)</h3>
        <div class="dim-row">
            <span class="dim-label">Room 5202 (Special Special)</span>
            <span class="dim-value">11'-5‚Öù" √ó 25'-3¬æ" | 3.49m √ó 7.71m</span>
        </div>
        <div class="dim-row">
            <span class="dim-label">Room 5202 Area</span>
            <span class="dim-value">289.4 sq ft | 26.9 m¬≤</span>
        </div>
        <div class="dim-row">
            <span class="dim-label">Room 5203 (Reading Room)</span>
            <span class="dim-value">14'-7¬æ" √ó 25'-3¬æ" | 4.46m √ó 7.71m</span>
        </div>
        <div class="dim-row">
            <span class="dim-label">Room 5203 Area</span>
            <span class="dim-value">369.5 sq ft | 34.3 m¬≤</span>
        </div>
        <div class="dim-row">
            <span class="dim-label">Ceiling Height</span>
            <span class="dim-value">12'-0" | 3.66m</span>
        </div>
        <div class="dim-row">
            <span class="dim-label">Door Openings</span>
            <span class="dim-value">3'-5‚Öõ" √ó 7'-0" | 1.04m √ó 2.13m</span>
        </div>
        <div class="dim-row">
            <span class="dim-label">Total Combined Area</span>
            <span class="dim-value">658.9 sq ft | 61.2 m¬≤</span>
        </div>
    </div>

    <div id="credits">
        <div style="margin-bottom: 8px; color: #888;">A project by</div>
        <div><a href="http://www.afrikadaa.com/" target="_blank">Pascale Obolo / Afrikadaa</a></div>
        <div><a href="http://coolhuntparis.com" target="_blank">Nalini Cazaux / Coolhunt Paris</a></div>
        <div style="margin-top: 8px; color: #888;">3D Simulation by</div>
        <div><a href="http://luvlab.io" target="_blank">Gordon Cyrus / Luvlab</a></div>
    </div>

    <div id="help-text">‚Ä¢ Drag to rotate ‚Ä¢ Scroll to zoom ‚Ä¢ WASD to move</div>

    <div id="toggle-btns">
        <button class="toggle-btn active" onclick="toggleGrid()" id="gridBtn">Grid</button>
        <button class="toggle-btn active" onclick="toggleLabels()" id="labelsBtn">Labels</button>
        <button class="toggle-btn active" onclick="toggleCeiling()" id="ceilingBtn">Ceiling</button>
        <button class="toggle-btn" onclick="toggleNearWall()" id="nearWallBtn">Hide Near Wall</button>
        <button class="toggle-btn" onclick="toggleWireframe()" id="wireframeBtn">Wireframe</button>
    </div>

    <button id="capture-btn" onclick="captureScreenshot()">üì∑ Capture</button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);

        const container = document.getElementById('canvas-container');
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);

        const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // ============================================================
        // EXACT DIMENSIONS FROM FLOOR PLAN (converted to meters)
        // CORRECTED LAYOUT: Windows on FRONT (south), Doors on BACK (north)
        // Room 5202 "Special Special" is LEFT, Room 5203 "Reading Room" is RIGHT
        // Room 5202 has an entry vestibule/corridor before main space
        // ============================================================
        const ROOM_5202_WIDTH = 3.496;  // 11'-5‚Öù" (X direction)
        const ROOM_5202_DEPTH = 7.715;  // 25'-3¬æ" (Z direction)
        const ROOM_5203_WIDTH = 4.465;  // 14'-7¬æ"
        const ROOM_5203_DEPTH = 7.715;  // 25'-3¬æ"
        const CEILING_HEIGHT = 3.66;   // 12' ceiling
        const WALL_THICKNESS = 0.152;  // 6"
        const DOOR_WIDTH = 1.044;      // 3'-5‚Öõ"
        const DOOR_HEIGHT = 2.134;     // 7'-0"

        // Entry vestibule dimensions for Room 5202 (estimated from plan)
        const VESTIBULE_WIDTH = ROOM_5202_WIDTH;  // Same width as room
        const VESTIBULE_DEPTH = 1.5;  // ~5' deep vestibule/corridor

        // Window dimensions (from reference photos)
        const ARCH_WINDOW_WIDTH = 1.4;
        const ARCH_WINDOW_HEIGHT = 2.4;
        const ARCH_WINDOW_SILL = 0.6;
        const ARCH_RADIUS = 0.7;

        const RECT_WINDOW_WIDTH = 1.2;
        const RECT_WINDOW_HEIGHT = 1.5;
        const RECT_WINDOW_SILL = 0.9;

        // Materials
        const wallMaterial = new THREE.MeshLambertMaterial({ color: 0xf8f8f5, side: THREE.DoubleSide });
        const brickMaterial = new THREE.MeshLambertMaterial({ color: 0xf0ebe5, side: THREE.DoubleSide });
        const floorMaterial = new THREE.MeshLambertMaterial({ color: 0xd4c8b8 });
        const darkBlueMaterial = new THREE.MeshLambertMaterial({ color: 0x2c3e5c });
        const windowFrameMaterial = new THREE.MeshLambertMaterial({ color: 0xe8e8e8 });
        const glassMaterial = new THREE.MeshLambertMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.25 });
        const woodMaterial = new THREE.MeshLambertMaterial({ color: 0xd4a76a });
        const ochreFloorMaterial = new THREE.MeshLambertMaterial({ color: 0xc9a227 });
        const redMaterial = new THREE.MeshLambertMaterial({ color: 0xc41e3a });

        // Groups for visibility control
        const labelsGroup = new THREE.Group();
        const ceilingsGroup = new THREE.Group();
        const wallsGroup = new THREE.Group();
        const room5202Walls = { front: null, back: null, left: null, right: null, vestibuleLeft: null, vestibuleRight: null };
        const room5203Walls = { front: null, back: null, left: null, right: null };

        const gridHelper = new THREE.GridHelper(20, 40, 0x444444, 0x333333);
        scene.add(gridHelper);

        // Position rooms side by side (Room 5202 LEFT, Room 5203 RIGHT)
        const TOTAL_WIDTH = ROOM_5202_WIDTH + WALL_THICKNESS + ROOM_5203_WIDTH;
        const ROOM_5202_X = -TOTAL_WIDTH / 2 + ROOM_5202_WIDTH / 2;
        const ROOM_5203_X = TOTAL_WIDTH / 2 - ROOM_5203_WIDTH / 2;

        // ============ HELPER FUNCTIONS ============

        function createArchedWindow(width, height, archRadius, hasFabricFrame = true) {
            const group = new THREE.Group();
            const frameThickness = 0.08;

            // Glass
            const glassShape = new THREE.Shape();
            glassShape.moveTo(-width/2, 0);
            glassShape.lineTo(-width/2, height - archRadius);
            glassShape.quadraticCurveTo(-width/2, height, 0, height);
            glassShape.quadraticCurveTo(width/2, height, width/2, height - archRadius);
            glassShape.lineTo(width/2, 0);
            glassShape.lineTo(-width/2, 0);

            const glass = new THREE.Mesh(new THREE.ShapeGeometry(glassShape), glassMaterial);
            group.add(glass);

            // Frame bars
            const leftFrame = new THREE.Mesh(new THREE.BoxGeometry(frameThickness, height - archRadius, frameThickness), windowFrameMaterial);
            leftFrame.position.set(-width/2, (height - archRadius)/2, 0);
            group.add(leftFrame);

            const rightFrame = new THREE.Mesh(new THREE.BoxGeometry(frameThickness, height - archRadius, frameThickness), windowFrameMaterial);
            rightFrame.position.set(width/2, (height - archRadius)/2, 0);
            group.add(rightFrame);

            const bottomFrame = new THREE.Mesh(new THREE.BoxGeometry(width + frameThickness, frameThickness, frameThickness), windowFrameMaterial);
            bottomFrame.position.set(0, 0, 0);
            group.add(bottomFrame);

            const centerFrame = new THREE.Mesh(new THREE.BoxGeometry(frameThickness, height - archRadius, frameThickness), windowFrameMaterial);
            centerFrame.position.set(0, (height - archRadius)/2, 0);
            group.add(centerFrame);

            const middleFrame = new THREE.Mesh(new THREE.BoxGeometry(width, frameThickness, frameThickness), windowFrameMaterial);
            middleFrame.position.set(0, height * 0.4, 0);
            group.add(middleFrame);

            // Dark blue fabric frame
            if (hasFabricFrame) {
                const fabricWidth = width + 0.4;
                const fabricHeight = height + 0.3;
                const leftFabric = new THREE.Mesh(new THREE.BoxGeometry(0.15, fabricHeight, 0.02), darkBlueMaterial);
                leftFabric.position.set(-fabricWidth/2, fabricHeight/2, 0.02);
                group.add(leftFabric);
                const rightFabric = new THREE.Mesh(new THREE.BoxGeometry(0.15, fabricHeight, 0.02), darkBlueMaterial);
                rightFabric.position.set(fabricWidth/2, fabricHeight/2, 0.02);
                group.add(rightFabric);
                const topFabric = new THREE.Mesh(new THREE.BoxGeometry(fabricWidth, 0.15, 0.02), darkBlueMaterial);
                topFabric.position.set(0, fabricHeight - 0.1, 0.02);
                group.add(topFabric);
            }

            return group;
        }

        function createRectWindow(width, height) {
            const group = new THREE.Group();
            const glass = new THREE.Mesh(new THREE.PlaneGeometry(width, height), glassMaterial);
            group.add(glass);

            const frameThickness = 0.06;
            const topFrame = new THREE.Mesh(new THREE.BoxGeometry(width + 0.1, frameThickness, frameThickness), windowFrameMaterial);
            topFrame.position.set(0, height/2, 0);
            group.add(topFrame);

            const bottomFrame = new THREE.Mesh(new THREE.BoxGeometry(width + 0.1, frameThickness, frameThickness), windowFrameMaterial);
            bottomFrame.position.set(0, -height/2, 0);
            group.add(bottomFrame);

            const leftFrame = new THREE.Mesh(new THREE.BoxGeometry(frameThickness, height, frameThickness), windowFrameMaterial);
            leftFrame.position.set(-width/2, 0, 0);
            group.add(leftFrame);

            const rightFrame = new THREE.Mesh(new THREE.BoxGeometry(frameThickness, height, frameThickness), windowFrameMaterial);
            rightFrame.position.set(width/2, 0, 0);
            group.add(rightFrame);

            const centerV = new THREE.Mesh(new THREE.BoxGeometry(frameThickness * 0.7, height, frameThickness), windowFrameMaterial);
            centerV.position.set(0, 0, 0);
            group.add(centerV);

            return group;
        }

        function createFloorCushion(color, size = 0.6) {
            const group = new THREE.Group();
            const cushion = new THREE.Mesh(new THREE.SphereGeometry(size / 2, 16, 12), new THREE.MeshLambertMaterial({ color }));
            cushion.scale.set(1, 0.5, 1);
            cushion.position.set(0, size * 0.25, 0);
            group.add(cushion);
            return group;
        }

        function createTuftedFloorMattress(width, depth) {
            const group = new THREE.Group();
            const mattress = new THREE.Mesh(new THREE.BoxGeometry(width, 0.2, depth), ochreFloorMaterial);
            mattress.position.set(0, 0.1, 0);
            group.add(mattress);
            const buttonMat = new THREE.MeshLambertMaterial({ color: 0xa88520 });
            for (let x = -width/2 + 0.3; x < width/2; x += 0.3) {
                for (let z = -depth/2 + 0.3; z < depth/2; z += 0.3) {
                    const button = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.05, 8), buttonMat);
                    button.position.set(x, 0.2, z);
                    group.add(button);
                }
            }
            return group;
        }

        function createLayeredRug(width, depth, color) {
            const group = new THREE.Group();
            const rug = new THREE.Mesh(new THREE.BoxGeometry(width, 0.02, depth), new THREE.MeshLambertMaterial({ color }));
            rug.position.set(0, 0.01, 0);
            group.add(rug);
            const borderMat = new THREE.MeshLambertMaterial({ color: 0x2d2d2d });
            const topBorder = new THREE.Mesh(new THREE.BoxGeometry(width, 0.025, 0.05), borderMat);
            topBorder.position.set(0, 0.02, -depth/2 + 0.025);
            group.add(topBorder);
            const bottomBorder = new THREE.Mesh(new THREE.BoxGeometry(width, 0.025, 0.05), borderMat);
            bottomBorder.position.set(0, 0.02, depth/2 - 0.025);
            group.add(bottomBorder);
            return group;
        }

        function createWoodenBookshelf(width, height, rows) {
            const group = new THREE.Group();
            const shelfWood = new THREE.MeshLambertMaterial({ color: 0xe8d4b8 });
            const backPanel = new THREE.Mesh(new THREE.BoxGeometry(width, height, 0.02), shelfWood);
            backPanel.position.set(0, height/2, 0);
            group.add(backPanel);

            const shelfSpacing = height / (rows + 1);
            for (let i = 1; i <= rows; i++) {
                const shelf = new THREE.Mesh(new THREE.BoxGeometry(width, 0.02, 0.15), shelfWood);
                shelf.position.set(0, i * shelfSpacing, 0.08);
                group.add(shelf);
                const bookCount = Math.floor(width / 0.2);
                const bookColors = [0x4ecdc4, 0xff6b6b, 0xffd93d, 0x45b7d1, 0x96ceb4, 0xa29bfe, 0xe17055, 0x00b894];
                for (let j = 0; j < bookCount; j++) {
                    const book = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, 0.02), new THREE.MeshLambertMaterial({ color: bookColors[j % bookColors.length] }));
                    book.position.set(-width/2 + 0.1 + j * 0.18, i * shelfSpacing + 0.12, 0.14);
                    group.add(book);
                }
            }
            return group;
        }

        function createPottedPlant() {
            const group = new THREE.Group();
            const pot = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.1, 0.2, 12), new THREE.MeshLambertMaterial({ color: 0xc4713d }));
            pot.position.set(0, 0.1, 0);
            group.add(pot);
            const soil = new THREE.Mesh(new THREE.CylinderGeometry(0.11, 0.11, 0.03, 12), new THREE.MeshLambertMaterial({ color: 0x4a3728 }));
            soil.position.set(0, 0.2, 0);
            group.add(soil);
            const leafMat = new THREE.MeshLambertMaterial({ color: 0x228b22 });
            for (let i = 0; i < 6; i++) {
                const leaf = new THREE.Mesh(new THREE.SphereGeometry(0.08 + Math.random() * 0.04, 8, 8), leafMat);
                leaf.position.set((Math.random() - 0.5) * 0.15, 0.35 + Math.random() * 0.15, (Math.random() - 0.5) * 0.15);
                leaf.scale.set(1, 0.6, 1);
                group.add(leaf);
            }
            return group;
        }

        function createPendantLight() {
            const group = new THREE.Group();
            const cord = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.8, 8), new THREE.MeshLambertMaterial({ color: 0x333333 }));
            cord.position.set(0, 0.4, 0);
            group.add(cord);
            const shade = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.25, 0.2, 16, 1, true), new THREE.MeshLambertMaterial({ color: 0xd4a76a, side: THREE.DoubleSide }));
            group.add(shade);
            const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), new THREE.MeshBasicMaterial({ color: 0xfffacd }));
            group.add(bulb);
            return group;
        }

        function createLowCoffeeTable() {
            const group = new THREE.Group();
            const tableMat = new THREE.MeshLambertMaterial({ color: 0xc4a77d });
            const top = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 0.04, 24), tableMat);
            top.position.set(0, 0.25, 0);
            group.add(top);
            for (let i = 0; i < 3; i++) {
                const angle = (i * 2 * Math.PI) / 3;
                const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.04, 0.23, 8), tableMat);
                leg.position.set(Math.cos(angle) * 0.25, 0.115, Math.sin(angle) * 0.25);
                group.add(leg);
            }
            return group;
        }

        function createRedBookDisplay() {
            const group = new THREE.Group();
            const bodyWidth = 0.7, bodyHeight = 0.9, bodyDepth = 0.5;
            const backPanel = new THREE.Mesh(new THREE.BoxGeometry(bodyWidth, bodyHeight, 0.03), redMaterial);
            backPanel.position.set(0, bodyHeight/2, -bodyDepth/2);
            group.add(backPanel);
            for (let i = 0; i < 4; i++) {
                const shelf = new THREE.Mesh(new THREE.BoxGeometry(bodyWidth - 0.05, 0.02, bodyDepth * 0.6), redMaterial);
                shelf.position.set(0, 0.15 + i * 0.2, -0.1);
                shelf.rotation.x = -0.2;
                group.add(shelf);
                const bookColors = [0xffffff, 0x4ecdc4, 0xff6b6b, 0xffd93d, 0x95e1d3];
                for (let j = 0; j < 5; j++) {
                    const book = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.15, 0.01), new THREE.MeshLambertMaterial({ color: bookColors[j] }));
                    book.position.set(-0.25 + j * 0.12, 0.25 + i * 0.2, 0);
                    book.rotation.x = -0.3;
                    group.add(book);
                }
            }
            const sideL = new THREE.Mesh(new THREE.BoxGeometry(0.03, bodyHeight, bodyDepth), redMaterial);
            sideL.position.set(-bodyWidth/2, bodyHeight/2, 0);
            group.add(sideL);
            const sideR = new THREE.Mesh(new THREE.BoxGeometry(0.03, bodyHeight, bodyDepth), redMaterial);
            sideR.position.set(bodyWidth/2, bodyHeight/2, 0);
            group.add(sideR);
            return group;
        }

        function createPosterWall(width, height) {
            const group = new THREE.Group();
            const baseWall = new THREE.Mesh(new THREE.PlaneGeometry(width, height), new THREE.MeshLambertMaterial({ color: 0xf5f0e8 }));
            group.add(baseWall);
            const posterColors = [0xff6b6b, 0xffd93d, 0x4ecdc4, 0x45b7d1, 0x96ceb4, 0xffeaa7, 0xdfe6e9, 0xfd79a8, 0x00b894, 0xe17055, 0x74b9ff, 0xa29bfe, 0x55efc4, 0xfdcb6e, 0xe84393];
            for (let i = 0; i < 60; i++) {
                const posterW = 0.15 + Math.random() * 0.3;
                const posterH = 0.2 + Math.random() * 0.35;
                const poster = new THREE.Mesh(new THREE.PlaneGeometry(posterW, posterH), new THREE.MeshLambertMaterial({ color: posterColors[Math.floor(Math.random() * posterColors.length)] }));
                poster.position.set((Math.random() - 0.5) * (width - posterW), (Math.random() - 0.5) * (height - posterH), 0.005 + i * 0.001);
                poster.rotation.z = (Math.random() - 0.5) * 0.1;
                group.add(poster);
            }
            return group;
        }

        // ============ ROOM 5202 - SPECIAL SPECIAL ============
        // LAYOUT: Windows on FRONT (+Z), Door to corridor on BACK (-Z) via VESTIBULE, Door to 5203 on RIGHT (+X)
        // Has an entry vestibule/corridor with INTERIOR PARTITION WALLS creating a narrow passage
        function createRoom5202() {
            const group = new THREE.Group();

            // Vestibule corridor dimensions - narrow passage created by interior partitions
            const CORRIDOR_WIDTH = 1.2;  // Narrow corridor width (~4 feet)
            const PARTITION_LENGTH = (ROOM_5202_WIDTH - CORRIDOR_WIDTH) / 2;  // Length of each partition wall

            // ========== FLOOR (entire room) ==========
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(ROOM_5202_WIDTH, ROOM_5202_DEPTH), floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(0, 0.01, 0);
            group.add(floor);

            // Dark blue carpet in main area (not in vestibule)
            const carpet = new THREE.Mesh(new THREE.PlaneGeometry(ROOM_5202_WIDTH - 0.5, ROOM_5202_DEPTH - VESTIBULE_DEPTH - 0.5), new THREE.MeshLambertMaterial({ color: 0x1a3a5c }));
            carpet.rotation.x = -Math.PI / 2;
            carpet.position.set(0, 0.02, VESTIBULE_DEPTH / 2);
            group.add(carpet);

            // ========== BACK WALL (-Z) - Door to corridor/STUDIO ==========
            const backWallGroup = new THREE.Group();
            const backWall1 = new THREE.Mesh(new THREE.BoxGeometry((ROOM_5202_WIDTH - DOOR_WIDTH) / 2, CEILING_HEIGHT, WALL_THICKNESS), wallMaterial);
            backWall1.position.set(-ROOM_5202_WIDTH / 4 - DOOR_WIDTH / 4, CEILING_HEIGHT / 2, -ROOM_5202_DEPTH / 2);
            backWallGroup.add(backWall1);
            const backWall2 = new THREE.Mesh(new THREE.BoxGeometry((ROOM_5202_WIDTH - DOOR_WIDTH) / 2, CEILING_HEIGHT, WALL_THICKNESS), wallMaterial);
            backWall2.position.set(ROOM_5202_WIDTH / 4 + DOOR_WIDTH / 4, CEILING_HEIGHT / 2, -ROOM_5202_DEPTH / 2);
            backWallGroup.add(backWall2);
            const backDoorHeader = new THREE.Mesh(new THREE.BoxGeometry(DOOR_WIDTH, CEILING_HEIGHT - DOOR_HEIGHT, WALL_THICKNESS), wallMaterial);
            backDoorHeader.position.set(0, DOOR_HEIGHT + (CEILING_HEIGHT - DOOR_HEIGHT) / 2, -ROOM_5202_DEPTH / 2);
            backWallGroup.add(backDoorHeader);
            group.add(backWallGroup);
            room5202Walls.back = backWallGroup;

            // ========== INTERIOR PARTITION WALLS (create the vestibule corridor) ==========
            // These walls extend from the back wall INTO the room, creating a narrow entry passage
            const partitionGroup = new THREE.Group();

            // LEFT partition wall - extends from back wall into room
            const leftPartition = new THREE.Mesh(new THREE.BoxGeometry(PARTITION_LENGTH, CEILING_HEIGHT, WALL_THICKNESS), wallMaterial);
            leftPartition.position.set(-ROOM_5202_WIDTH / 2 + PARTITION_LENGTH / 2, CEILING_HEIGHT / 2, -ROOM_5202_DEPTH / 2 + VESTIBULE_DEPTH);
            partitionGroup.add(leftPartition);

            // RIGHT partition wall - extends from back wall into room
            const rightPartition = new THREE.Mesh(new THREE.BoxGeometry(PARTITION_LENGTH, CEILING_HEIGHT, WALL_THICKNESS), wallMaterial);
            rightPartition.position.set(ROOM_5202_WIDTH / 2 - PARTITION_LENGTH / 2, CEILING_HEIGHT / 2, -ROOM_5202_DEPTH / 2 + VESTIBULE_DEPTH);
            partitionGroup.add(rightPartition);

            // Door opening header between partitions (if needed for taller doorway effect)
            // Optional: add a header above the corridor opening

            group.add(partitionGroup);
            room5202Walls.vestibuleLeft = leftPartition;
            room5202Walls.vestibuleRight = rightPartition;

            // ========== FRONT WALL (+Z) - Windows (exterior) ==========
            const frontWallGroup = new THREE.Group();
            const frontWallBase = new THREE.Mesh(new THREE.BoxGeometry(ROOM_5202_WIDTH, RECT_WINDOW_SILL, WALL_THICKNESS), wallMaterial);
            frontWallBase.position.set(0, RECT_WINDOW_SILL / 2, ROOM_5202_DEPTH / 2);
            frontWallGroup.add(frontWallBase);
            const frontWallTop = new THREE.Mesh(new THREE.BoxGeometry(ROOM_5202_WIDTH, CEILING_HEIGHT - RECT_WINDOW_SILL - RECT_WINDOW_HEIGHT, WALL_THICKNESS), wallMaterial);
            frontWallTop.position.set(0, RECT_WINDOW_SILL + RECT_WINDOW_HEIGHT + (CEILING_HEIGHT - RECT_WINDOW_SILL - RECT_WINDOW_HEIGHT) / 2, ROOM_5202_DEPTH / 2);
            frontWallGroup.add(frontWallTop);
            // Window pillars and windows
            const windowSpacing = ROOM_5202_WIDTH / 3;
            for (let i = 0; i < 2; i++) {
                const win = createRectWindow(RECT_WINDOW_WIDTH, RECT_WINDOW_HEIGHT);
                win.position.set(-ROOM_5202_WIDTH / 4 + i * windowSpacing, RECT_WINDOW_SILL + RECT_WINDOW_HEIGHT / 2, ROOM_5202_DEPTH / 2 - 0.01);
                frontWallGroup.add(win);
                const pillar = new THREE.Mesh(new THREE.BoxGeometry(windowSpacing - RECT_WINDOW_WIDTH, RECT_WINDOW_HEIGHT, WALL_THICKNESS), wallMaterial);
                pillar.position.set(-ROOM_5202_WIDTH / 4 + (i + 0.5) * windowSpacing / 2, RECT_WINDOW_SILL + RECT_WINDOW_HEIGHT / 2, ROOM_5202_DEPTH / 2);
                frontWallGroup.add(pillar);
            }
            group.add(frontWallGroup);
            room5202Walls.front = frontWallGroup;

            // ========== LEFT WALL (-X) - Full length exterior wall ==========
            const leftWall = new THREE.Mesh(new THREE.BoxGeometry(WALL_THICKNESS, CEILING_HEIGHT, ROOM_5202_DEPTH), wallMaterial);
            leftWall.position.set(-ROOM_5202_WIDTH / 2, CEILING_HEIGHT / 2, 0);
            group.add(leftWall);
            room5202Walls.left = leftWall;

            // ========== RIGHT WALL (+X) - Shared wall with door to Room 5203 ==========
            const rightWallGroup = new THREE.Group();
            // Wall segments around door to 5203 (door positioned in main room area, not vestibule)
            const doorZPosition = 0.5;  // Door to 5203 is in the main room area
            const rightWall1 = new THREE.Mesh(new THREE.BoxGeometry(WALL_THICKNESS, CEILING_HEIGHT, ROOM_5202_DEPTH / 2 - DOOR_WIDTH / 2 + doorZPosition), wallMaterial);
            rightWall1.position.set(ROOM_5202_WIDTH / 2, CEILING_HEIGHT / 2, -ROOM_5202_DEPTH / 4 + doorZPosition / 2 - DOOR_WIDTH / 4);
            rightWallGroup.add(rightWall1);
            const rightWall2 = new THREE.Mesh(new THREE.BoxGeometry(WALL_THICKNESS, CEILING_HEIGHT, ROOM_5202_DEPTH / 2 - DOOR_WIDTH / 2 - doorZPosition), wallMaterial);
            rightWall2.position.set(ROOM_5202_WIDTH / 2, CEILING_HEIGHT / 2, ROOM_5202_DEPTH / 4 - doorZPosition / 2 + DOOR_WIDTH / 4);
            rightWallGroup.add(rightWall2);
            const rightDoorHeader = new THREE.Mesh(new THREE.BoxGeometry(WALL_THICKNESS, CEILING_HEIGHT - DOOR_HEIGHT, DOOR_WIDTH), wallMaterial);
            rightDoorHeader.position.set(ROOM_5202_WIDTH / 2, DOOR_HEIGHT + (CEILING_HEIGHT - DOOR_HEIGHT) / 2, doorZPosition);
            rightWallGroup.add(rightDoorHeader);
            group.add(rightWallGroup);
            room5202Walls.right = rightWallGroup;

            // ========== CEILING ==========
            const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(ROOM_5202_WIDTH, ROOM_5202_DEPTH), wallMaterial);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.set(0, CEILING_HEIGHT, 0);
            ceiling.userData.isCeiling = true;
            ceilingsGroup.add(ceiling);
            group.add(ceilingsGroup);

            // ========== FURNITURE ==========
            // Display table with colorful cloth (in main room area, past the vestibule)
            const mainRoomZ = VESTIBULE_DEPTH / 2 + 0.5;
            const tableCloth = new THREE.Mesh(new THREE.BoxGeometry(2.1, 0.02, 0.9), new THREE.MeshLambertMaterial({ color: 0xffd93d }));
            tableCloth.position.set(0, 0.74, mainRoomZ);
            group.add(tableCloth);
            const displayTable = new THREE.Mesh(new THREE.BoxGeometry(2, 0.72, 0.8), woodMaterial);
            displayTable.position.set(0, 0.36, mainRoomZ);
            group.add(displayTable);

            // Books on table
            const bookColors = [0x4ecdc4, 0xff6b6b, 0xffd93d, 0x45b7d1, 0x96ceb4, 0xdfe6e9, 0x74b9ff, 0xe17055];
            for (let i = 0; i < 10; i++) {
                const book = new THREE.Mesh(new THREE.BoxGeometry(0.12 + Math.random() * 0.08, 0.015, 0.16 + Math.random() * 0.06), new THREE.MeshLambertMaterial({ color: bookColors[i % bookColors.length] }));
                book.position.set(-0.7 + (i % 5) * 0.3 + (Math.random() - 0.5) * 0.1, 0.76 + Math.floor(i / 5) * 0.02, mainRoomZ + (Math.random() - 0.5) * 0.3);
                book.rotation.y = Math.random() * 0.5 - 0.25;
                group.add(book);
            }

            // Floor cushions (near window wall for listening)
            const cushion1 = createFloorCushion(0xfd7e14, 0.6);
            cushion1.position.set(-0.8, 0.03, ROOM_5202_DEPTH / 3);
            group.add(cushion1);
            const cushion2 = createFloorCushion(0x20c997, 0.55);
            cushion2.position.set(0.3, 0.03, ROOM_5202_DEPTH / 3 + 0.3);
            group.add(cushion2);
            const cushion3 = createFloorCushion(0xd63384, 0.5);
            cushion3.position.set(-0.2, 0.03, ROOM_5202_DEPTH / 3 - 0.3);
            group.add(cushion3);

            // Bookshelf against left partition wall
            const smallShelf = createWoodenBookshelf(1.2, 1.6, 3);
            smallShelf.position.set(-ROOM_5202_WIDTH / 2 + PARTITION_LENGTH + 0.2, 0, -ROOM_5202_DEPTH / 2 + VESTIBULE_DEPTH + 0.1);
            smallShelf.rotation.y = Math.PI / 2;
            group.add(smallShelf);

            // Potted plant
            const plant = createPottedPlant();
            plant.position.set(ROOM_5202_WIDTH / 2 - 0.4, 0, ROOM_5202_DEPTH / 3);
            group.add(plant);

            // Pendant light (in main room)
            const pendant = createPendantLight();
            pendant.position.set(0, CEILING_HEIGHT - 0.8, mainRoomZ);
            group.add(pendant);

            return group;
        }

        // ============ ROOM 5203 - READING ROOM ============
        // LAYOUT: Windows on FRONT (+Z), Door to corridor on BACK (-Z), Door to 5202 on LEFT (-X)
        function createRoom5203() {
            const group = new THREE.Group();

            // Floor
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(ROOM_5203_WIDTH, ROOM_5203_DEPTH), floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(0, 0.01, 0);
            group.add(floor);

            // BACK WALL (-Z) - Door to corridor + Poster wall
            const backWallGroup = new THREE.Group();
            const backWall1 = new THREE.Mesh(new THREE.BoxGeometry((ROOM_5203_WIDTH - DOOR_WIDTH) / 2, CEILING_HEIGHT, WALL_THICKNESS), brickMaterial);
            backWall1.position.set(-ROOM_5203_WIDTH / 4 - DOOR_WIDTH / 4, CEILING_HEIGHT / 2, -ROOM_5203_DEPTH / 2);
            backWallGroup.add(backWall1);
            const backWall2 = new THREE.Mesh(new THREE.BoxGeometry((ROOM_5203_WIDTH - DOOR_WIDTH) / 2, CEILING_HEIGHT, WALL_THICKNESS), brickMaterial);
            backWall2.position.set(ROOM_5203_WIDTH / 4 + DOOR_WIDTH / 4, CEILING_HEIGHT / 2, -ROOM_5203_DEPTH / 2);
            backWallGroup.add(backWall2);
            const backDoorHeader = new THREE.Mesh(new THREE.BoxGeometry(DOOR_WIDTH, CEILING_HEIGHT - DOOR_HEIGHT, WALL_THICKNESS), brickMaterial);
            backDoorHeader.position.set(0, DOOR_HEIGHT + (CEILING_HEIGHT - DOOR_HEIGHT) / 2, -ROOM_5203_DEPTH / 2);
            backWallGroup.add(backDoorHeader);
            // Poster wall on back wall sections
            const posterWallLeft = createPosterWall((ROOM_5203_WIDTH - DOOR_WIDTH) / 2 - 0.1, CEILING_HEIGHT - 0.3);
            posterWallLeft.position.set(-ROOM_5203_WIDTH / 4 - DOOR_WIDTH / 4, CEILING_HEIGHT / 2, -ROOM_5203_DEPTH / 2 + WALL_THICKNESS / 2 + 0.02);
            backWallGroup.add(posterWallLeft);
            const posterWallRight = createPosterWall((ROOM_5203_WIDTH - DOOR_WIDTH) / 2 - 0.1, CEILING_HEIGHT - 0.3);
            posterWallRight.position.set(ROOM_5203_WIDTH / 4 + DOOR_WIDTH / 4, CEILING_HEIGHT / 2, -ROOM_5203_DEPTH / 2 + WALL_THICKNESS / 2 + 0.02);
            backWallGroup.add(posterWallRight);
            group.add(backWallGroup);
            room5203Walls.back = backWallGroup;

            // FRONT WALL (+Z) - Arched windows (exterior)
            const frontWallGroup = new THREE.Group();
            const frontWallBase = new THREE.Mesh(new THREE.BoxGeometry(ROOM_5203_WIDTH, ARCH_WINDOW_SILL, WALL_THICKNESS), brickMaterial);
            frontWallBase.position.set(0, ARCH_WINDOW_SILL / 2, ROOM_5203_DEPTH / 2);
            frontWallGroup.add(frontWallBase);
            const frontWallTop = new THREE.Mesh(new THREE.BoxGeometry(ROOM_5203_WIDTH, CEILING_HEIGHT - ARCH_WINDOW_SILL - ARCH_WINDOW_HEIGHT - 0.2, WALL_THICKNESS), brickMaterial);
            frontWallTop.position.set(0, ARCH_WINDOW_SILL + ARCH_WINDOW_HEIGHT + 0.2 + (CEILING_HEIGHT - ARCH_WINDOW_SILL - ARCH_WINDOW_HEIGHT - 0.2) / 2, ROOM_5203_DEPTH / 2);
            frontWallGroup.add(frontWallTop);
            // Arched windows
            const archWindowSpacing = ROOM_5203_WIDTH / 3;
            for (let i = 0; i < 2; i++) {
                const archedWin = createArchedWindow(ARCH_WINDOW_WIDTH, ARCH_WINDOW_HEIGHT, ARCH_RADIUS, true);
                archedWin.position.set(-ROOM_5203_WIDTH / 4 + i * archWindowSpacing, ARCH_WINDOW_SILL, ROOM_5203_DEPTH / 2 - 0.01);
                frontWallGroup.add(archedWin);
                const pillar = new THREE.Mesh(new THREE.BoxGeometry(archWindowSpacing - ARCH_WINDOW_WIDTH - 0.3, ARCH_WINDOW_HEIGHT, WALL_THICKNESS), brickMaterial);
                pillar.position.set(-ROOM_5203_WIDTH / 4 + (i + 0.5) * archWindowSpacing / 2, ARCH_WINDOW_SILL + ARCH_WINDOW_HEIGHT / 2, ROOM_5203_DEPTH / 2);
                frontWallGroup.add(pillar);
            }
            group.add(frontWallGroup);
            room5203Walls.front = frontWallGroup;

            // LEFT WALL (-X) - Shared wall with door to Room 5202
            const leftWallGroup = new THREE.Group();
            const leftWall1 = new THREE.Mesh(new THREE.BoxGeometry(WALL_THICKNESS, CEILING_HEIGHT, (ROOM_5203_DEPTH - DOOR_WIDTH) / 2), brickMaterial);
            leftWall1.position.set(-ROOM_5203_WIDTH / 2, CEILING_HEIGHT / 2, -ROOM_5203_DEPTH / 4 - DOOR_WIDTH / 4);
            leftWallGroup.add(leftWall1);
            const leftWall2 = new THREE.Mesh(new THREE.BoxGeometry(WALL_THICKNESS, CEILING_HEIGHT, (ROOM_5203_DEPTH - DOOR_WIDTH) / 2), brickMaterial);
            leftWall2.position.set(-ROOM_5203_WIDTH / 2, CEILING_HEIGHT / 2, ROOM_5203_DEPTH / 4 + DOOR_WIDTH / 4);
            leftWallGroup.add(leftWall2);
            const leftDoorHeader = new THREE.Mesh(new THREE.BoxGeometry(WALL_THICKNESS, CEILING_HEIGHT - DOOR_HEIGHT, DOOR_WIDTH), brickMaterial);
            leftDoorHeader.position.set(-ROOM_5203_WIDTH / 2, DOOR_HEIGHT + (CEILING_HEIGHT - DOOR_HEIGHT) / 2, 0);
            leftWallGroup.add(leftDoorHeader);
            group.add(leftWallGroup);
            room5203Walls.left = leftWallGroup;

            // RIGHT WALL (+X) - Solid exterior wall
            const rightWall = new THREE.Mesh(new THREE.BoxGeometry(WALL_THICKNESS, CEILING_HEIGHT, ROOM_5203_DEPTH), brickMaterial);
            rightWall.position.set(ROOM_5203_WIDTH / 2, CEILING_HEIGHT / 2, 0);
            group.add(rightWall);
            room5203Walls.right = rightWall;

            // Ceiling
            const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(ROOM_5203_WIDTH, ROOM_5203_DEPTH), wallMaterial);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.set(0, CEILING_HEIGHT, 0);
            ceiling.userData.isCeiling = true;
            ceilingsGroup.add(ceiling);
            group.add(ceilingsGroup);

            // FURNITURE - Reading area

            // Layered rugs
            const mainRug = createLayeredRug(3.5, 2.5, 0x8b2942);
            mainRug.position.set(0, 0, 0);
            group.add(mainRug);
            const rug2 = createLayeredRug(2.2, 1.8, 0x2d5a5a);
            rug2.position.set(-0.6, 0.02, -0.3);
            rug2.rotation.y = -0.15;
            group.add(rug2);

            // Tufted floor mattress
            const floorMattress = createTuftedFloorMattress(2.2, 1.4);
            floorMattress.position.set(0, 0.05, 0);
            group.add(floorMattress);

            // Floor cushions around mattress
            const cushionColors = [0xd63384, 0xdc3545, 0x20c997, 0xfd7e14, 0xffc107, 0x6c757d];
            const cushionPositions = [[-0.8, 0.5], [0.7, 0.3], [-0.4, 1.2], [0.9, 1.0], [-1.1, 0.8], [1.1, 0.5]];
            cushionPositions.forEach((pos, i) => {
                const cushion = createFloorCushion(cushionColors[i], 0.5 + Math.random() * 0.2);
                cushion.position.set(pos[0], 0.15, pos[1]);
                group.add(cushion);
            });

            // Low coffee table
            const coffeeTable = createLowCoffeeTable();
            coffeeTable.position.set(0, 0.15, 0.8);
            group.add(coffeeTable);

            // Book displays near back wall
            const bookDisplay1 = createRedBookDisplay();
            bookDisplay1.position.set(-1.2, 0, -ROOM_5203_DEPTH / 2 + 1);
            group.add(bookDisplay1);
            const bookDisplay2 = createRedBookDisplay();
            bookDisplay2.position.set(1.2, 0, -ROOM_5203_DEPTH / 2 + 1);
            group.add(bookDisplay2);

            // Bookshelf near side wall
            const bookshelf = createWoodenBookshelf(2, 2.2, 4);
            bookshelf.position.set(ROOM_5203_WIDTH / 2 - 0.3, 0, -1);
            bookshelf.rotation.y = -Math.PI / 2;
            group.add(bookshelf);

            // Plants
            const plant1 = createPottedPlant();
            plant1.position.set(ROOM_5203_WIDTH / 2 - 0.4, 0, ROOM_5203_DEPTH / 3);
            group.add(plant1);
            const plant2 = createPottedPlant();
            plant2.position.set(-ROOM_5203_WIDTH / 2 + 0.4, 0, ROOM_5203_DEPTH / 3);
            group.add(plant2);

            // Pendant lights
            const pendant1 = createPendantLight();
            pendant1.position.set(-1, CEILING_HEIGHT - 0.8, 0);
            group.add(pendant1);
            const pendant2 = createPendantLight();
            pendant2.position.set(1, CEILING_HEIGHT - 0.8, 0.5);
            group.add(pendant2);

            return group;
        }

        // Create and position rooms
        const room5202 = createRoom5202();
        room5202.position.set(ROOM_5202_X, 0, 0);
        scene.add(room5202);

        const room5203 = createRoom5203();
        room5203.position.set(ROOM_5203_X, 0, 0);
        scene.add(room5203);

        // Room labels
        function createLabel(text, position) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 128;
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 32px Helvetica';
            ctx.textAlign = 'center';
            ctx.fillText(text, canvas.width / 2, canvas.height / 2 + 10);
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(2.5, 0.6, 1);
            sprite.position.copy(position);
            return sprite;
        }

        labelsGroup.add(createLabel('ROOM 5202 - SPECIAL SPECIAL', new THREE.Vector3(ROOM_5202_X, CEILING_HEIGHT + 0.5, 0)));
        labelsGroup.add(createLabel('ROOM 5203 - READING ROOM', new THREE.Vector3(ROOM_5203_X, CEILING_HEIGHT + 0.5, 0)));
        scene.add(labelsGroup);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
        directionalLight.position.set(10, 15, 10);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
        fillLight.position.set(-10, 10, -10);
        scene.add(fillLight);
        const room5202Light = new THREE.PointLight(0xffffee, 0.4, 12);
        room5202Light.position.set(ROOM_5202_X, CEILING_HEIGHT - 0.5, 0);
        scene.add(room5202Light);
        const room5203Light = new THREE.PointLight(0xffffee, 0.4, 12);
        room5203Light.position.set(ROOM_5203_X, CEILING_HEIGHT - 0.5, 0);
        scene.add(room5203Light);

        // Camera controls
        let isMouseDown = false;
        let mouseX = 0, mouseY = 0;
        let targetRotationX = 0, targetRotationY = 0.4;
        let currentRotationX = 0, currentRotationY = 0.4;
        let cameraDistance = 18;
        let cameraTarget = new THREE.Vector3(0, 2, 0);

        camera.position.set(0, 12, 18);
        camera.lookAt(cameraTarget);

        container.addEventListener('mousedown', (e) => { isMouseDown = true; mouseX = e.clientX; mouseY = e.clientY; });
        container.addEventListener('mouseup', () => isMouseDown = false);
        container.addEventListener('mouseleave', () => isMouseDown = false);

        container.addEventListener('mousemove', (e) => {
            if (!isMouseDown) return;
            targetRotationX += (e.clientX - mouseX) * 0.005;
            targetRotationY += (e.clientY - mouseY) * 0.005;
            targetRotationY = Math.max(-0.5, Math.min(1.2, targetRotationY));
            mouseX = e.clientX; mouseY = e.clientY;
        });

        container.addEventListener('wheel', (e) => {
            cameraDistance += e.deltaY * 0.01;
            cameraDistance = Math.max(3, Math.min(35, cameraDistance));
        });

        const keys = {};
        document.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
        document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

        // Touch controls
        container.addEventListener('touchstart', (e) => { isMouseDown = true; mouseX = e.touches[0].clientX; mouseY = e.touches[0].clientY; });
        container.addEventListener('touchend', () => isMouseDown = false);
        container.addEventListener('touchmove', (e) => {
            if (!isMouseDown) return;
            targetRotationX += (e.touches[0].clientX - mouseX) * 0.005;
            targetRotationY += (e.touches[0].clientY - mouseY) * 0.005;
            targetRotationY = Math.max(-0.5, Math.min(1.2, targetRotationY));
            mouseX = e.touches[0].clientX; mouseY = e.touches[0].clientY;
        });

        // View presets - CORRECTED FOR DOOR ENTRY PERSPECTIVE
        // Entry views: Camera at BACK (door, -Z) looking FORWARD toward windows (+Z)
        // rotX=0 means camera is at front looking back, rotX=Math.PI means camera at back looking forward
        const views = {
            overview: { rotX: 0, rotY: 0.5, dist: 18, target: new THREE.Vector3(0, 2, 0) },
            floorPlan: { rotX: 0, rotY: 1.5, dist: 14, target: new THREE.Vector3(0, 0, 0) },
            // Room 5202 views - Entry through vestibule door, looking toward windows
            // rotX=Math.PI puts camera at -Z (door) looking toward +Z (windows)
            room5202Entry: { rotX: Math.PI, rotY: 0.15, dist: 3, target: new THREE.Vector3(ROOM_5202_X, 1.5, -ROOM_5202_DEPTH / 2 + 1) },
            room5202Inside: { rotX: Math.PI, rotY: 0.2, dist: 5, target: new THREE.Vector3(ROOM_5202_X, 1.5, 0) },
            room5202Windows: { rotX: Math.PI, rotY: 0.15, dist: 4, target: new THREE.Vector3(ROOM_5202_X, 1.5, ROOM_5202_DEPTH / 4) },
            room5202Table: { rotX: Math.PI * 0.8, rotY: 0.25, dist: 4, target: new THREE.Vector3(ROOM_5202_X, 0.8, 0) },
            // Room 5203 views - Entry through corridor door, looking toward arched windows
            room5203Entry: { rotX: Math.PI, rotY: 0.15, dist: 3, target: new THREE.Vector3(ROOM_5203_X, 1.5, -ROOM_5203_DEPTH / 2 + 1) },
            room5203Inside: { rotX: Math.PI, rotY: 0.2, dist: 6, target: new THREE.Vector3(ROOM_5203_X, 1.5, 0) },
            room5203Windows: { rotX: Math.PI, rotY: 0.15, dist: 4, target: new THREE.Vector3(ROOM_5203_X, 1.5, ROOM_5203_DEPTH / 4) },
            room5203Seating: { rotX: Math.PI * 0.7, rotY: 0.2, dist: 4, target: new THREE.Vector3(ROOM_5203_X, 0.5, 0.5) },
            room5203Shelves: { rotX: Math.PI * 1.2, rotY: 0.2, dist: 5, target: new THREE.Vector3(ROOM_5203_X, 1.2, -ROOM_5203_DEPTH / 3) }
        };

        function animateToView(view, duration = 1500) {
            const startRotX = currentRotationX, startRotY = currentRotationY;
            const startDist = cameraDistance;
            const startTarget = cameraTarget.clone();
            const startTime = Date.now();

            function update() {
                const elapsed = Date.now() - startTime;
                const t = Math.min(elapsed / duration, 1);
                const eased = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;

                targetRotationX = startRotX + (view.rotX - startRotX) * eased;
                targetRotationY = startRotY + (view.rotY - startRotY) * eased;
                cameraDistance = startDist + (view.dist - startDist) * eased;
                cameraTarget.lerpVectors(startTarget, view.target, eased);

                if (t < 1) requestAnimationFrame(update);
            }
            update();
        }

        window.setView = function(viewName) { const view = views[viewName]; if (view) animateToView(view); };
        window.focusRoom = function(room) {
            if (room === 'room5202') setView('room5202Inside');
            else if (room === 'room5203') setView('room5203Inside');
        };

        let tourRunning = false;
        window.startTour = function() {
            if (tourRunning) return;
            tourRunning = true;
            // Tour starts from entry doors, walking through each room
            const stops = ['overview', 'room5202Entry', 'room5202Inside', 'room5202Windows', 'room5202Table', 'room5203Entry', 'room5203Inside', 'room5203Windows', 'room5203Seating', 'room5203Shelves', 'overview'];
            let i = 0;
            function next() {
                if (i >= stops.length) { tourRunning = false; return; }
                animateToView(views[stops[i++]], 2000);
                setTimeout(next, 3500);
            }
            next();
        };

        // Toggle functions
        let showGrid = true, showLabels = true, showCeiling = true, hideNearWall = false, showWireframe = false;

        window.toggleGrid = function() {
            showGrid = !showGrid;
            gridHelper.visible = showGrid;
            document.getElementById('gridBtn').classList.toggle('active', showGrid);
        };

        window.toggleLabels = function() {
            showLabels = !showLabels;
            labelsGroup.visible = showLabels;
            document.getElementById('labelsBtn').classList.toggle('active', showLabels);
        };

        window.toggleCeiling = function() {
            showCeiling = !showCeiling;
            ceilingsGroup.traverse((obj) => {
                if (obj.userData.isCeiling || obj.isMesh) obj.visible = showCeiling;
            });
            document.getElementById('ceilingBtn').classList.toggle('active', showCeiling);
        };

        window.toggleNearWall = function() {
            hideNearWall = !hideNearWall;
            document.getElementById('nearWallBtn').classList.toggle('active', hideNearWall);
        };

        window.toggleWireframe = function() {
            showWireframe = !showWireframe;
            document.getElementById('wireframeBtn').classList.toggle('active', showWireframe);
            scene.traverse((obj) => { if (obj.isMesh && obj.material) obj.material.wireframe = showWireframe; });
        };

        window.captureScreenshot = function() {
            const link = document.createElement('a');
            link.download = 'PanafricanLibrary_ReadingRoom.png';
            link.href = renderer.domElement.toDataURL('image/png');
            link.click();
        };

        // Wall visibility based on camera position
        function updateWallVisibility() {
            if (!hideNearWall) {
                // Show all walls
                Object.values(room5202Walls).forEach(w => { if (w) w.visible = true; });
                Object.values(room5203Walls).forEach(w => { if (w) w.visible = true; });
                return;
            }

            // Determine which wall is closest to camera
            const camX = camera.position.x;
            const camZ = camera.position.z;

            // Room 5202 walls (including vestibule)
            if (room5202Walls.front) room5202Walls.front.visible = camZ < 0;
            if (room5202Walls.back) room5202Walls.back.visible = camZ > -ROOM_5202_DEPTH / 2;
            if (room5202Walls.left) room5202Walls.left.visible = camX > ROOM_5202_X;
            if (room5202Walls.right) room5202Walls.right.visible = camX < ROOM_5202_X;
            if (room5202Walls.vestibuleLeft) room5202Walls.vestibuleLeft.visible = camX > ROOM_5202_X;
            if (room5202Walls.vestibuleRight) room5202Walls.vestibuleRight.visible = camX < ROOM_5202_X;

            // Room 5203 walls
            if (room5203Walls.front) room5203Walls.front.visible = camZ < 0;
            if (room5203Walls.back) room5203Walls.back.visible = camZ > 0;
            if (room5203Walls.left) room5203Walls.left.visible = camX > ROOM_5203_X;
            if (room5203Walls.right) room5203Walls.right.visible = camX < ROOM_5203_X;
        }

        // Auto ceiling visibility based on camera height
        function updateCeilingVisibility() {
            const camY = camera.position.y;
            const isAbove = camY > CEILING_HEIGHT + 1;

            if (showCeiling) {
                // Auto-hide ceiling when viewing from above
                ceilingsGroup.traverse((obj) => {
                    if (obj.userData.isCeiling || obj.isMesh) {
                        obj.visible = !isAbove;
                    }
                });
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            currentRotationX += (targetRotationX - currentRotationX) * 0.05;
            currentRotationY += (targetRotationY - currentRotationY) * 0.05;

            if (keys['w']) cameraTarget.z -= 0.1;
            if (keys['s']) cameraTarget.z += 0.1;
            if (keys['a']) cameraTarget.x -= 0.1;
            if (keys['d']) cameraTarget.x += 0.1;

            camera.position.x = cameraTarget.x + Math.sin(currentRotationX) * Math.cos(currentRotationY) * cameraDistance;
            camera.position.y = cameraTarget.y + Math.sin(currentRotationY) * cameraDistance;
            camera.position.z = cameraTarget.z + Math.cos(currentRotationX) * Math.cos(currentRotationY) * cameraDistance;
            camera.lookAt(cameraTarget);

            updateWallVisibility();
            updateCeilingVisibility();

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
