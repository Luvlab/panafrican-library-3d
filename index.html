<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Panafrican Library Will Not Be Colonized | Reading Room 3D</title>
    <meta name="description" content="A curatorial Reading Room conceived as a living archive of panafrican and diasporic publishing. Interactive 3D simulation.">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background: #1a1a1a;
            color: #fff;
            overflow: hidden;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px;
            border-radius: 8px;
            max-width: 320px;
            z-index: 100;
            border: 1px solid rgba(255,255,255,0.1);
        }
        /* Mobile responsive styles */
        @media (max-width: 768px) {
            #info-panel {
                top: 10px;
                left: 10px;
                right: 10px;
                max-width: none;
                padding: 12px;
            }
            #info-panel h1 { font-size: 14px; }
            #info-panel h2 { font-size: 9px; margin-bottom: 10px; }
            #info-panel p { font-size: 11px; margin-bottom: 10px; }
            .room-btn { padding: 6px 10px; font-size: 10px; }
            #controls-panel {
                top: auto;
                bottom: 180px;
                right: 10px;
                left: 10px;
                max-height: 40vh;
                display: flex;
                flex-wrap: wrap;
                gap: 5px;
                padding: 10px;
            }
            .control-section {
                flex: 1 1 45%;
                min-width: 140px;
                margin-bottom: 5px;
                padding-bottom: 5px;
            }
            .control-btn { padding: 6px 8px; font-size: 10px; }
            .section-title { font-size: 9px; margin-bottom: 5px; }
            #dimensions-panel { display: none; }
            #credits {
                bottom: 10px;
                right: 10px;
                left: auto;
                padding: 8px 10px;
                font-size: 8px;
            }
            #help-text {
                bottom: 150px;
                font-size: 10px;
                padding: 6px 12px;
            }
            #toggle-btns {
                bottom: 100px;
                padding: 0 10px;
            }
            .toggle-btn { padding: 5px 8px; font-size: 9px; }
            #capture-btn {
                bottom: 60px;
                padding: 8px 15px;
                font-size: 11px;
            }
        }
        @media (max-width: 480px) {
            #info-panel {
                padding: 10px;
            }
            #info-panel h1 { font-size: 12px; }
            #info-panel p { display: none; }
            #controls-panel {
                max-height: 35vh;
            }
            .control-section { flex: 1 1 100%; }
            #credits { display: none; }
        }
        #info-panel h1 {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        #info-panel h2 {
            font-size: 11px;
            font-weight: 400;
            color: #888;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        #info-panel p {
            font-size: 13px;
            line-height: 1.6;
            color: #ccc;
            margin-bottom: 15px;
        }
        .room-btn {
            display: inline-block;
            padding: 8px 14px;
            margin: 4px 4px 4px 0;
            background: rgba(100, 149, 237, 0.3);
            border: 1px solid cornflowerblue;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }
        .room-btn:hover {
            background: cornflowerblue;
        }
        #controls-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            border: 1px solid rgba(255,255,255,0.1);
            max-height: 80vh;
            overflow-y: auto;
        }
        .control-section {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .control-section:last-child { border-bottom: none; }
        .section-title {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }
        .control-btn {
            display: block;
            width: 100%;
            padding: 8px 12px;
            margin: 4px 0;
            background: rgba(255,255,255,0.1);
            border: none;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            text-align: left;
            transition: all 0.3s;
        }
        .control-btn:hover {
            background: rgba(255,255,255,0.2);
        }
        .control-btn.active {
            background: rgba(100, 149, 237, 0.4);
            border: 1px solid cornflowerblue;
        }
        #dimensions-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.85);
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            border: 1px solid rgba(255,255,255,0.1);
            font-size: 11px;
            max-width: 420px;
        }
        #dimensions-panel h3 {
            font-size: 12px;
            margin-bottom: 10px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .dim-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .dim-row:last-child { border-bottom: none; }
        .dim-label { color: #888; }
        .dim-value { color: #fff; font-family: monospace; }
        #credits {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 12px 15px;
            border-radius: 8px;
            z-index: 100;
            border: 1px solid rgba(255,255,255,0.1);
            font-size: 10px;
            text-align: right;
        }
        #credits a { color: cornflowerblue; text-decoration: none; }
        #credits a:hover { text-decoration: underline; }
        #help-text {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 12px;
            color: #888;
            z-index: 100;
        }
        #toggle-btns {
            position: absolute;
            bottom: 130px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
            z-index: 100;
            max-width: 500px;
        }
        .toggle-btn {
            padding: 6px 12px;
            background: rgba(0,0,0,0.7);
            border: 1px solid rgba(255,255,255,0.2);
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }
        .toggle-btn.active {
            background: rgba(100, 149, 237, 0.5);
            border-color: cornflowerblue;
        }
        #capture-btn {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background: cornflowerblue;
            border: none;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            z-index: 100;
        }
        .icon { margin-right: 6px; }
        #moodboard-btn {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(calc(-50% - 40px));
            padding: 10px 20px;
            background: #8b2942;
            border: none;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            z-index: 100;
        }
        #moodboard-btn:hover { background: #a03050; }
        #capture-btn { transform: translateX(calc(-50% - 120px)); }
        .modal-hidden { display: none; }
        #moodboard-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 1000;
            overflow-y: auto;
            padding: 40px 20px;
        }
        .modal-content {
            max-width: 900px;
            margin: 0 auto;
            background: #1a1a1a;
            border-radius: 12px;
            padding: 30px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .modal-close {
            position: absolute;
            top: 20px;
            right: 30px;
            background: none;
            border: none;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
        }
        .modal-content h2 {
            font-size: 24px;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        .modal-content > p {
            color: #888;
            margin-bottom: 25px;
            font-size: 14px;
        }
        .moodboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }
        .moodboard-section {
            background: rgba(255,255,255,0.05);
            padding: 20px;
            border-radius: 8px;
        }
        .moodboard-section h3 {
            font-size: 14px;
            color: cornflowerblue;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .image-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        .ref-image {
            aspect-ratio: 4/3;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .ref-image span {
            background: rgba(0,0,0,0.6);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 11px;
        }
        .color-palette {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .color-swatch {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .color-swatch:hover { transform: scale(1.1); }
        .design-list {
            list-style: none;
            font-size: 13px;
            line-height: 2;
        }
        .layout-info p {
            font-size: 12px;
            line-height: 1.8;
            color: #ccc;
            margin-bottom: 10px;
        }
        /* Mood Board Image Gallery */
        .moodboard-images {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        .moodboard-image-item {
            position: relative;
            border-radius: 6px;
            overflow: hidden;
            cursor: pointer;
            aspect-ratio: 4/3;
            background: #333;
        }
        .moodboard-image-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.3s, opacity 0.3s;
        }
        .moodboard-image-item:hover img {
            transform: scale(1.05);
        }
        .moodboard-image-item .image-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0,0,0,0.8));
            padding: 20px 8px 8px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .moodboard-image-item:hover .image-overlay {
            opacity: 1;
        }
        .moodboard-image-item .image-title {
            font-size: 10px;
            color: #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .moodboard-image-item.editing .image-actions {
            display: flex;
        }
        .image-actions {
            position: absolute;
            top: 5px;
            right: 5px;
            display: none;
            gap: 4px;
        }
        .image-action-btn {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .image-action-btn.delete { background: #e53935; color: #fff; }
        .image-action-btn.move { background: #555; color: #fff; cursor: grab; }
        .image-action-btn:hover { opacity: 0.8; }
        /* Slideshow Modal */
        #slideshow-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            z-index: 2000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        #slideshow-modal.active { display: flex; }
        .slideshow-image-container {
            max-width: 90vw;
            max-height: 75vh;
            position: relative;
        }
        .slideshow-image-container img {
            max-width: 100%;
            max-height: 75vh;
            border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }
        .slideshow-controls {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            align-items: center;
        }
        .slideshow-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: #fff;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.2s;
        }
        .slideshow-btn:hover { background: rgba(255,255,255,0.2); }
        .slideshow-btn.nav { padding: 12px 20px; font-size: 20px; }
        .slideshow-info {
            color: #888;
            font-size: 14px;
        }
        .slideshow-caption {
            color: #fff;
            text-align: center;
            margin-top: 15px;
            font-size: 16px;
            max-width: 600px;
        }
        .slideshow-close {
            position: absolute;
            top: 20px;
            right: 30px;
            background: none;
            border: none;
            color: #fff;
            font-size: 32px;
            cursor: pointer;
        }
        /* Mood Board Edit Mode */
        .moodboard-toolbar {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        .moodboard-toolbar-btn {
            padding: 8px 16px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.05);
            color: #fff;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }
        .moodboard-toolbar-btn:hover { background: rgba(255,255,255,0.15); }
        .moodboard-toolbar-btn.active { background: #8b2942; border-color: #8b2942; }
        .moodboard-toolbar-btn.primary { background: #2e7d32; border-color: #2e7d32; }
        .add-image-form {
            display: none;
            background: rgba(255,255,255,0.05);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }
        .add-image-form.active { display: block; }
        .add-image-form input, .add-image-form select {
            width: 100%;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.2);
            background: rgba(0,0,0,0.3);
            color: #fff;
            margin-bottom: 10px;
            font-size: 13px;
        }
        .add-image-form input::placeholder { color: #888; }
        .drop-zone {
            border: 2px dashed rgba(255,255,255,0.3);
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            color: #888;
            margin-bottom: 10px;
            cursor: pointer;
            transition: border-color 0.2s, background 0.2s;
        }
        .drop-zone:hover, .drop-zone.dragover {
            border-color: #8b2942;
            background: rgba(139,41,66,0.1);
        }
        .drop-zone.has-file {
            border-color: #2e7d32;
            background: rgba(46,125,50,0.1);
        }
        @media (max-width: 768px) {
            #capture-btn, #moodboard-btn {
                transform: translateX(-50%);
                bottom: 20px;
            }
            #moodboard-btn { bottom: 60px; }
            .modal-content { padding: 20px; }
            .moodboard-grid { grid-template-columns: 1fr; }
        }
        /* Decorator Mode Styles */
        #decorator-btn {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(calc(-50% + 40px));
            padding: 10px 20px;
            background: #20c997;
            border: none;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            z-index: 100;
        }
        #decorator-btn:hover { background: #1aa87c; }
        #decorator-panel {
            position: fixed;
            top: 0;
            right: -350px;
            width: 350px;
            height: 100%;
            background: rgba(20,20,20,0.98);
            z-index: 1001;
            transition: right 0.3s ease;
            overflow-y: auto;
            border-left: 1px solid rgba(255,255,255,0.1);
        }
        #decorator-panel.open { right: 0; }
        .decorator-header {
            padding: 20px;
            background: rgba(0,0,0,0.5);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .decorator-header h2 { font-size: 16px; margin: 0; }
        .decorator-close {
            background: none;
            border: none;
            color: #fff;
            font-size: 20px;
            cursor: pointer;
        }
        .decorator-category {
            padding: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .decorator-category h3 {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #20c997;
            margin-bottom: 12px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .decorator-category h3::after { content: 'â–¼'; font-size: 8px; }
        .decorator-category.collapsed h3::after { content: 'â–¶'; }
        .decorator-category.collapsed .item-grid { display: none; }
        .decorator-category.collapsed .upload-section { display: none; }
        /* 3D File Upload Styles */
        .upload-section {
            padding: 10px;
            margin-bottom: 10px;
        }
        .file-drop-zone {
            border: 2px dashed rgba(255,255,255,0.3);
            border-radius: 8px;
            padding: 20px 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 10px;
        }
        .file-drop-zone:hover, .file-drop-zone.dragover {
            border-color: #20c997;
            background: rgba(32,201,151,0.1);
        }
        .file-drop-zone.has-file {
            border-color: #20c997;
            background: rgba(32,201,151,0.15);
        }
        .file-drop-zone .drop-icon { font-size: 28px; margin-bottom: 8px; }
        .file-drop-zone .drop-text { font-size: 11px; color: #888; }
        .file-drop-zone .drop-formats { font-size: 9px; color: #666; margin-top: 5px; }
        .uploaded-models-list {
            max-height: 200px;
            overflow-y: auto;
        }
        .uploaded-model-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 10px;
            background: rgba(255,255,255,0.05);
            border-radius: 4px;
            margin-bottom: 6px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .uploaded-model-item:hover { background: rgba(255,255,255,0.1); }
        .uploaded-model-item.selected { background: rgba(32,201,151,0.2); border: 1px solid #20c997; }
        .uploaded-model-info { flex: 1; min-width: 0; }
        .uploaded-model-name { font-size: 11px; color: #fff; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .uploaded-model-meta { font-size: 9px; color: #888; }
        .uploaded-model-actions { display: flex; gap: 5px; }
        .model-action-btn {
            width: 24px;
            height: 24px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .model-action-btn.delete { background: rgba(220,53,69,0.5); color: #fff; }
        .model-action-btn.place { background: rgba(32,201,151,0.5); color: #fff; }
        .item-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }
        .item-card {
            background: rgba(255,255,255,0.08);
            border-radius: 6px;
            padding: 8px;
            cursor: grab;
            text-align: center;
            transition: all 0.2s;
            border: 2px solid transparent;
            user-select: none;
        }
        .item-card:hover { background: rgba(255,255,255,0.15); }
        .item-card.selected { border-color: #20c997; background: rgba(32,201,151,0.2); }
        .item-card:active { cursor: grabbing; }
        .item-card.dragging { opacity: 0.5; transform: scale(0.95); }
        .item-preview {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 4px;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            background: transparent !important;
        }
        .item-name {
            font-size: 9px;
            color: #ccc;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .decorator-actions {
            padding: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .decorator-action-btn {
            flex: 1 1 45%;
            padding: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }
        .decorator-action-btn.primary { background: #20c997; color: #fff; }
        .decorator-action-btn.secondary { background: rgba(255,255,255,0.1); color: #fff; }
        .decorator-action-btn.danger { background: #dc3545; color: #fff; flex: 1 1 100%; }
        .decorator-action-btn:hover { opacity: 0.8; }
        .decorator-help {
            padding: 12px 15px;
            background: rgba(32,201,151,0.1);
            border-top: 1px solid rgba(32,201,151,0.3);
            font-size: 10px;
            color: #aaa;
            line-height: 1.6;
        }
        .decorator-help strong { color: #20c997; }
        #canvas-container.drag-over {
            outline: 3px dashed #20c997;
            outline-offset: -3px;
        }
        #canvas-container.drag-over::after {
            content: 'Drop to place';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(32,201,151,0.9);
            color: #fff;
            padding: 20px 40px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            pointer-events: none;
            z-index: 1000;
        }
        .decorator-instructions {
            padding: 15px;
            background: rgba(0,0,0,0.3);
            font-size: 11px;
            color: #888;
            line-height: 1.6;
        }
        .decorator-instructions strong { color: #fff; }
        #selected-item-info {
            padding: 15px;
            background: rgba(32,201,151,0.1);
            border-top: 1px solid rgba(32,201,151,0.3);
            display: none;
        }
        #selected-item-info.visible { display: block; }
        #selected-item-info h4 { font-size: 12px; margin-bottom: 8px; }
        .item-controls {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }
        .item-control-btn {
            padding: 6px 10px;
            background: rgba(255,255,255,0.1);
            border: none;
            color: #fff;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
        }
        .item-control-btn:hover { background: rgba(255,255,255,0.2); }
        .item-control-btn.danger { background: rgba(220,53,69,0.5); }
        .item-control-btn.danger:hover { background: rgba(220,53,69,0.7); }
        /* Wall art section special styling */
        .art-item-card {
            grid-column: span 2;
        }
        .art-item-card .item-preview {
            aspect-ratio: 4/3;
        }
        @media (max-width: 768px) {
            #decorator-btn { transform: translateX(-50%); bottom: 100px; }
            #decorator-panel { width: 100%; right: -100%; }
        }
        /* Admin Mode Styles */
        #admin-btn {
            position: absolute;
            top: 20px;
            right: 240px;
            padding: 8px 16px;
            background: rgba(139, 41, 66, 0.8);
            border: 1px solid #8b2942;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            z-index: 100;
        }
        #admin-btn:hover { background: #8b2942; }
        #admin-btn.logged-in { background: #20c997; border-color: #1aa87c; }
        #render-btn {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(calc(-50% + 120px));
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            z-index: 100;
        }
        #render-btn:hover { opacity: 0.9; }
        #render-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        /* Login Modal */
        #login-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 2000;
            display: none;
            justify-content: center;
            align-items: center;
        }
        #login-modal.visible { display: flex; }
        .login-box {
            background: #1a1a1a;
            padding: 40px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.1);
            max-width: 400px;
            width: 90%;
            text-align: center;
        }
        .login-box h2 { margin-bottom: 10px; font-size: 20px; }
        .login-box p { color: #888; margin-bottom: 25px; font-size: 13px; }
        .login-input {
            width: 100%;
            padding: 12px 15px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            color: #fff;
            font-size: 14px;
            margin-bottom: 15px;
        }
        .login-input:focus { outline: none; border-color: #8b2942; }
        .login-submit {
            width: 100%;
            padding: 12px;
            background: #8b2942;
            border: none;
            border-radius: 6px;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
        }
        .login-submit:hover { background: #a03050; }
        .login-cancel {
            background: transparent;
            border: 1px solid rgba(255,255,255,0.2);
            margin-top: 10px;
        }
        .login-error { color: #dc3545; font-size: 12px; margin-top: 10px; }
        /* Admin Panel */
        #admin-panel {
            position: fixed;
            top: 0;
            left: -400px;
            width: 400px;
            height: 100%;
            background: rgba(20,20,20,0.98);
            z-index: 1500;
            transition: left 0.3s ease;
            overflow-y: auto;
            border-right: 1px solid rgba(255,255,255,0.1);
        }
        #admin-panel.open { left: 0; }
        .admin-header {
            padding: 20px;
            background: linear-gradient(135deg, #8b2942 0%, #5a1a2a 100%);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .admin-header h2 { font-size: 16px; margin: 0; }
        .admin-user { font-size: 11px; color: rgba(255,255,255,0.7); }
        .admin-close {
            background: none;
            border: none;
            color: #fff;
            font-size: 20px;
            cursor: pointer;
        }
        .admin-tabs {
            display: flex;
            background: rgba(0,0,0,0.3);
        }
        .admin-tab {
            flex: 1;
            padding: 12px;
            background: transparent;
            border: none;
            color: #888;
            font-size: 11px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
        }
        .admin-tab:hover { color: #fff; }
        .admin-tab.active { color: #fff; border-bottom-color: #8b2942; }
        .admin-content { padding: 20px; }
        .admin-section {
            margin-bottom: 25px;
        }
        .admin-section h3 {
            font-size: 12px;
            color: #8b2942;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
        }
        .admin-input-group {
            margin-bottom: 12px;
        }
        .admin-input-group label {
            display: block;
            font-size: 11px;
            color: #888;
            margin-bottom: 5px;
        }
        .admin-input {
            width: 100%;
            padding: 10px;
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 4px;
            color: #fff;
            font-size: 12px;
        }
        .admin-input:focus { outline: none; border-color: #8b2942; }
        .admin-textarea {
            min-height: 80px;
            resize: vertical;
        }
        .admin-btn {
            padding: 10px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            margin-right: 8px;
            margin-bottom: 8px;
        }
        .admin-btn-primary { background: #8b2942; color: #fff; }
        .admin-btn-secondary { background: rgba(255,255,255,0.1); color: #fff; }
        .admin-btn-success { background: #20c997; color: #fff; }
        .admin-btn:hover { opacity: 0.8; }
        .saved-config-list {
            max-height: 200px;
            overflow-y: auto;
        }
        .saved-config-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: rgba(255,255,255,0.05);
            border-radius: 4px;
            margin-bottom: 8px;
        }
        .saved-config-item:hover { background: rgba(255,255,255,0.1); }
        .saved-config-name { font-size: 12px; }
        .saved-config-meta { font-size: 10px; color: #888; }
        .saved-config-actions { display: flex; gap: 5px; }
        .saved-config-btn {
            padding: 4px 8px;
            background: rgba(255,255,255,0.1);
            border: none;
            border-radius: 3px;
            color: #fff;
            font-size: 10px;
            cursor: pointer;
        }
        .saved-config-btn.danger { background: rgba(220,53,69,0.5); }
        .saved-config-btn.edit { background: rgba(255,193,7,0.5); }
        .saved-config-btn.move { cursor: grab; background: rgba(108,117,125,0.5); }
        .saved-config-item.dragging { opacity: 0.5; border: 1px dashed #8b2942; }
        .saved-config-item.drag-over { border-top: 2px solid #8b2942; }
        .saved-config-info { flex: 1; }
        .edit-inline-input {
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.2);
            color: #fff;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 12px;
            width: 100%;
            margin-bottom: 5px;
        }
        /* Render Modal */
        #render-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            z-index: 2000;
            display: none;
            justify-content: center;
            align-items: center;
        }
        #render-modal.visible { display: flex; }
        .render-box {
            background: #1a1a1a;
            padding: 30px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.1);
            max-width: 900px;
            width: 95%;
            max-height: 90vh;
            overflow-y: auto;
        }
        .render-box h2 { margin-bottom: 5px; }
        .render-box > p { color: #888; margin-bottom: 20px; font-size: 13px; }
        .render-preview {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        .render-preview-box {
            background: rgba(0,0,0,0.5);
            border-radius: 8px;
            padding: 15px;
        }
        .render-preview-box h4 {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 10px;
        }
        .render-preview-img {
            width: 100%;
            aspect-ratio: 16/10;
            background: #000;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #444;
            font-size: 12px;
            overflow: hidden;
        }
        .render-preview-img img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        .render-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }
        .render-style-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }
        .render-style-btn {
            padding: 10px;
            background: rgba(255,255,255,0.08);
            border: 2px solid transparent;
            border-radius: 6px;
            color: #fff;
            font-size: 10px;
            cursor: pointer;
            text-align: center;
        }
        .render-style-btn:hover { background: rgba(255,255,255,0.15); }
        .render-style-btn.active { border-color: #667eea; background: rgba(102,126,234,0.2); }
        .render-actions {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }
        .render-btn-generate {
            flex: 1;
            padding: 14px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 6px;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
        }
        .render-btn-generate:disabled { opacity: 0.5; cursor: not-allowed; }
        .render-btn-close {
            padding: 14px 24px;
            background: rgba(255,255,255,0.1);
            border: none;
            border-radius: 6px;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
        }
        .render-status {
            text-align: center;
            padding: 20px;
            color: #888;
            font-size: 13px;
        }
        .render-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
            vertical-align: middle;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        @media (max-width: 768px) {
            #admin-btn { right: 10px; top: auto; bottom: 140px; }
            #render-btn { transform: translateX(-50%); bottom: 180px; }
            #admin-panel { width: 100%; left: -100%; }
            .render-preview { grid-template-columns: 1fr; }
            .render-options { grid-template-columns: 1fr; }
            .render-style-grid { grid-template-columns: repeat(2, 1fr); }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div id="info-panel">
        <h1>The Panafrican Library Will Not Be Colonized</h1>
        <h2>Reading Room â€¢ Interactive 3D</h2>
        <p>A curatorial Reading Room conceived as a living archive of panafrican and diasporic publishing. A space to read, listen, and slow down.</p>
        <button class="room-btn" onclick="focusRoom('roomS202')">Room S202 â€” Special Special</button>
        <button class="room-btn" onclick="focusRoom('roomS203')">Room S203 â€” Reading Room</button>
    </div>

    <div id="controls-panel">
        <div class="control-section">
            <div class="section-title">Overview</div>
            <button class="control-btn" onclick="setView('overview')"><span class="icon">ğŸ </span>Bird's Eye</button>
            <button class="control-btn" onclick="setView('floorPlan')"><span class="icon">ğŸ“</span>Floor Plan View</button>
        </div>
        <div class="control-section">
            <div class="section-title">Room S202 - Special Special</div>
            <button class="control-btn" onclick="setView('roomS202Entry')"><span class="icon">ğŸšª</span>Entry Vestibule</button>
            <button class="control-btn" onclick="setView('roomS202Inside')"><span class="icon">ğŸ”Š</span>Inside View</button>
            <button class="control-btn" onclick="setView('roomS202Windows')"><span class="icon">ğŸªŸ</span>Window Wall</button>
            <button class="control-btn" onclick="setView('roomS202Table')"><span class="icon">ğŸ“š</span>Display Table</button>
        </div>
        <div class="control-section">
            <div class="section-title">Room S203 - Reading Room</div>
            <button class="control-btn" onclick="setView('roomS203Entry')"><span class="icon">ğŸšª</span>Entry (from door)</button>
            <button class="control-btn" onclick="setView('roomS203Inside')"><span class="icon">ğŸ“–</span>Inside View</button>
            <button class="control-btn" onclick="setView('roomS203Windows')"><span class="icon">ğŸªŸ</span>Arched Windows</button>
            <button class="control-btn" onclick="setView('roomS203Seating')"><span class="icon">ğŸ›‹ï¸</span>Seating Area</button>
            <button class="control-btn" onclick="setView('roomS203Shelves')"><span class="icon">ğŸ“š</span>Book Displays</button>
        </div>
        <div class="control-section">
            <button class="control-btn" onclick="startTour()"><span class="icon">ğŸ¬</span>Auto Tour</button>
        </div>
    </div>

    <div id="dimensions-panel">
        <h3>Room Dimensions (from floor plan)</h3>
        <div class="dim-row">
            <span class="dim-label">Room S202 (Special Special)</span>
            <span class="dim-value">11'-5â…" Ã— 25'-3Â¾" | 3.49m Ã— 7.71m</span>
        </div>
        <div class="dim-row">
            <span class="dim-label">Room S202 Area</span>
            <span class="dim-value">289.4 sq ft | 26.9 mÂ²</span>
        </div>
        <div class="dim-row">
            <span class="dim-label">Room S203 (Reading Room)</span>
            <span class="dim-value">14'-7Â¾" Ã— 25'-3Â¾" | 4.46m Ã— 7.71m</span>
        </div>
        <div class="dim-row">
            <span class="dim-label">Room S203 Area</span>
            <span class="dim-value">369.5 sq ft | 34.3 mÂ²</span>
        </div>
        <div class="dim-row">
            <span class="dim-label">Ceiling Height</span>
            <span class="dim-value">12'-0" | 3.66m</span>
        </div>
        <div class="dim-row">
            <span class="dim-label">Door Openings</span>
            <span class="dim-value">3'-5â…›" Ã— 7'-0" | 1.04m Ã— 2.13m</span>
        </div>
        <div class="dim-row">
            <span class="dim-label">Total Combined Area</span>
            <span class="dim-value">658.9 sq ft | 61.2 mÂ²</span>
        </div>
    </div>

    <div id="credits">
        <div style="margin-bottom: 8px; color: #888;">A project by</div>
        <div><a href="http://www.afrikadaa.com/" target="_blank">Pascale Obolo / Afrikadaa</a></div>
        <div><a href="http://coolhuntparis.com" target="_blank">Nalini Cazaux / Coolhunt Paris</a></div>
        <div style="margin-top: 8px; color: #888;">3D Simulation by</div>
        <div><a href="http://luvlab.io" target="_blank">Gordon Cyrus / Luvlab</a></div>
    </div>

    <div id="help-text">â€¢ Drag to rotate â€¢ Scroll to zoom â€¢ WASD to move</div>

    <div id="toggle-btns">
        <button class="toggle-btn active" onclick="toggleGrid()" id="gridBtn">Grid</button>
        <button class="toggle-btn active" onclick="toggleLabels()" id="labelsBtn">Labels</button>
        <button class="toggle-btn active" onclick="toggleCeiling()" id="ceilingBtn">Ceiling</button>
        <button class="toggle-btn" onclick="toggleNearWall()" id="nearWallBtn">Hide Near Wall</button>
        <button class="toggle-btn" onclick="toggleWireframe()" id="wireframeBtn">Wireframe</button>
    </div>

    <button id="capture-btn" onclick="captureScreenshot()">ğŸ“· Capture</button>
    <button id="moodboard-btn" onclick="toggleMoodboard()">ğŸ¨ Mood Board</button>

    <!-- Mood Board Modal -->
    <div id="moodboard-modal" class="modal-hidden">
        <div class="modal-content">
            <button class="modal-close" onclick="toggleMoodboard()">âœ•</button>
            <h2>Reference Images & Mood Board</h2>
            <p>Design inspiration for The Panafrican Library Reading Room â€” Afrikadaa Ã— Coolhunt Paris</p>

            <!-- Toolbar -->
            <div class="moodboard-toolbar">
                <button class="moodboard-toolbar-btn" onclick="toggleMoodboardEdit()" id="edit-mode-btn">âœï¸ Edit Mode</button>
                <button class="moodboard-toolbar-btn primary" onclick="toggleAddImageForm()" id="add-image-btn">â• Add Image</button>
                <button class="moodboard-toolbar-btn" onclick="filterMoodboard('all')" data-filter="all">All</button>
                <button class="moodboard-toolbar-btn" onclick="filterMoodboard('furniture')" data-filter="furniture">Furniture</button>
                <button class="moodboard-toolbar-btn" onclick="filterMoodboard('ambiance')" data-filter="ambiance">Ambiance</button>
                <button class="moodboard-toolbar-btn" onclick="filterMoodboard('inspiration')" data-filter="inspiration">Inspiration</button>
            </div>

            <!-- Add Image Form -->
            <div class="add-image-form" id="add-image-form">
                <div class="drop-zone" id="drop-zone" onclick="document.getElementById('image-file-input').click()">
                    ğŸ“· Drag & drop image here or click to browse
                </div>
                <input type="file" id="image-file-input" accept="image/*" style="display:none" onchange="handleImageSelect(event)">
                <input type="text" id="new-image-url" placeholder="Or paste image URL...">
                <input type="text" id="new-image-title" placeholder="Image title / description">
                <select id="new-image-category">
                    <option value="furniture">Furniture Style</option>
                    <option value="ambiance">Ambiance</option>
                    <option value="inspiration">Inspiration</option>
                    <option value="pattern">Patterns & Textiles</option>
                </select>
                <div style="display: flex; gap: 10px;">
                    <button class="moodboard-toolbar-btn primary" onclick="addMoodboardImage()" style="flex:1">Add Image</button>
                    <button class="moodboard-toolbar-btn" onclick="toggleAddImageForm()" style="flex:1">Cancel</button>
                </div>
            </div>

            <!-- Reference Images Gallery -->
            <div class="moodboard-section" style="grid-column: 1 / -1;">
                <h3>ğŸ“¸ Reference Images <span id="image-count" style="color:#888; font-weight:normal;"></span></h3>
                <div class="moodboard-images" id="moodboard-gallery">
                    <!-- Images will be populated by JavaScript -->
                </div>
            </div>

            <div class="moodboard-grid">
                <div class="moodboard-section">
                    <h3>ğŸ¨ Color Palette</h3>
                    <p style="font-size: 11px; color: #666; margin-bottom: 8px;">Based on Panafrican reference imagery</p>
                    <div class="color-palette">
                        <div class="color-swatch" style="background: #f5f0e8;" title="Cream/Off-White (Bean Bags, Walls)"></div>
                        <div class="color-swatch" style="background: #fd7e14;" title="Burnt Orange (Bean Bags, Accents)"></div>
                        <div class="color-swatch" style="background: #c41e3a;" title="Deep Red (Natte, Posters)"></div>
                        <div class="color-swatch" style="background: #fdd835;" title="Bright Yellow (Wax Print, Highlights)"></div>
                        <div class="color-swatch" style="background: #c2185b;" title="Magenta/Pink (Cushions, Rugs)"></div>
                        <div class="color-swatch" style="background: #6b8e23;" title="Olive Green (Velvet Sofa)"></div>
                        <div class="color-swatch" style="background: #00897b;" title="Teal (Cushions, Accents)"></div>
                        <div class="color-swatch" style="background: #1a3a5c;" title="Deep Blue (Tie-Dye, Books)"></div>
                        <div class="color-swatch" style="background: #d4a76a;" title="Natural Wood/Rattan"></div>
                        <div class="color-swatch" style="background: #8b4513;" title="Terracotta/Brown"></div>
                        <div class="color-swatch" style="background: #c9a227;" title="Ochre/Gold"></div>
                        <div class="color-swatch" style="background: #1a1a1a;" title="Black (Frames, Contrast)"></div>
                    </div>
                </div>
                <div class="moodboard-section">
                    <h3>ğŸŒ African Wax Patterns</h3>
                    <div class="pattern-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;">
                        <div class="pattern-swatch" style="background: repeating-conic-gradient(from 0deg, #fdd835 0deg 30deg, #c41e3a 30deg 60deg); width: 60px; height: 60px; border-radius: 4px;" title="Ankara Circles"></div>
                        <div class="pattern-swatch" style="background: repeating-linear-gradient(45deg, #fd7e14 0px, #fd7e14 10px, #fdd835 10px, #fdd835 20px); width: 60px; height: 60px; border-radius: 4px;" title="Kente Stripes"></div>
                        <div class="pattern-swatch" style="background: radial-gradient(circle at 50% 50%, #c41e3a 30%, #1a1a1a 30%, #1a1a1a 40%, #fdd835 40%); width: 60px; height: 60px; border-radius: 4px;" title="Target Circles"></div>
                        <div class="pattern-swatch" style="background: repeating-linear-gradient(0deg, #00897b 0px, #00897b 8px, #f5f0e8 8px, #f5f0e8 16px); width: 60px; height: 60px; border-radius: 4px;" title="Horizontal Bars"></div>
                        <div class="pattern-swatch" style="background: conic-gradient(#c2185b, #fdd835, #00897b, #c41e3a, #c2185b); width: 60px; height: 60px; border-radius: 4px;" title="Color Wheel"></div>
                        <div class="pattern-swatch" style="background: repeating-conic-gradient(#1a1a1a 0deg 10deg, #f5f0e8 10deg 20deg); width: 60px; height: 60px; border-radius: 4px;" title="B&W Geometric"></div>
                    </div>
                    <p style="font-size: 10px; color: #888; margin-top: 6px;">Ankara â€¢ Kente â€¢ Adinkra â€¢ Mud Cloth</p>
                </div>
                <div class="moodboard-section">
                    <h3>ğŸ›‹ï¸ Key Furniture</h3>
                    <ul class="design-list" style="font-size: 12px;">
                        <li>ğŸ§ DJ/Audio station (west wall)</li>
                        <li>ğŸ”Š Floor speakers in corners</li>
                        <li>ğŸ§˜ Floor poufs for listening</li>
                        <li>ğŸµ Headphone stations</li>
                        <li>ğŸ“– Reading tables with chairs</li>
                        <li>ğŸ“š Wall-mounted archive shelves</li>
                        <li>ğŸ“º Video screen stands</li>
                    </ul>
                </div>
                <div class="moodboard-section">
                    <h3>ğŸ“ Room Functions</h3>
                    <div class="layout-info" style="font-size: 12px;">
                        <p><strong>S202 - Sound Library:</strong> Radio Room for collective listening, DJ sets, performances</p>
                        <p><strong>S203 - Reading Room:</strong> Panafrican Library with ~50 publications, archives, video viewing</p>
                        <p><strong>Duration:</strong> 3-day art fair exhibition</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Slideshow Modal -->
    <div id="slideshow-modal">
        <button class="slideshow-close" onclick="closeSlideshow()">âœ•</button>
        <div class="slideshow-image-container">
            <img id="slideshow-image" src="" alt="Reference image">
        </div>
        <div class="slideshow-caption" id="slideshow-caption"></div>
        <div class="slideshow-controls">
            <button class="slideshow-btn nav" onclick="slideshowNav(-1)">â†</button>
            <span class="slideshow-info" id="slideshow-info">1 / 6</span>
            <button class="slideshow-btn nav" onclick="slideshowNav(1)">â†’</button>
        </div>
    </div>

    <button id="decorator-btn" onclick="toggleDecorator()">ğŸ›‹ï¸ Decorator</button>
    <button id="render-btn" onclick="openRenderModal()">âœ¨ AI Render</button>
    <button id="admin-btn" onclick="toggleAdminLogin()">ğŸ” Admin</button>

    <!-- Login Modal -->
    <div id="login-modal">
        <div class="login-box">
            <h2>ğŸ” Admin Login</h2>
            <p>Enter your authorized email to access admin features</p>
            <input type="email" id="login-email" class="login-input" placeholder="your@email.com" onkeypress="if(event.key==='Enter')attemptLogin()">
            <button class="login-submit" onclick="attemptLogin()">Login</button>
            <button class="login-submit login-cancel" onclick="closeLoginModal()">Cancel</button>
            <div id="login-error" class="login-error"></div>
        </div>
    </div>

    <!-- Admin Panel -->
    <div id="admin-panel">
        <div class="admin-header">
            <div>
                <h2>ğŸ› ï¸ Admin Panel</h2>
                <div class="admin-user" id="admin-user-name">Logged in as: Admin</div>
            </div>
            <button class="admin-close" onclick="toggleAdminPanel()">âœ•</button>
        </div>

        <div class="admin-tabs">
            <button class="admin-tab active" onclick="switchAdminTab('layouts')">Layouts</button>
            <button class="admin-tab" onclick="switchAdminTab('views')">Views</button>
            <button class="admin-tab" onclick="switchAdminTab('moodboard')">Mood Board</button>
            <button class="admin-tab" onclick="switchAdminTab('renders')">AI Renders</button>
        </div>

        <div class="admin-content" id="admin-tab-layouts">
            <div class="admin-section">
                <h3>Save Current Layout</h3>
                <div class="admin-input-group">
                    <label>Configuration Name</label>
                    <input type="text" class="admin-input" id="layout-name" placeholder="e.g., Opening Night Setup">
                </div>
                <div class="admin-input-group">
                    <label>Description (optional)</label>
                    <input type="text" class="admin-input" id="layout-description" placeholder="e.g., With all furniture in place">
                </div>
                <button class="admin-btn admin-btn-primary" onclick="saveAdminLayout()">ğŸ’¾ Save Layout</button>
                <button class="admin-btn admin-btn-secondary" onclick="exportLayoutFile()">ğŸ“¤ Export JSON</button>
                <button class="admin-btn admin-btn-secondary" onclick="importLayoutFile()">ğŸ“¥ Import JSON</button>
                <input type="file" id="import-layout-input" accept=".json" style="display:none" onchange="handleLayoutImport(event)">
            </div>

            <div class="admin-section">
                <h3>Saved Layouts <span id="layouts-count" style="color:#888; font-weight:normal;"></span></h3>
                <p style="font-size: 10px; color: #666; margin-bottom: 10px;">Drag to reorder â€¢ Click to load</p>
                <div class="saved-config-list" id="saved-layouts-list">
                    <div style="color: #666; font-size: 12px; padding: 10px;">No layouts saved yet</div>
                </div>
            </div>
        </div>

        <div class="admin-content" id="admin-tab-views" style="display:none;">
            <div class="admin-section">
                <h3>Save Current View</h3>
                <div class="admin-input-group">
                    <label>View Name</label>
                    <input type="text" class="admin-input" id="view-name" placeholder="e.g., Window Corner">
                </div>
                <div class="admin-input-group">
                    <label>Description (optional)</label>
                    <input type="text" class="admin-input" id="view-description" placeholder="Brief description">
                </div>
                <button class="admin-btn admin-btn-primary" onclick="saveAdminView()">ğŸ“ Save Current View</button>
            </div>

            <div class="admin-section">
                <h3>Saved Views <span id="views-count" style="color:#888; font-weight:normal;"></span></h3>
                <p style="font-size: 10px; color: #666; margin-bottom: 10px;">Drag to reorder â€¢ Click to apply</p>
                <div class="saved-config-list" id="saved-views-list">
                    <div style="color: #666; font-size: 12px; padding: 10px;">No views saved yet</div>
                </div>
            </div>

            <div class="admin-section">
                <h3>Current Camera Position</h3>
                <div id="camera-position-display" style="font-family: monospace; font-size: 11px; color: #888; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 4px;">
                    Position: (0, 0, 0)<br>
                    Target: (0, 0, 0)
                </div>
                <button class="admin-btn admin-btn-secondary" style="margin-top:10px; width:100%;" onclick="updateCameraDisplay()">ğŸ”„ Refresh Position</button>
            </div>
        </div>

        <div class="admin-content" id="admin-tab-moodboard" style="display:none;">
            <div class="admin-section">
                <h3>Add Mood Board Entry</h3>
                <div class="admin-input-group">
                    <label>Title</label>
                    <input type="text" class="admin-input" id="mood-title" placeholder="e.g., Color Inspiration">
                </div>
                <div class="admin-input-group">
                    <label>Image URL</label>
                    <input type="text" class="admin-input" id="mood-image-url" placeholder="https://...">
                </div>
                <div class="admin-input-group">
                    <label>Description</label>
                    <textarea class="admin-input admin-textarea" id="mood-description" placeholder="Describe this reference..."></textarea>
                </div>
                <div class="admin-input-group">
                    <label>Category</label>
                    <select class="admin-input" id="mood-category">
                        <option value="inspiration">Inspiration</option>
                        <option value="colors">Colors</option>
                        <option value="furniture">Furniture</option>
                        <option value="art">Artwork</option>
                        <option value="layout">Layout</option>
                    </select>
                </div>
                <button class="admin-btn admin-btn-primary" onclick="saveMoodEntry()">â• Add to Mood Board</button>
            </div>

            <div class="admin-section">
                <h3>Saved Mood Board Entries</h3>
                <div class="saved-config-list" id="saved-mood-list">
                    <div style="color: #666; font-size: 12px; padding: 10px;">Loading...</div>
                </div>
            </div>
        </div>

        <div class="admin-content" id="admin-tab-renders" style="display:none;">
            <div class="admin-section">
                <h3>AI Render History</h3>
                <p style="font-size: 11px; color: #888; margin-bottom: 15px;">Generated photorealistic renders of your room designs</p>
                <div class="saved-config-list" id="saved-renders-list">
                    <div style="color: #666; font-size: 12px; padding: 10px;">No renders yet. Click "AI Render" to generate one.</div>
                </div>
            </div>

            <div class="admin-section">
                <h3>Render Settings</h3>
                <div class="admin-input-group">
                    <label>Default Style</label>
                    <select class="admin-input" id="default-render-style">
                        <option value="photorealistic">Photorealistic</option>
                        <option value="warm-cozy">Warm & Cozy</option>
                        <option value="editorial">Editorial Magazine</option>
                        <option value="sketch">Architectural Sketch</option>
                    </select>
                </div>
            </div>
        </div>

        <div style="padding: 20px; border-top: 1px solid rgba(255,255,255,0.1);">
            <button class="admin-btn admin-btn-secondary" onclick="logoutAdmin()" style="width: 100%;">ğŸšª Logout</button>
        </div>
    </div>

    <!-- Render Modal -->
    <div id="render-modal">
        <div class="render-box">
            <h2>âœ¨ AI Photorealistic Render</h2>
            <p>Transform your 3D scene into a stunning photorealistic image using Nano Banana AI</p>

            <div class="render-preview">
                <div class="render-preview-box">
                    <h4>Current 3D View</h4>
                    <div class="render-preview-img" id="render-input-preview">
                        Capture will appear here
                    </div>
                </div>
                <div class="render-preview-box">
                    <h4>AI Generated Render</h4>
                    <div class="render-preview-img" id="render-output-preview">
                        Generated image will appear here
                    </div>
                </div>
            </div>

            <div class="render-options">
                <div>
                    <label style="font-size: 11px; color: #888; display: block; margin-bottom: 8px;">Render Style</label>
                    <div class="render-style-grid">
                        <button class="render-style-btn active" onclick="selectRenderStyle('photorealistic', this)">ğŸ“¸ Photo</button>
                        <button class="render-style-btn" onclick="selectRenderStyle('warm-cozy', this)">ğŸŒ… Warm</button>
                        <button class="render-style-btn" onclick="selectRenderStyle('editorial', this)">ğŸ“° Editorial</button>
                        <button class="render-style-btn" onclick="selectRenderStyle('sketch', this)">âœï¸ Sketch</button>
                    </div>
                </div>
                <div>
                    <label style="font-size: 11px; color: #888; display: block; margin-bottom: 8px;">Custom Prompt (optional)</label>
                    <input type="text" class="admin-input" id="render-custom-prompt" placeholder="Add specific instructions...">
                </div>
            </div>

            <div id="render-status" class="render-status" style="display: none;">
                <span class="render-spinner"></span>
                <span id="render-status-text">Generating render...</span>
            </div>

            <div class="render-actions">
                <button class="render-btn-generate" id="generate-render-btn" onclick="generateRender()">
                    ğŸ¨ Generate Photorealistic Render
                </button>
                <button class="render-btn-close" onclick="closeRenderModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Decorator Panel -->
    <div id="decorator-panel">
        <div class="decorator-header">
            <h2>ğŸ›‹ï¸ Room Decorator</h2>
            <button class="decorator-close" onclick="toggleDecorator()">âœ•</button>
        </div>

        <div id="selected-item-info">
            <h4>Selected: <span id="selected-name">None</span></h4>
            <div class="item-controls">
                <button class="item-control-btn" onclick="moveItem(-0.2, 0)">â† X</button>
                <button class="item-control-btn" onclick="moveItem(0.2, 0)">X â†’</button>
                <button class="item-control-btn" onclick="moveItem(0, -0.2)">â†‘ Z</button>
                <button class="item-control-btn" onclick="moveItem(0, 0.2)">Z â†“</button>
                <button class="item-control-btn" onclick="rotateItem(15)">â†» 15Â°</button>
                <button class="item-control-btn" onclick="rotateItem(-15)">â†º 15Â°</button>
                <button class="item-control-btn danger" onclick="deleteItem()">ğŸ—‘ï¸</button>
            </div>
            <div style="font-size:9px; color:#888; margin-top:8px;">
                Keys: G=move, R=rotate, Del=delete, Esc=deselect
            </div>
        </div>

        <div class="decorator-category" id="cat-seating">
            <h3 onclick="toggleCategory('cat-seating')">Seating - Bean Bags & Cushions</h3>
            <div class="item-grid">
                <div class="item-card" onclick="selectFurniture('beanbag-cream')">
                    <div class="item-preview">ğŸ¤</div>
                    <div class="item-name">Cream Bean Bag</div>
                </div>
                <div class="item-card" onclick="selectFurniture('beanbag-orange')">
                    <div class="item-preview">ğŸ§¡</div>
                    <div class="item-name">Orange Bean Bag</div>
                </div>
                <div class="item-card" onclick="selectFurniture('beanbag-magenta')">
                    <div class="item-preview">ğŸ’—</div>
                    <div class="item-name">Magenta Bean Bag</div>
                </div>
                <div class="item-card" onclick="selectFurniture('beanbag-teal')">
                    <div class="item-preview">ğŸ’š</div>
                    <div class="item-name">Teal Bean Bag</div>
                </div>
                <div class="item-card" onclick="selectFurniture('cushion-ethnic-orange')">
                    <div class="item-preview">ğŸŸ </div>
                    <div class="item-name">Ethnic Orange</div>
                </div>
                <div class="item-card" onclick="selectFurniture('cushion-ethnic-burgundy')">
                    <div class="item-preview">ğŸŸ¤</div>
                    <div class="item-name">Ethnic Burgundy</div>
                </div>
                <div class="item-card" onclick="selectFurniture('cushion-velvet-teal')">
                    <div class="item-preview">ğŸ©µ</div>
                    <div class="item-name">Velvet Teal</div>
                </div>
                <div class="item-card" onclick="selectFurniture('cushion-round-green')">
                    <div class="item-preview">ğŸŸ¢</div>
                    <div class="item-name">Round Green</div>
                </div>
                <div class="item-card" onclick="selectFurniture('cushion-pebble-gray')">
                    <div class="item-preview">âšª</div>
                    <div class="item-name">Pebble Gray</div>
                </div>
                <div class="item-card" onclick="selectFurniture('mattress-ochre')">
                    <div class="item-preview">ğŸŸ¨</div>
                    <div class="item-name">Tufted Mattress</div>
                </div>
                <div class="item-card" onclick="selectFurniture('sofa-olive')">
                    <div class="item-preview">ğŸ›‹ï¸</div>
                    <div class="item-name">Olive Velvet Sofa</div>
                </div>
                <div class="item-card" onclick="selectFurniture('armchair-pink')">
                    <div class="item-preview">ğŸª‘</div>
                    <div class="item-name">Pink Armchair</div>
                </div>
            </div>
        </div>

        <div class="decorator-category" id="cat-tables">
            <h3 onclick="toggleCategory('cat-tables')">Tables</h3>
            <div class="item-grid">
                <div class="item-card" onclick="selectFurniture('table-display')">
                    <div class="item-preview">ğŸªµ</div>
                    <div class="item-name">Display Table</div>
                </div>
                <div class="item-card" onclick="selectFurniture('table-coffee')">
                    <div class="item-preview">â˜•</div>
                    <div class="item-name">Coffee Table</div>
                </div>
                <div class="item-card" onclick="selectFurniture('table-side')">
                    <div class="item-preview">ğŸŸ¡</div>
                    <div class="item-name">Side Table</div>
                </div>
                <div class="item-card" onclick="selectFurniture('bench-wood')">
                    <div class="item-preview">ğŸª‘</div>
                    <div class="item-name">Wood Bench</div>
                </div>
            </div>
        </div>

        <div class="decorator-category" id="cat-storage">
            <h3 onclick="toggleCategory('cat-storage')">Book Displays & Storage</h3>
            <div class="item-grid">
                <div class="item-card" onclick="selectFurniture('bookcase-wall')">
                    <div class="item-preview">ğŸ“š</div>
                    <div class="item-name">Wall Bookcase</div>
                </div>
                <div class="item-card" onclick="selectFurniture('book-cubby')">
                    <div class="item-preview">ğŸ“¦</div>
                    <div class="item-name">Book Cubby</div>
                </div>
                <div class="item-card" onclick="selectFurniture('magazine-rack')">
                    <div class="item-preview">ğŸ“°</div>
                    <div class="item-name">Magazine Rack</div>
                </div>
                <div class="item-card" onclick="selectFurniture('book-stack')">
                    <div class="item-preview">ğŸ“š</div>
                    <div class="item-name">Book Stack</div>
                </div>
                <div class="item-card" onclick="selectFurniture('display-pink')">
                    <div class="item-preview">ğŸ“•</div>
                    <div class="item-name">Pink Display</div>
                </div>
                <div class="item-card" onclick="selectFurniture('shelf-leaning')">
                    <div class="item-preview">ğŸ“–</div>
                    <div class="item-name">Leaning Shelf</div>
                </div>
            </div>
        </div>

        <div class="decorator-category" id="cat-rugs">
            <h3 onclick="toggleCategory('cat-rugs')">Rugs & Textiles - Layered</h3>
            <div class="item-grid">
                <div class="item-card" onclick="selectFurniture('rug-persian-red')">
                    <div class="item-preview">ğŸŸ¥</div>
                    <div class="item-name">Persian Red</div>
                </div>
                <div class="item-card" onclick="selectFurniture('rug-persian-cream')">
                    <div class="item-preview">â¬œ</div>
                    <div class="item-name">Persian Cream</div>
                </div>
                <div class="item-card" onclick="selectFurniture('rug-natte-african')">
                    <div class="item-preview">ğŸ‡¸ğŸ‡³</div>
                    <div class="item-name">Natte Plastique</div>
                </div>
                <div class="item-card" onclick="selectFurniture('rug-checkered-pink')">
                    <div class="item-preview">ğŸ©·</div>
                    <div class="item-name">Checkered Pink</div>
                </div>
                <div class="item-card" onclick="selectFurniture('rug-checkered-teal')">
                    <div class="item-preview">ğŸ©µ</div>
                    <div class="item-name">Checkered Teal</div>
                </div>
                <div class="item-card" onclick="selectFurniture('rug-wax-yellow')">
                    <div class="item-preview">ğŸŸ¡</div>
                    <div class="item-name">Wax Print Yellow</div>
                </div>
                <div class="item-card" onclick="selectFurniture('rug-geometric-bw')">
                    <div class="item-preview">â¬›</div>
                    <div class="item-name">Geometric B&W</div>
                </div>
                <div class="item-card" onclick="selectFurniture('tablecloth-tiedye')">
                    <div class="item-preview">ğŸ¨</div>
                    <div class="item-name">Tie-Dye Cloth</div>
                </div>
            </div>
        </div>

        <div class="decorator-category" id="cat-lighting">
            <h3 onclick="toggleCategory('cat-lighting')">Lighting & Hanging</h3>
            <div class="item-grid">
                <div class="item-card" onclick="selectFurniture('lamp-ethiopian')">
                    <div class="item-preview">ğŸº</div>
                    <div class="item-name">Ethiopian Lamp</div>
                </div>
                <div class="item-card" onclick="selectFurniture('lamp-beaded')">
                    <div class="item-preview">âœ¨</div>
                    <div class="item-name">Beaded Lamp</div>
                </div>
                <div class="item-card" onclick="selectFurniture('disco-ball')">
                    <div class="item-preview">ğŸª©</div>
                    <div class="item-name">Disco Ball</div>
                </div>
                <div class="item-card" onclick="selectFurniture('disco-ball-cluster')">
                    <div class="item-preview">ğŸª©ğŸª©</div>
                    <div class="item-name">Disco Cluster</div>
                </div>
                <div class="item-card" onclick="selectFurniture('light-string')">
                    <div class="item-preview">ğŸ’¡</div>
                    <div class="item-name">String Lights</div>
                </div>
                <div class="item-card" onclick="selectFurniture('lantern-paper')">
                    <div class="item-preview">ğŸ®</div>
                    <div class="item-name">Paper Lantern</div>
                </div>
            </div>
        </div>

        <div class="decorator-category" id="cat-plants">
            <h3 onclick="toggleCategory('cat-plants')">Plants & African Decor</h3>
            <div class="item-grid">
                <div class="item-card" onclick="selectFurniture('plant-palm')">
                    <div class="item-preview">ğŸŒ´</div>
                    <div class="item-name">Palm Plant</div>
                </div>
                <div class="item-card" onclick="selectFurniture('plant-hanging')">
                    <div class="item-preview">ğŸŒ¿</div>
                    <div class="item-name">Hanging Plant</div>
                </div>
                <div class="item-card" onclick="selectFurniture('plant-pothos')">
                    <div class="item-preview">ğŸƒ</div>
                    <div class="item-name">Pothos Vine</div>
                </div>
                <div class="item-card" onclick="selectFurniture('basket-woven')">
                    <div class="item-preview">ğŸ§º</div>
                    <div class="item-name">Woven Basket</div>
                </div>
                <div class="item-card" onclick="selectFurniture('pottery-african')">
                    <div class="item-preview">ğŸº</div>
                    <div class="item-name">African Pottery</div>
                </div>
                <div class="item-card" onclick="selectFurniture('sculpture-wood')">
                    <div class="item-preview">ğŸ—¿</div>
                    <div class="item-name">Wood Sculpture</div>
                </div>
            </div>
        </div>

        <div class="decorator-category" id="cat-wallart">
            <h3 onclick="toggleCategory('cat-wallart')">Wall Art - Afrikadaa</h3>
            <div class="item-grid">
                <div class="item-card art-item-card" onclick="selectFurniture('poster-afrikadaa-1')">
                    <div class="item-preview">ğŸ–¼ï¸</div>
                    <div class="item-name">Afrikadaa Cover #1</div>
                </div>
                <div class="item-card art-item-card" onclick="selectFurniture('poster-afrikadaa-2')">
                    <div class="item-preview">ğŸ–¼ï¸</div>
                    <div class="item-name">Afrikadaa Cover #2</div>
                </div>
                <div class="item-card art-item-card" onclick="selectFurniture('poster-afrikadaa-3')">
                    <div class="item-preview">ğŸ–¼ï¸</div>
                    <div class="item-name">African Contemporary</div>
                </div>
            </div>
        </div>

        <div class="decorator-category" id="cat-wallart2">
            <h3 onclick="toggleCategory('cat-wallart2')">Wall Art - Coolhunt Paris</h3>
            <div class="item-grid">
                <div class="item-card art-item-card" onclick="selectFurniture('poster-coolhunt-1')">
                    <div class="item-preview">ğŸ“·</div>
                    <div class="item-name">Fashion Photo</div>
                </div>
                <div class="item-card art-item-card" onclick="selectFurniture('poster-coolhunt-2')">
                    <div class="item-preview">ğŸ¨</div>
                    <div class="item-name">Street Art Print</div>
                </div>
                <div class="item-card art-item-card" onclick="selectFurniture('poster-coolhunt-3')">
                    <div class="item-preview">ğŸ–Œï¸</div>
                    <div class="item-name">Design Print</div>
                </div>
            </div>
        </div>

        <div class="decorator-category" id="cat-activist">
            <h3 onclick="toggleCategory('cat-activist')">Wall Art - Activist</h3>
            <div class="item-grid">
                <div class="item-card art-item-card" onclick="selectFurniture('poster-activist-1')">
                    <div class="item-preview">WE WANT TO LIVE FREE</div>
                    <div class="item-name">Live Free Banner</div>
                </div>
                <div class="item-card art-item-card" onclick="selectFurniture('poster-activist-2')">
                    <div class="item-preview">SOMOS PERSONAS</div>
                    <div class="item-name">Somos Personas</div>
                </div>
                <div class="item-card art-item-card" onclick="selectFurniture('poster-activist-3')">
                    <div class="item-preview">âœŠ</div>
                    <div class="item-name">Resistance Art</div>
                </div>
            </div>
        </div>

        <div class="decorator-category" id="cat-custom3d">
            <h3 onclick="toggleCategory('cat-custom3d')">ğŸ“¦ Custom 3D Models</h3>
            <div class="upload-section">
                <div class="file-drop-zone" id="model-drop-zone" onclick="document.getElementById('model-file-input').click()">
                    <div class="drop-icon">ğŸ“¦</div>
                    <div class="drop-text">Drop 3D model file here or click to browse</div>
                    <div class="drop-formats">Supports: GLB, GLTF, OBJ</div>
                </div>
                <input type="file" id="model-file-input" accept=".glb,.gltf,.obj" style="display:none" onchange="handleModelUpload(event)">
                <input type="text" id="model-name-input" class="edit-inline-input" placeholder="Model name (optional)" style="margin-bottom: 8px;">
                <div class="uploaded-models-list" id="uploaded-models-list">
                    <!-- Uploaded models appear here -->
                </div>
            </div>
            <div class="item-grid" id="custom-models-grid">
                <!-- Custom model cards appear here -->
            </div>
        </div>

        <div class="decorator-actions">
            <button class="decorator-action-btn danger" onclick="resetLayout()">ğŸ”„ Clear All</button>
        </div>

        <div class="decorator-help">
            <strong>How to use:</strong><br>
            â€¢ Drag items from library â†’ drop in 3D view<br>
            â€¢ Or click item, then click in room to place<br>
            â€¢ Drag 3D files (GLB/OBJ) from Finder â†’ drop on canvas<br>
            â€¢ Click placed items to select, then drag to move<br>
            â€¢ Use controls above for rotate/delete
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
    <script>
        // ============ INDEXEDDB FOR 3D MODEL STORAGE ============
        const DB_NAME = 'PanafricanLibrary3D';
        const DB_VERSION = 1;
        const MODELS_STORE = 'custom_models';
        const IMAGES_STORE = 'moodboard_images';

        let db = null;

        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    resolve(db);
                };

                request.onupgradeneeded = (event) => {
                    const database = event.target.result;

                    // Store for 3D models
                    if (!database.objectStoreNames.contains(MODELS_STORE)) {
                        const modelsStore = database.createObjectStore(MODELS_STORE, { keyPath: 'id', autoIncrement: true });
                        modelsStore.createIndex('name', 'name', { unique: false });
                        modelsStore.createIndex('type', 'type', { unique: false });
                    }

                    // Store for mood board images
                    if (!database.objectStoreNames.contains(IMAGES_STORE)) {
                        const imagesStore = database.createObjectStore(IMAGES_STORE, { keyPath: 'id', autoIncrement: true });
                        imagesStore.createIndex('category', 'category', { unique: false });
                    }
                };
            });
        }

        // Save 3D model to IndexedDB
        async function saveModelToDB(modelData) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([MODELS_STORE], 'readwrite');
                const store = transaction.objectStore(MODELS_STORE);
                const request = store.add(modelData);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        // Get all models from IndexedDB
        async function getAllModelsFromDB() {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([MODELS_STORE], 'readonly');
                const store = transaction.objectStore(MODELS_STORE);
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        // Delete model from IndexedDB
        async function deleteModelFromDB(id) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([MODELS_STORE], 'readwrite');
                const store = transaction.objectStore(MODELS_STORE);
                const request = store.delete(id);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        // Save image to IndexedDB
        async function saveImageToDB(imageData) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([IMAGES_STORE], 'readwrite');
                const store = transaction.objectStore(IMAGES_STORE);
                const request = store.add(imageData);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        // Get all images from IndexedDB
        async function getAllImagesFromDB() {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([IMAGES_STORE], 'readonly');
                const store = transaction.objectStore(IMAGES_STORE);
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        // Delete image from IndexedDB
        async function deleteImageFromDB(id) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([IMAGES_STORE], 'readwrite');
                const store = transaction.objectStore(IMAGES_STORE);
                const request = store.delete(id);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        // Initialize DB on load
        initDB().then(() => {
            console.log('IndexedDB initialized for 3D models and images');
            loadUploadedModels();
            loadUploadedImages();
        }).catch(err => {
            console.error('Failed to initialize IndexedDB:', err);
        });

        // ============ 3D MODEL UPLOAD HANDLING ============
        let uploadedModels = [];
        let gltfLoader = null;
        let objLoader = null;

        // Initialize loaders after Three.js is ready
        function initLoaders() {
            if (typeof THREE.GLTFLoader !== 'undefined') {
                gltfLoader = new THREE.GLTFLoader();
            }
            if (typeof THREE.OBJLoader !== 'undefined') {
                objLoader = new THREE.OBJLoader();
            }
        }

        // Handle 3D model file upload
        window.handleModelUpload = async function(event) {
            const file = event.target.files[0];
            if (!file) return;

            const dropZone = document.getElementById('model-drop-zone');
            const nameInput = document.getElementById('model-name-input');
            const customName = nameInput.value.trim() || file.name.replace(/\.[^/.]+$/, '');

            // Check file type
            const ext = file.name.split('.').pop().toLowerCase();
            if (!['glb', 'gltf', 'obj'].includes(ext)) {
                alert('Unsupported file format. Please use GLB, GLTF, or OBJ.');
                return;
            }

            dropZone.classList.add('has-file');
            dropZone.querySelector('.drop-text').textContent = 'Processing...';

            try {
                // Read file as ArrayBuffer
                const arrayBuffer = await file.arrayBuffer();

                const modelData = {
                    name: customName,
                    fileName: file.name,
                    type: ext,
                    size: file.size,
                    data: arrayBuffer,
                    createdAt: new Date().toISOString()
                };

                // Save to IndexedDB
                const id = await saveModelToDB(modelData);
                modelData.id = id;
                uploadedModels.push(modelData);

                // Update UI
                nameInput.value = '';
                dropZone.classList.remove('has-file');
                dropZone.querySelector('.drop-text').textContent = 'Drop 3D model file here or click to browse';

                renderUploadedModelsList();
                alert(`Model "${customName}" uploaded successfully!`);

            } catch (err) {
                console.error('Error uploading model:', err);
                alert('Failed to upload model: ' + err.message);
                dropZone.classList.remove('has-file');
                dropZone.querySelector('.drop-text').textContent = 'Drop 3D model file here or click to browse';
            }

            // Reset file input
            event.target.value = '';
        };

        // Load models from IndexedDB on startup
        async function loadUploadedModels() {
            if (!db) return;
            try {
                uploadedModels = await getAllModelsFromDB();
                renderUploadedModelsList();
            } catch (err) {
                console.error('Error loading models:', err);
            }
        }

        // Render the uploaded models list
        function renderUploadedModelsList() {
            const container = document.getElementById('uploaded-models-list');
            const grid = document.getElementById('custom-models-grid');

            if (!container) return;

            if (uploadedModels.length === 0) {
                container.innerHTML = '<div style="color:#666; font-size:11px; text-align:center; padding:10px;">No custom models yet</div>';
                if (grid) grid.innerHTML = '';
                return;
            }

            // List view
            container.innerHTML = uploadedModels.map(model => `
                <div class="uploaded-model-item" onclick="selectCustomModel(${model.id})">
                    <div class="uploaded-model-info">
                        <div class="uploaded-model-name">ğŸ“¦ ${model.name}</div>
                        <div class="uploaded-model-meta">${model.type.toUpperCase()} â€¢ ${formatFileSize(model.size)}</div>
                    </div>
                    <div class="uploaded-model-actions">
                        <button class="model-action-btn place" onclick="event.stopPropagation(); placeCustomModel(${model.id})" title="Place in scene">+</button>
                        <button class="model-action-btn delete" onclick="event.stopPropagation(); deleteCustomModel(${model.id})" title="Delete">âœ•</button>
                    </div>
                </div>
            `).join('');

            // Grid view (item cards)
            if (grid) {
                grid.innerHTML = uploadedModels.map(model => `
                    <div class="item-card" onclick="selectCustomModel(${model.id})">
                        <div class="item-preview">ğŸ“¦</div>
                        <div class="item-name">${model.name}</div>
                    </div>
                `).join('');
            }
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        // Select a custom model for placement
        window.selectCustomModel = function(id) {
            const model = uploadedModels.find(m => m.id === id);
            if (model) {
                selectedFurnitureType = `custom-model-${id}`;
                document.querySelectorAll('.item-card').forEach(c => c.classList.remove('selected'));
                document.querySelectorAll('.uploaded-model-item').forEach(c => c.classList.remove('selected'));
                event.target.closest('.item-card, .uploaded-model-item')?.classList.add('selected');
                updateSelectedInfo();
            }
        };

        // Place custom model in scene
        window.placeCustomModel = async function(id) {
            const model = uploadedModels.find(m => m.id === id);
            if (!model) return;

            initLoaders();

            try {
                const blob = new Blob([model.data]);
                const url = URL.createObjectURL(blob);

                let object = null;

                if (model.type === 'glb' || model.type === 'gltf') {
                    if (!gltfLoader) {
                        alert('GLTF Loader not available');
                        return;
                    }
                    object = await new Promise((resolve, reject) => {
                        gltfLoader.load(url, (gltf) => {
                            resolve(gltf.scene);
                        }, undefined, reject);
                    });
                } else if (model.type === 'obj') {
                    if (!objLoader) {
                        alert('OBJ Loader not available');
                        return;
                    }
                    object = await new Promise((resolve, reject) => {
                        objLoader.load(url, resolve, undefined, reject);
                    });
                }

                URL.revokeObjectURL(url);

                if (object) {
                    // Auto-scale to reasonable size
                    const box = new THREE.Box3().setFromObject(object);
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    if (maxDim > 2) {
                        const scale = 1.5 / maxDim;
                        object.scale.multiplyScalar(scale);
                    }

                    // Center on floor
                    const newBox = new THREE.Box3().setFromObject(object);
                    object.position.y = -newBox.min.y;

                    // Place at room center
                    object.position.x = 0;
                    object.position.z = 0;

                    // Mark as placed item
                    object.userData.isPlacedItem = true;
                    object.userData.itemType = `custom-model-${id}`;
                    object.userData.customModelId = id;
                    object.userData.customModelName = model.name;

                    scene.add(object);
                    placedItems.push(object);

                    alert(`Model "${model.name}" placed in scene!`);
                }

            } catch (err) {
                console.error('Error loading model:', err);
                alert('Failed to load model: ' + err.message);
            }
        };

        // Delete custom model
        window.deleteCustomModel = async function(id) {
            const model = uploadedModels.find(m => m.id === id);
            if (!model) return;

            if (!confirm(`Delete model "${model.name}"? This cannot be undone.`)) return;

            try {
                await deleteModelFromDB(id);
                uploadedModels = uploadedModels.filter(m => m.id !== id);
                renderUploadedModelsList();
            } catch (err) {
                console.error('Error deleting model:', err);
                alert('Failed to delete model: ' + err.message);
            }
        };

        // Setup drag-drop for model upload
        document.addEventListener('DOMContentLoaded', () => {
            const dropZone = document.getElementById('model-drop-zone');
            if (dropZone) {
                dropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    dropZone.classList.add('dragover');
                });
                dropZone.addEventListener('dragleave', () => {
                    dropZone.classList.remove('dragover');
                });
                dropZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    dropZone.classList.remove('dragover');
                    const file = e.dataTransfer.files[0];
                    if (file) {
                        // Trigger the file input handler
                        const input = document.getElementById('model-file-input');
                        const dt = new DataTransfer();
                        dt.items.add(file);
                        input.files = dt.files;
                        handleModelUpload({ target: input });
                    }
                });
            }
        });

        // ============ MOOD BOARD IMAGE UPLOAD TO INDEXEDDB ============
        let uploadedImages = [];

        async function loadUploadedImages() {
            if (!db) return;
            try {
                uploadedImages = await getAllImagesFromDB();
                // Merge with localStorage moodboard images
                mergeUploadedImagesWithMoodboard();
            } catch (err) {
                console.error('Error loading images:', err);
            }
        }

        function mergeUploadedImagesWithMoodboard() {
            // Add uploaded images to moodboard if they exist
            uploadedImages.forEach(img => {
                const exists = moodboardImages.find(m => m.dbId === img.id);
                if (!exists && img.dataUrl) {
                    moodboardImages.push({
                        src: img.dataUrl,
                        title: img.name,
                        category: img.category || 'inspiration',
                        dbId: img.id,
                        isUploaded: true
                    });
                }
            });
        }

        // Enhanced image upload with IndexedDB storage
        window.handleMoodboardImageUpload = async function(file) {
            if (!file || !file.type.startsWith('image/')) return null;

            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    const dataUrl = e.target.result;

                    // Save to IndexedDB for persistence
                    const imageData = {
                        name: file.name.replace(/\.[^/.]+$/, ''),
                        fileName: file.name,
                        dataUrl: dataUrl,
                        size: file.size,
                        category: document.getElementById('new-image-category')?.value || 'inspiration',
                        createdAt: new Date().toISOString()
                    };

                    try {
                        const id = await saveImageToDB(imageData);
                        imageData.id = id;
                        uploadedImages.push(imageData);
                        resolve(dataUrl);
                    } catch (err) {
                        console.error('Error saving image:', err);
                        // Still return dataUrl even if DB save fails
                        resolve(dataUrl);
                    }
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        };

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);

        const container = document.getElementById('canvas-container');
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);

        const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // Camera orbit blocking flag - declared early for TransformControls use
        let isCameraOrbitBlocked = false;

        // TransformControls for visual move/rotate gizmos
        let transformControls = null;
        function initTransformControls() {
            if (typeof THREE.TransformControls !== 'undefined') {
                transformControls = new THREE.TransformControls(camera, renderer.domElement);
                transformControls.setSize(0.75);
                scene.add(transformControls);

                // STRICT: Snap to floor and enforce room boundaries
                let lastValidPosition = null;
                transformControls.addEventListener('objectChange', () => {
                    if (selectedPlacedItem) {
                        // Snap to floor (unless wall art)
                        if (!selectedPlacedItem.userData.isWallArt) {
                            selectedPlacedItem.position.y = 0;
                        }

                        // STRICT: Check if new position is valid
                        const constrained = constrainToRoom(selectedPlacedItem.position);
                        if (constrained) {
                            // Valid position - update and save
                            selectedPlacedItem.position.x = constrained.x;
                            selectedPlacedItem.position.z = constrained.z;
                            lastValidPosition = selectedPlacedItem.position.clone();
                        } else if (lastValidPosition) {
                            // INVALID - snap back to last valid position
                            selectedPlacedItem.position.copy(lastValidPosition);
                        }
                    }
                });

                // Save valid position when starting drag
                transformControls.addEventListener('mouseDown', () => {
                    if (selectedPlacedItem) {
                        lastValidPosition = selectedPlacedItem.position.clone();
                    }
                });

                // Disable camera orbit while transforming with gizmo
                transformControls.addEventListener('dragging-changed', (event) => {
                    isCameraOrbitBlocked = event.value; // Block when dragging starts, unblock when ends
                    isMouseDown = false; // Also reset mouse state
                });
            }
        }

        // ============================================================
        // EXACT DIMENSIONS FROM FLOOR PLAN (converted to meters)
        // CORRECTED LAYOUT: Windows on FRONT (south), Doors on BACK (north)
        // Room S202 "Special Special" is LEFT, Room S203 "Reading Room" is RIGHT
        // Room S202 has an entry vestibule/corridor before main space
        // ============================================================
        const ROOM_S202_WIDTH = 3.496;  // 11'-5â…" (X direction)
        const ROOM_S202_DEPTH = 7.715;  // 25'-3Â¾" (Z direction)
        const ROOM_S203_WIDTH = 4.465;  // 14'-7Â¾"
        const ROOM_S203_DEPTH = 7.715;  // 25'-3Â¾"
        const CEILING_HEIGHT = 3.66;   // 12' ceiling
        const WALL_THICKNESS = 0.152;  // 6"
        const DOOR_WIDTH = 1.044;      // 3'-5â…›"
        const DOOR_HEIGHT = 2.134;     // 7'-0"

        // Entry vestibule dimensions for Room S202 (estimated from plan)
        const VESTIBULE_WIDTH = ROOM_S202_WIDTH;  // Same width as room
        const VESTIBULE_DEPTH = 1.5;  // ~5' deep vestibule/corridor

        // ============================================================
        // LAYOUT VALIDATION SYSTEM
        // Prevents bad furniture placements from rendering
        // ============================================================

        // Asset Whitelist - Only these items can be placed
        const ASSET_WHITELIST = {
            // S202 - SOUND LIBRARY / RADIO ROOM
            'audio_station': {
                id: 'audio_station',
                name: 'DJ / Audio Station',
                footprint: { width: 1.2, depth: 0.6 },
                clearance: { front: 0.8, back: 0.1, left: 0.2, right: 0.2 },
                allowedRooms: ['S202'],
                wallAnchor: 'west', // Must be against west wall
                maxCount: 1
            },
            'floor_speaker': {
                id: 'floor_speaker',
                name: 'Floor Speaker',
                footprint: { width: 0.35, depth: 0.35 },
                clearance: { front: 0.5, back: 0.1, left: 0.1, right: 0.1 },
                allowedRooms: ['S202'],
                wallAnchor: null, // Corners preferred
                maxCount: 4
            },
            'simple_pouf': {
                id: 'simple_pouf',
                name: 'Floor Pouf/Cushion',
                footprint: { width: 0.6, depth: 0.6 },
                clearance: { front: 0.3, back: 0.3, left: 0.3, right: 0.3 },
                allowedRooms: ['S202'],
                wallAnchor: null, // Perimeter seating
                maxCount: 8
            },
            'headphone_station': {
                id: 'headphone_station',
                name: 'Headphone Listening Station',
                footprint: { width: 0.5, depth: 0.5 },
                clearance: { front: 0.6, back: 0.1, left: 0.3, right: 0.3 },
                allowedRooms: ['S202'],
                wallAnchor: 'east',
                maxCount: 3
            },
            'african_natte': {
                id: 'african_natte',
                name: 'African Woven Mat',
                footprint: { width: 2.0, depth: 1.5 },
                clearance: { front: 0, back: 0, left: 0, right: 0 },
                allowedRooms: ['S202'],
                wallAnchor: null,
                maxCount: 2
            },

            // S203 - PANAFRICAN LIBRARY / READING ROOM
            'reading_table': {
                id: 'reading_table',
                name: 'Reading Table',
                footprint: { width: 1.8, depth: 0.9 },
                clearance: { front: 0.8, back: 0.8, left: 0.6, right: 0.6 },
                allowedRooms: ['S203'],
                wallAnchor: null, // Center of room
                maxCount: 2
            },
            'stackable_chair': {
                id: 'stackable_chair',
                name: 'Stackable Chair',
                footprint: { width: 0.45, depth: 0.45 },
                clearance: { front: 0.5, back: 0.1, left: 0.1, right: 0.1 },
                allowedRooms: ['S203'],
                wallAnchor: null,
                maxCount: 12
            },
            'wall_shelf': {
                id: 'wall_shelf',
                name: 'Wall-Mounted Archive Shelf',
                footprint: { width: 1.2, depth: 0.3 },
                clearance: { front: 0.6, back: 0, left: 0.1, right: 0.1 },
                allowedRooms: ['S203'],
                wallAnchor: 'any', // Must be on a wall
                maxCount: 6
            },
            'archive_cabinet': {
                id: 'archive_cabinet',
                name: 'Low Archive Cabinet',
                footprint: { width: 1.0, depth: 0.45 },
                clearance: { front: 0.6, back: 0.1, left: 0.1, right: 0.1 },
                allowedRooms: ['S203'],
                wallAnchor: 'any',
                maxCount: 4
            },
            'screen_stand': {
                id: 'screen_stand',
                name: 'Video Screen Stand',
                footprint: { width: 0.6, depth: 0.4 },
                clearance: { front: 1.5, back: 0.1, left: 0.3, right: 0.3 },
                allowedRooms: ['S203'],
                wallAnchor: null,
                maxCount: 2
            },
            'simple_stool': {
                id: 'simple_stool',
                name: 'Simple Stool',
                footprint: { width: 0.35, depth: 0.35 },
                clearance: { front: 0.4, back: 0.2, left: 0.2, right: 0.2 },
                allowedRooms: ['S203'],
                wallAnchor: null,
                maxCount: 6
            },
            'pendant_light': {
                id: 'pendant_light',
                name: 'Pendant Light',
                footprint: { width: 0.4, depth: 0.4 },
                clearance: { front: 0, back: 0, left: 0, right: 0 },
                allowedRooms: ['S202', 'S203'],
                wallAnchor: null, // Ceiling mounted
                isCeilingMounted: true,
                maxCount: 4
            }
        };

        // Room Geometry - Defines boundaries and keep-out zones
        const ROOM_GEOMETRY = {
            'S202': {
                id: 'S202',
                name: 'Sound Library / Radio Room',
                bounds: {
                    minX: -ROOM_S202_WIDTH / 2 - ROOM_S203_WIDTH / 2 - WALL_THICKNESS / 2,
                    maxX: -ROOM_S203_WIDTH / 2 - WALL_THICKNESS / 2,
                    minZ: -ROOM_S202_DEPTH / 2,
                    maxZ: ROOM_S202_DEPTH / 2
                },
                doorZone: {
                    // 1.2m clearance in front of door (north wall, center)
                    minX: -ROOM_S202_WIDTH / 2 - ROOM_S203_WIDTH / 2 - WALL_THICKNESS / 2 + ROOM_S202_WIDTH / 2 - DOOR_WIDTH,
                    maxX: -ROOM_S202_WIDTH / 2 - ROOM_S203_WIDTH / 2 - WALL_THICKNESS / 2 + ROOM_S202_WIDTH / 2 + DOOR_WIDTH,
                    minZ: -ROOM_S202_DEPTH / 2,
                    maxZ: -ROOM_S202_DEPTH / 2 + 1.2
                },
                circulationZones: [
                    // Main circulation path from door to window
                    {
                        minX: -ROOM_S202_WIDTH / 2 - ROOM_S203_WIDTH / 2 - WALL_THICKNESS / 2 + 0.8,
                        maxX: -ROOM_S203_WIDTH / 2 - WALL_THICKNESS / 2 - 0.8,
                        minZ: -ROOM_S202_DEPTH / 2 + 1.2,
                        maxZ: ROOM_S202_DEPTH / 2 - 1.0
                    }
                ],
                usableArea: null // Calculated at runtime
            },
            'S203': {
                id: 'S203',
                name: 'Panafrican Library / Reading Room',
                bounds: {
                    minX: WALL_THICKNESS / 2,
                    maxX: ROOM_S203_WIDTH + WALL_THICKNESS / 2,
                    minZ: -ROOM_S203_DEPTH / 2,
                    maxZ: ROOM_S203_DEPTH / 2
                },
                doorZone: {
                    // 1.2m clearance in front of door (north wall, center)
                    minX: WALL_THICKNESS / 2 + ROOM_S203_WIDTH / 2 - DOOR_WIDTH,
                    maxX: WALL_THICKNESS / 2 + ROOM_S203_WIDTH / 2 + DOOR_WIDTH,
                    minZ: -ROOM_S203_DEPTH / 2,
                    maxZ: -ROOM_S203_DEPTH / 2 + 1.2
                },
                circulationZones: [
                    // Main circulation from door
                    {
                        minX: WALL_THICKNESS / 2 + 0.6,
                        maxX: ROOM_S203_WIDTH + WALL_THICKNESS / 2 - 0.6,
                        minZ: -ROOM_S203_DEPTH / 2 + 1.2,
                        maxZ: -ROOM_S203_DEPTH / 2 + 2.5
                    }
                ],
                usableArea: null
            }
        };

        // Calculate usable areas (bounds minus door and circulation zones)
        function calculateUsableAreas() {
            for (const roomId in ROOM_GEOMETRY) {
                const room = ROOM_GEOMETRY[roomId];
                const bounds = room.bounds;
                const door = room.doorZone;
                // Usable area is the bounds with margin
                room.usableArea = {
                    minX: bounds.minX + 0.3,
                    maxX: bounds.maxX - 0.3,
                    minZ: bounds.minZ + 0.3,
                    maxZ: bounds.maxZ - 0.3
                };
            }
        }
        calculateUsableAreas();

        // 2D AABB Collision Detection
        function getAABB(placement) {
            const asset = ASSET_WHITELIST[placement.assetId];
            if (!asset) return null;

            const halfW = asset.footprint.width / 2;
            const halfD = asset.footprint.depth / 2;

            // Account for rotation (simplified - assumes 90 degree increments)
            const rot = (placement.rotation || 0) % 360;
            const rotated = (rot === 90 || rot === 270);
            const w = rotated ? halfD : halfW;
            const d = rotated ? halfW : halfD;

            return {
                minX: placement.x - w,
                maxX: placement.x + w,
                minZ: placement.z - d,
                maxZ: placement.z + d
            };
        }

        function aabbsOverlap(a, b) {
            if (!a || !b) return false;
            return !(a.maxX < b.minX || a.minX > b.maxX ||
                     a.maxZ < b.minZ || a.minZ > b.maxZ);
        }

        function getAABBWithClearance(placement) {
            const asset = ASSET_WHITELIST[placement.assetId];
            if (!asset) return null;

            const base = getAABB(placement);
            if (!base) return null;

            const cl = asset.clearance;
            return {
                minX: base.minX - cl.left,
                maxX: base.maxX + cl.right,
                minZ: base.minZ - cl.back,
                maxZ: base.maxZ + cl.front
            };
        }

        // Layout Validation Function
        function validateLayout(placements) {
            const errors = [];
            const warnings = [];
            const assetCounts = {};

            for (let i = 0; i < placements.length; i++) {
                const p = placements[i];
                const asset = ASSET_WHITELIST[p.assetId];

                // 1. Check if asset is in whitelist
                if (!asset) {
                    errors.push(`Unknown asset: ${p.assetId}`);
                    continue;
                }

                // 2. Check room assignment
                if (!asset.allowedRooms.includes(p.roomId)) {
                    errors.push(`${asset.name} not allowed in room ${p.roomId}`);
                }

                // 3. Check max count
                assetCounts[p.assetId] = (assetCounts[p.assetId] || 0) + 1;
                if (assetCounts[p.assetId] > asset.maxCount) {
                    errors.push(`Too many ${asset.name} (max ${asset.maxCount})`);
                }

                // 4. Check room boundaries
                const room = ROOM_GEOMETRY[p.roomId];
                if (room) {
                    const aabb = getAABB(p);
                    if (aabb) {
                        const usable = room.usableArea;
                        if (aabb.minX < usable.minX || aabb.maxX > usable.maxX ||
                            aabb.minZ < usable.minZ || aabb.maxZ > usable.maxZ) {
                            errors.push(`${asset.name} outside room boundaries`);
                        }

                        // 5. Check door zone collision
                        if (aabbsOverlap(aabb, room.doorZone)) {
                            errors.push(`${asset.name} blocks door in ${p.roomId}`);
                        }
                    }
                }

                // 6. Check wall anchor requirements
                if (asset.wallAnchor && asset.wallAnchor !== 'any') {
                    const room = ROOM_GEOMETRY[p.roomId];
                    if (room) {
                        const bounds = room.bounds;
                        const wallMargin = 0.5;
                        let anchored = false;

                        if (asset.wallAnchor === 'west' && Math.abs(p.x - bounds.minX) < wallMargin) anchored = true;
                        if (asset.wallAnchor === 'east' && Math.abs(p.x - bounds.maxX) < wallMargin) anchored = true;
                        if (asset.wallAnchor === 'north' && Math.abs(p.z - bounds.minZ) < wallMargin) anchored = true;
                        if (asset.wallAnchor === 'south' && Math.abs(p.z - bounds.maxZ) < wallMargin) anchored = true;

                        if (!anchored) {
                            warnings.push(`${asset.name} should be against ${asset.wallAnchor} wall`);
                        }
                    }
                }

                // 7. Check collision with other placements
                for (let j = i + 1; j < placements.length; j++) {
                    const other = placements[j];
                    const aabb1 = getAABBWithClearance(p);
                    const aabb2 = getAABBWithClearance(other);

                    if (aabbsOverlap(aabb1, aabb2)) {
                        const otherAsset = ASSET_WHITELIST[other.assetId];
                        errors.push(`${asset.name} collides with ${otherAsset?.name || other.assetId}`);
                    }
                }
            }

            return {
                valid: errors.length === 0,
                errors: errors,
                warnings: warnings
            };
        }

        // Layout Scoring Function
        function scoreLayout(placements) {
            let score = 100;
            const validation = validateLayout(placements);

            // Hard failures
            if (!validation.valid) {
                return { score: 0, details: 'Invalid layout: ' + validation.errors.join(', ') };
            }

            // Deduct for warnings
            score -= validation.warnings.length * 5;

            // Check functional completeness
            const hasAudioStation = placements.some(p => p.assetId === 'audio_station' && p.roomId === 'S202');
            const hasReadingTable = placements.some(p => p.assetId === 'reading_table' && p.roomId === 'S203');
            const hasSeating = placements.some(p =>
                ['simple_pouf', 'stackable_chair', 'simple_stool'].includes(p.assetId)
            );

            if (!hasAudioStation) score -= 20;
            if (!hasReadingTable) score -= 20;
            if (!hasSeating) score -= 15;

            // Bonus for good distribution
            const s202Count = placements.filter(p => p.roomId === 'S202').length;
            const s203Count = placements.filter(p => p.roomId === 'S203').length;
            if (s202Count > 0 && s203Count > 0) score += 10;

            return {
                score: Math.max(0, Math.min(100, score)),
                details: validation.warnings.length > 0 ?
                    'Warnings: ' + validation.warnings.join(', ') : 'Good layout'
            };
        }

        // Convert Three.js position to placement format
        function objectToPlacement(obj, assetId, roomId) {
            return {
                assetId: assetId,
                roomId: roomId,
                x: obj.position.x,
                z: obj.position.z,
                rotation: (obj.rotation.y * 180 / Math.PI) % 360
            };
        }

        // Determine which room an object is in
        function getObjectRoom(obj) {
            const x = obj.position.x;
            const z = obj.position.z;

            for (const roomId in ROOM_GEOMETRY) {
                const room = ROOM_GEOMETRY[roomId];
                const b = room.bounds;
                if (x >= b.minX && x <= b.maxX && z >= b.minZ && z <= b.maxZ) {
                    return roomId;
                }
            }
            return null;
        }

        console.log('Layout validation system initialized');
        console.log('Asset whitelist:', Object.keys(ASSET_WHITELIST).length, 'items');
        console.log('Room geometries:', Object.keys(ROOM_GEOMETRY));

        // ============================================================
        // END LAYOUT VALIDATION SYSTEM
        // ============================================================

        // Window dimensions (from reference photos - MoMA PS1 industrial windows)
        // Tall rectangular windows with white frames, grid pattern
        const PS1_WINDOW_WIDTH = 1.3;      // ~4.25 feet
        const PS1_WINDOW_HEIGHT = 2.2;     // ~7.25 feet tall
        const PS1_WINDOW_SILL = 0.75;      // ~2.5 feet sill height
        const PS1_COLUMN_WIDTH = 0.25;     // White fluted columns between windows

        // Materials
        const wallMaterial = new THREE.MeshLambertMaterial({ color: 0xf8f8f5, side: THREE.DoubleSide });
        const ceilingMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff, side: THREE.DoubleSide }); // Pure white ceiling
        const brickMaterial = new THREE.MeshLambertMaterial({ color: 0xf0ebe5, side: THREE.DoubleSide });
        const floorMaterial = new THREE.MeshLambertMaterial({ color: 0xd4c8b8 });
        const darkBlueMaterial = new THREE.MeshLambertMaterial({ color: 0x2c3e5c });
        const windowFrameMaterial = new THREE.MeshLambertMaterial({ color: 0xe8e8e8 });
        const glassMaterial = new THREE.MeshLambertMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.25 });
        const woodMaterial = new THREE.MeshLambertMaterial({ color: 0xd4a76a });
        const ochreFloorMaterial = new THREE.MeshLambertMaterial({ color: 0xc9a227 });
        const redMaterial = new THREE.MeshLambertMaterial({ color: 0xc41e3a });

        // Groups for visibility control
        const labelsGroup = new THREE.Group();
        const ceilingsGroup = new THREE.Group();
        const wallsGroup = new THREE.Group();
        const roomS202Walls = { front: null, back: null, left: null, right: null, vestibuleLeft: null, vestibuleRight: null };
        const roomS203Walls = { front: null, back: null, left: null, right: null };

        const gridHelper = new THREE.GridHelper(20, 40, 0x444444, 0x333333);
        scene.add(gridHelper);

        // Position rooms side by side (Room S202 LEFT, Room S203 RIGHT)
        const TOTAL_WIDTH = ROOM_S202_WIDTH + WALL_THICKNESS + ROOM_S203_WIDTH;
        const ROOM_S202_X = -TOTAL_WIDTH / 2 + ROOM_S202_WIDTH / 2;
        const ROOM_S203_X = TOTAL_WIDTH / 2 - ROOM_S203_WIDTH / 2;

        // ============ HELPER FUNCTIONS ============

        function createArchedWindow(width, height, archRadius, hasFabricFrame = true) {
            const group = new THREE.Group();
            const frameThickness = 0.08;

            // Glass
            const glassShape = new THREE.Shape();
            glassShape.moveTo(-width/2, 0);
            glassShape.lineTo(-width/2, height - archRadius);
            glassShape.quadraticCurveTo(-width/2, height, 0, height);
            glassShape.quadraticCurveTo(width/2, height, width/2, height - archRadius);
            glassShape.lineTo(width/2, 0);
            glassShape.lineTo(-width/2, 0);

            const glass = new THREE.Mesh(new THREE.ShapeGeometry(glassShape), glassMaterial);
            group.add(glass);

            // Frame bars
            const leftFrame = new THREE.Mesh(new THREE.BoxGeometry(frameThickness, height - archRadius, frameThickness), windowFrameMaterial);
            leftFrame.position.set(-width/2, (height - archRadius)/2, 0);
            group.add(leftFrame);

            const rightFrame = new THREE.Mesh(new THREE.BoxGeometry(frameThickness, height - archRadius, frameThickness), windowFrameMaterial);
            rightFrame.position.set(width/2, (height - archRadius)/2, 0);
            group.add(rightFrame);

            const bottomFrame = new THREE.Mesh(new THREE.BoxGeometry(width + frameThickness, frameThickness, frameThickness), windowFrameMaterial);
            bottomFrame.position.set(0, 0, 0);
            group.add(bottomFrame);

            const centerFrame = new THREE.Mesh(new THREE.BoxGeometry(frameThickness, height - archRadius, frameThickness), windowFrameMaterial);
            centerFrame.position.set(0, (height - archRadius)/2, 0);
            group.add(centerFrame);

            const middleFrame = new THREE.Mesh(new THREE.BoxGeometry(width, frameThickness, frameThickness), windowFrameMaterial);
            middleFrame.position.set(0, height * 0.4, 0);
            group.add(middleFrame);

            // Dark blue fabric frame
            if (hasFabricFrame) {
                const fabricWidth = width + 0.4;
                const fabricHeight = height + 0.3;
                const leftFabric = new THREE.Mesh(new THREE.BoxGeometry(0.15, fabricHeight, 0.02), darkBlueMaterial);
                leftFabric.position.set(-fabricWidth/2, fabricHeight/2, 0.02);
                group.add(leftFabric);
                const rightFabric = new THREE.Mesh(new THREE.BoxGeometry(0.15, fabricHeight, 0.02), darkBlueMaterial);
                rightFabric.position.set(fabricWidth/2, fabricHeight/2, 0.02);
                group.add(rightFabric);
                const topFabric = new THREE.Mesh(new THREE.BoxGeometry(fabricWidth, 0.15, 0.02), darkBlueMaterial);
                topFabric.position.set(0, fabricHeight - 0.1, 0.02);
                group.add(topFabric);
            }

            return group;
        }

        // MoMA PS1 style industrial window - tall rectangular with grid pattern
        function createPS1Window(width, height) {
            const group = new THREE.Group();

            // Glass pane
            const glass = new THREE.Mesh(
                new THREE.PlaneGeometry(width, height),
                glassMaterial
            );
            group.add(glass);

            // White window frame
            const frameThickness = 0.05;
            const frameMat = new THREE.MeshLambertMaterial({ color: 0xffffff });

            // Outer frame
            const topFrame = new THREE.Mesh(new THREE.BoxGeometry(width + 0.08, frameThickness, frameThickness), frameMat);
            topFrame.position.set(0, height/2, 0.02);
            group.add(topFrame);

            const bottomFrame = new THREE.Mesh(new THREE.BoxGeometry(width + 0.08, frameThickness, frameThickness), frameMat);
            bottomFrame.position.set(0, -height/2, 0.02);
            group.add(bottomFrame);

            const leftFrame = new THREE.Mesh(new THREE.BoxGeometry(frameThickness, height, frameThickness), frameMat);
            leftFrame.position.set(-width/2, 0, 0.02);
            group.add(leftFrame);

            const rightFrame = new THREE.Mesh(new THREE.BoxGeometry(frameThickness, height, frameThickness), frameMat);
            rightFrame.position.set(width/2, 0, 0.02);
            group.add(rightFrame);

            // Horizontal dividers (3 panes vertically = 2 dividers)
            const dividerH1 = new THREE.Mesh(new THREE.BoxGeometry(width, frameThickness * 0.7, frameThickness), frameMat);
            dividerH1.position.set(0, height * 0.2, 0.02);
            group.add(dividerH1);

            const dividerH2 = new THREE.Mesh(new THREE.BoxGeometry(width, frameThickness * 0.7, frameThickness), frameMat);
            dividerH2.position.set(0, -height * 0.2, 0.02);
            group.add(dividerH2);

            // Vertical center divider
            const centerV = new THREE.Mesh(new THREE.BoxGeometry(frameThickness * 0.7, height, frameThickness), frameMat);
            centerV.position.set(0, 0, 0.02);
            group.add(centerV);

            return group;
        }

        // Create white fluted column/pilaster (decorative element between windows)
        function createFlutedColumn(height) {
            const group = new THREE.Group();
            const columnMat = new THREE.MeshLambertMaterial({ color: 0xf5f5f0 });

            // Main column body
            const column = new THREE.Mesh(
                new THREE.BoxGeometry(PS1_COLUMN_WIDTH, height, 0.1),
                columnMat
            );
            column.position.set(0, height/2, 0);
            group.add(column);

            // Add fluting detail (vertical ridges)
            const fluteMat = new THREE.MeshLambertMaterial({ color: 0xe8e8e3 });
            for (let i = -2; i <= 2; i++) {
                const flute = new THREE.Mesh(
                    new THREE.BoxGeometry(0.02, height, 0.03),
                    fluteMat
                );
                flute.position.set(i * 0.05, height/2, 0.06);
                group.add(flute);
            }

            return group;
        }

        function createFloorCushion(color, size = 0.6) {
            const group = new THREE.Group();
            const cushion = new THREE.Mesh(new THREE.SphereGeometry(size / 2, 16, 12), new THREE.MeshLambertMaterial({ color }));
            cushion.scale.set(1, 0.5, 1);
            cushion.position.set(0, size * 0.25, 0);
            group.add(cushion);
            return group;
        }

        function createTuftedFloorMattress(width, depth) {
            const group = new THREE.Group();
            const mattress = new THREE.Mesh(new THREE.BoxGeometry(width, 0.2, depth), ochreFloorMaterial);
            mattress.position.set(0, 0.1, 0);
            group.add(mattress);
            const buttonMat = new THREE.MeshLambertMaterial({ color: 0xa88520 });
            for (let x = -width/2 + 0.3; x < width/2; x += 0.3) {
                for (let z = -depth/2 + 0.3; z < depth/2; z += 0.3) {
                    const button = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.05, 8), buttonMat);
                    button.position.set(x, 0.2, z);
                    group.add(button);
                }
            }
            return group;
        }

        function createLayeredRug(width, depth, color) {
            const group = new THREE.Group();
            const rug = new THREE.Mesh(new THREE.BoxGeometry(width, 0.02, depth), new THREE.MeshLambertMaterial({ color }));
            rug.position.set(0, 0.01, 0);
            group.add(rug);
            const borderMat = new THREE.MeshLambertMaterial({ color: 0x2d2d2d });
            const topBorder = new THREE.Mesh(new THREE.BoxGeometry(width, 0.025, 0.05), borderMat);
            topBorder.position.set(0, 0.02, -depth/2 + 0.025);
            group.add(topBorder);
            const bottomBorder = new THREE.Mesh(new THREE.BoxGeometry(width, 0.025, 0.05), borderMat);
            bottomBorder.position.set(0, 0.02, depth/2 - 0.025);
            group.add(bottomBorder);
            return group;
        }

        function createWoodenBookshelf(width, height, rows) {
            const group = new THREE.Group();
            const shelfWood = new THREE.MeshLambertMaterial({ color: 0xe8d4b8 });
            const backPanel = new THREE.Mesh(new THREE.BoxGeometry(width, height, 0.02), shelfWood);
            backPanel.position.set(0, height/2, 0);
            group.add(backPanel);

            const shelfSpacing = height / (rows + 1);
            for (let i = 1; i <= rows; i++) {
                const shelf = new THREE.Mesh(new THREE.BoxGeometry(width, 0.02, 0.15), shelfWood);
                shelf.position.set(0, i * shelfSpacing, 0.08);
                group.add(shelf);
                const bookCount = Math.floor(width / 0.2);
                const bookColors = [0x4ecdc4, 0xff6b6b, 0xffd93d, 0x45b7d1, 0x96ceb4, 0xa29bfe, 0xe17055, 0x00b894];
                for (let j = 0; j < bookCount; j++) {
                    const book = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, 0.02), new THREE.MeshLambertMaterial({ color: bookColors[j % bookColors.length] }));
                    book.position.set(-width/2 + 0.1 + j * 0.18, i * shelfSpacing + 0.12, 0.14);
                    group.add(book);
                }
            }
            return group;
        }

        function createPottedPlant() {
            const group = new THREE.Group();
            const pot = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.1, 0.2, 12), new THREE.MeshLambertMaterial({ color: 0xc4713d }));
            pot.position.set(0, 0.1, 0);
            group.add(pot);
            const soil = new THREE.Mesh(new THREE.CylinderGeometry(0.11, 0.11, 0.03, 12), new THREE.MeshLambertMaterial({ color: 0x4a3728 }));
            soil.position.set(0, 0.2, 0);
            group.add(soil);
            const leafMat = new THREE.MeshLambertMaterial({ color: 0x228b22 });
            for (let i = 0; i < 6; i++) {
                const leaf = new THREE.Mesh(new THREE.SphereGeometry(0.08 + Math.random() * 0.04, 8, 8), leafMat);
                leaf.position.set((Math.random() - 0.5) * 0.15, 0.35 + Math.random() * 0.15, (Math.random() - 0.5) * 0.15);
                leaf.scale.set(1, 0.6, 1);
                group.add(leaf);
            }
            return group;
        }

        function createPendantLight() {
            const group = new THREE.Group();
            const cord = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.8, 8), new THREE.MeshLambertMaterial({ color: 0x333333 }));
            cord.position.set(0, 0.4, 0);
            group.add(cord);
            const shade = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.25, 0.2, 16, 1, true), new THREE.MeshLambertMaterial({ color: 0xd4a76a, side: THREE.DoubleSide }));
            group.add(shade);
            const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), new THREE.MeshBasicMaterial({ color: 0xfffacd }));
            group.add(bulb);
            return group;
        }

        function createLowCoffeeTable() {
            const group = new THREE.Group();
            const tableMat = new THREE.MeshLambertMaterial({ color: 0xc4a77d });
            const top = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 0.04, 24), tableMat);
            top.position.set(0, 0.25, 0);
            group.add(top);
            for (let i = 0; i < 3; i++) {
                const angle = (i * 2 * Math.PI) / 3;
                const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.04, 0.23, 8), tableMat);
                leg.position.set(Math.cos(angle) * 0.25, 0.115, Math.sin(angle) * 0.25);
                group.add(leg);
            }
            return group;
        }

        function createRedBookDisplay() {
            const group = new THREE.Group();
            const bodyWidth = 0.7, bodyHeight = 0.9, bodyDepth = 0.5;
            const backPanel = new THREE.Mesh(new THREE.BoxGeometry(bodyWidth, bodyHeight, 0.03), redMaterial);
            backPanel.position.set(0, bodyHeight/2, -bodyDepth/2);
            group.add(backPanel);
            for (let i = 0; i < 4; i++) {
                const shelf = new THREE.Mesh(new THREE.BoxGeometry(bodyWidth - 0.05, 0.02, bodyDepth * 0.6), redMaterial);
                shelf.position.set(0, 0.15 + i * 0.2, -0.1);
                shelf.rotation.x = -0.2;
                group.add(shelf);
                const bookColors = [0xffffff, 0x4ecdc4, 0xff6b6b, 0xffd93d, 0x95e1d3];
                for (let j = 0; j < 5; j++) {
                    const book = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.15, 0.01), new THREE.MeshLambertMaterial({ color: bookColors[j] }));
                    book.position.set(-0.25 + j * 0.12, 0.25 + i * 0.2, 0);
                    book.rotation.x = -0.3;
                    group.add(book);
                }
            }
            const sideL = new THREE.Mesh(new THREE.BoxGeometry(0.03, bodyHeight, bodyDepth), redMaterial);
            sideL.position.set(-bodyWidth/2, bodyHeight/2, 0);
            group.add(sideL);
            const sideR = new THREE.Mesh(new THREE.BoxGeometry(0.03, bodyHeight, bodyDepth), redMaterial);
            sideR.position.set(bodyWidth/2, bodyHeight/2, 0);
            group.add(sideR);
            return group;
        }

        function createPosterWall(width, height) {
            const group = new THREE.Group();
            const baseWall = new THREE.Mesh(new THREE.PlaneGeometry(width, height), new THREE.MeshLambertMaterial({ color: 0xf5f0e8 }));
            group.add(baseWall);
            const posterColors = [0xff6b6b, 0xffd93d, 0x4ecdc4, 0x45b7d1, 0x96ceb4, 0xffeaa7, 0xdfe6e9, 0xfd79a8, 0x00b894, 0xe17055, 0x74b9ff, 0xa29bfe, 0x55efc4, 0xfdcb6e, 0xe84393];
            for (let i = 0; i < 60; i++) {
                const posterW = 0.15 + Math.random() * 0.3;
                const posterH = 0.2 + Math.random() * 0.35;
                const poster = new THREE.Mesh(new THREE.PlaneGeometry(posterW, posterH), new THREE.MeshLambertMaterial({ color: posterColors[Math.floor(Math.random() * posterColors.length)] }));
                poster.position.set((Math.random() - 0.5) * (width - posterW), (Math.random() - 0.5) * (height - posterH), 0.005 + i * 0.001);
                poster.rotation.z = (Math.random() - 0.5) * 0.1;
                group.add(poster);
            }
            return group;
        }

        // ============ ROOM S202 - SPECIAL SPECIAL ============
        // LAYOUT: Windows on FRONT (+Z), Door to corridor on BACK (-Z) via VESTIBULE, Door to S203 on RIGHT (+X)
        // Has an entry vestibule/corridor - a narrow enclosed passage before the main room
        function createRoomS202() {
            const group = new THREE.Group();

            // Vestibule corridor dimensions - enclosed passage with side walls
            const CORRIDOR_WIDTH = 1.2;  // Narrow corridor width (~4 feet)
            const CORRIDOR_OFFSET_X = 0;  // Corridor centered on door

            // ========== FLOOR (entire room) ==========
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(ROOM_S202_WIDTH, ROOM_S202_DEPTH), floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(0, 0.01, 0);
            group.add(floor);

            // Dark blue carpet in main area (not in vestibule)
            const carpet = new THREE.Mesh(new THREE.PlaneGeometry(ROOM_S202_WIDTH - 0.5, ROOM_S202_DEPTH - VESTIBULE_DEPTH - 0.5), new THREE.MeshLambertMaterial({ color: 0x1a3a5c }));
            carpet.rotation.x = -Math.PI / 2;
            carpet.position.set(0, 0.02, VESTIBULE_DEPTH / 2);
            group.add(carpet);

            // ========== BACK WALL (-Z) - Door to corridor/STUDIO ==========
            const backWallGroup = new THREE.Group();
            const backWall1 = new THREE.Mesh(new THREE.BoxGeometry((ROOM_S202_WIDTH - DOOR_WIDTH) / 2, CEILING_HEIGHT, WALL_THICKNESS), wallMaterial);
            backWall1.position.set(-ROOM_S202_WIDTH / 4 - DOOR_WIDTH / 4, CEILING_HEIGHT / 2, -ROOM_S202_DEPTH / 2);
            backWallGroup.add(backWall1);
            const backWall2 = new THREE.Mesh(new THREE.BoxGeometry((ROOM_S202_WIDTH - DOOR_WIDTH) / 2, CEILING_HEIGHT, WALL_THICKNESS), wallMaterial);
            backWall2.position.set(ROOM_S202_WIDTH / 4 + DOOR_WIDTH / 4, CEILING_HEIGHT / 2, -ROOM_S202_DEPTH / 2);
            backWallGroup.add(backWall2);
            const backDoorHeader = new THREE.Mesh(new THREE.BoxGeometry(DOOR_WIDTH, CEILING_HEIGHT - DOOR_HEIGHT, WALL_THICKNESS), wallMaterial);
            backDoorHeader.position.set(0, DOOR_HEIGHT + (CEILING_HEIGHT - DOOR_HEIGHT) / 2, -ROOM_S202_DEPTH / 2);
            backWallGroup.add(backDoorHeader);
            group.add(backWallGroup);
            roomS202Walls.back = backWallGroup;

            // ========== VESTIBULE CORRIDOR WALLS ==========
            // The vestibule is an enclosed corridor with:
            // - Two SIDE walls running from back wall (-Z) toward the room (+Z)
            // - One FRONT wall (partition) with a door opening to main room
            const vestibuleGroup = new THREE.Group();

            // LEFT side wall of vestibule (runs along Z axis)
            const vestibuleLeftSide = new THREE.Mesh(
                new THREE.BoxGeometry(WALL_THICKNESS, CEILING_HEIGHT, VESTIBULE_DEPTH),
                wallMaterial
            );
            vestibuleLeftSide.position.set(
                CORRIDOR_OFFSET_X - CORRIDOR_WIDTH / 2,
                CEILING_HEIGHT / 2,
                -ROOM_S202_DEPTH / 2 + VESTIBULE_DEPTH / 2
            );
            vestibuleGroup.add(vestibuleLeftSide);

            // RIGHT side wall of vestibule (runs along Z axis)
            const vestibuleRightSide = new THREE.Mesh(
                new THREE.BoxGeometry(WALL_THICKNESS, CEILING_HEIGHT, VESTIBULE_DEPTH),
                wallMaterial
            );
            vestibuleRightSide.position.set(
                CORRIDOR_OFFSET_X + CORRIDOR_WIDTH / 2,
                CEILING_HEIGHT / 2,
                -ROOM_S202_DEPTH / 2 + VESTIBULE_DEPTH / 2
            );
            vestibuleGroup.add(vestibuleRightSide);

            // FRONT partition wall of vestibule (with door opening to main room)
            // Left section of front partition
            const partitionLeftWidth = (ROOM_S202_WIDTH / 2) - (CORRIDOR_WIDTH / 2) - CORRIDOR_OFFSET_X;
            if (partitionLeftWidth > 0) {
                const partitionLeft = new THREE.Mesh(
                    new THREE.BoxGeometry(partitionLeftWidth, CEILING_HEIGHT, WALL_THICKNESS),
                    wallMaterial
                );
                partitionLeft.position.set(
                    -ROOM_S202_WIDTH / 2 + partitionLeftWidth / 2,
                    CEILING_HEIGHT / 2,
                    -ROOM_S202_DEPTH / 2 + VESTIBULE_DEPTH
                );
                vestibuleGroup.add(partitionLeft);
            }

            // Right section of front partition
            const partitionRightWidth = (ROOM_S202_WIDTH / 2) - (CORRIDOR_WIDTH / 2) + CORRIDOR_OFFSET_X;
            if (partitionRightWidth > 0) {
                const partitionRight = new THREE.Mesh(
                    new THREE.BoxGeometry(partitionRightWidth, CEILING_HEIGHT, WALL_THICKNESS),
                    wallMaterial
                );
                partitionRight.position.set(
                    ROOM_S202_WIDTH / 2 - partitionRightWidth / 2,
                    CEILING_HEIGHT / 2,
                    -ROOM_S202_DEPTH / 2 + VESTIBULE_DEPTH
                );
                vestibuleGroup.add(partitionRight);
            }

            // Header above vestibule door opening
            const vestibuleDoorHeader = new THREE.Mesh(
                new THREE.BoxGeometry(CORRIDOR_WIDTH, CEILING_HEIGHT - DOOR_HEIGHT, WALL_THICKNESS),
                wallMaterial
            );
            vestibuleDoorHeader.position.set(
                CORRIDOR_OFFSET_X,
                DOOR_HEIGHT + (CEILING_HEIGHT - DOOR_HEIGHT) / 2,
                -ROOM_S202_DEPTH / 2 + VESTIBULE_DEPTH
            );
            vestibuleGroup.add(vestibuleDoorHeader);

            group.add(vestibuleGroup);
            roomS202Walls.vestibuleLeft = vestibuleLeftSide;
            roomS202Walls.vestibuleRight = vestibuleRightSide;
            roomS202Walls.vestibuleGroup = vestibuleGroup;  // Store entire vestibule for hiding

            // ========== FRONT WALL (+Z) - PS1 Industrial Windows ==========
            const frontWallGroup = new THREE.Group();

            // Wall below windows (sill area)
            const frontWallBase = new THREE.Mesh(
                new THREE.BoxGeometry(ROOM_S202_WIDTH, PS1_WINDOW_SILL, WALL_THICKNESS),
                wallMaterial
            );
            frontWallBase.position.set(0, PS1_WINDOW_SILL / 2, ROOM_S202_DEPTH / 2);
            frontWallGroup.add(frontWallBase);

            // Wall above windows
            const topWallHeight = CEILING_HEIGHT - PS1_WINDOW_SILL - PS1_WINDOW_HEIGHT;
            const frontWallTop = new THREE.Mesh(
                new THREE.BoxGeometry(ROOM_S202_WIDTH, topWallHeight, WALL_THICKNESS),
                wallMaterial
            );
            frontWallTop.position.set(0, PS1_WINDOW_SILL + PS1_WINDOW_HEIGHT + topWallHeight / 2, ROOM_S202_DEPTH / 2);
            frontWallGroup.add(frontWallTop);

            // Two windows with fluted column between them
            const windowSpacing = (ROOM_S202_WIDTH - PS1_COLUMN_WIDTH) / 2;
            const windowCenterY = PS1_WINDOW_SILL + PS1_WINDOW_HEIGHT / 2;

            // Left window
            const win1 = createPS1Window(PS1_WINDOW_WIDTH, PS1_WINDOW_HEIGHT);
            win1.position.set(-windowSpacing / 2, windowCenterY, ROOM_S202_DEPTH / 2 - 0.02);
            frontWallGroup.add(win1);

            // Right window
            const win2 = createPS1Window(PS1_WINDOW_WIDTH, PS1_WINDOW_HEIGHT);
            win2.position.set(windowSpacing / 2, windowCenterY, ROOM_S202_DEPTH / 2 - 0.02);
            frontWallGroup.add(win2);

            // Fluted column between windows
            const columnS202 = createFlutedColumn(PS1_WINDOW_HEIGHT);
            columnS202.position.set(0, PS1_WINDOW_SILL, ROOM_S202_DEPTH / 2 - 0.02);
            frontWallGroup.add(columnS202);

            // Wall sections on either side of windows
            const sideWallWidth = (ROOM_S202_WIDTH - windowSpacing * 2 - PS1_WINDOW_WIDTH * 2) / 2 + 0.3;
            if (sideWallWidth > 0.1) {
                const leftSide = new THREE.Mesh(
                    new THREE.BoxGeometry(sideWallWidth, PS1_WINDOW_HEIGHT, WALL_THICKNESS),
                    wallMaterial
                );
                leftSide.position.set(-ROOM_S202_WIDTH / 2 + sideWallWidth / 2, windowCenterY, ROOM_S202_DEPTH / 2);
                frontWallGroup.add(leftSide);

                const rightSide = new THREE.Mesh(
                    new THREE.BoxGeometry(sideWallWidth, PS1_WINDOW_HEIGHT, WALL_THICKNESS),
                    wallMaterial
                );
                rightSide.position.set(ROOM_S202_WIDTH / 2 - sideWallWidth / 2, windowCenterY, ROOM_S202_DEPTH / 2);
                frontWallGroup.add(rightSide);
            }

            group.add(frontWallGroup);
            roomS202Walls.front = frontWallGroup;

            // ========== LEFT WALL (-X) - Wall with CLOSED DOOR to Three Star room ==========
            // From floor plan: Three Star door is near the SOUTH (window) end of the west wall
            // The west wall runs the full depth of the room from north to south
            const leftWallGroup = new THREE.Group();

            // Wall X position (west wall of room) - flush with room boundary
            const leftWallX = -ROOM_S202_WIDTH / 2;

            // Room Z boundaries
            const roomSouthZ = ROOM_S202_DEPTH / 2;    // South - windows (+Z)
            const roomNorthZ = -ROOM_S202_DEPTH / 2;   // North - corridor entry (-Z)

            // Three Star door position - near the SOUTH (window) end
            // From floor plan, door appears about 1.5m from the south wall
            const threeStarDoorCenterZ = roomSouthZ - 1.5;  // 1.5m from south wall
            const doorHalfWidth = DOOR_WIDTH / 2;

            // SOUTH segment: short wall between door and south wall (window wall)
            const southSegmentLength = roomSouthZ - (threeStarDoorCenterZ + doorHalfWidth);
            if (southSegmentLength > 0.05) {
                const leftWallSouth = new THREE.Mesh(
                    new THREE.BoxGeometry(WALL_THICKNESS, CEILING_HEIGHT, southSegmentLength),
                    wallMaterial
                );
                leftWallSouth.position.set(leftWallX, CEILING_HEIGHT / 2, roomSouthZ - southSegmentLength / 2);
                leftWallGroup.add(leftWallSouth);
            }

            // NORTH segment: long wall from door to north wall (runs past vestibule area)
            const northSegmentLength = (threeStarDoorCenterZ - doorHalfWidth) - roomNorthZ;
            if (northSegmentLength > 0.05) {
                const leftWallNorth = new THREE.Mesh(
                    new THREE.BoxGeometry(WALL_THICKNESS, CEILING_HEIGHT, northSegmentLength),
                    wallMaterial
                );
                leftWallNorth.position.set(leftWallX, CEILING_HEIGHT / 2, roomNorthZ + northSegmentLength / 2);
                leftWallGroup.add(leftWallNorth);
            }

            // Door header above the Three Star door
            const leftDoorHeader = new THREE.Mesh(
                new THREE.BoxGeometry(WALL_THICKNESS, CEILING_HEIGHT - DOOR_HEIGHT, DOOR_WIDTH),
                wallMaterial
            );
            leftDoorHeader.position.set(leftWallX, DOOR_HEIGHT + (CEILING_HEIGHT - DOOR_HEIGHT) / 2, threeStarDoorCenterZ);
            leftWallGroup.add(leftDoorHeader);

            // CLOSED DOOR to Three Star room (brown wood panel)
            const threeStarDoor = new THREE.Mesh(
                new THREE.BoxGeometry(0.05, DOOR_HEIGHT, DOOR_WIDTH),
                new THREE.MeshLambertMaterial({ color: 0x8B4513 })
            );
            threeStarDoor.position.set(leftWallX + 0.03, DOOR_HEIGHT / 2, threeStarDoorCenterZ);
            leftWallGroup.add(threeStarDoor);

            // Door handle (silver)
            const doorHandle = new THREE.Mesh(
                new THREE.BoxGeometry(0.03, 0.12, 0.03),
                new THREE.MeshLambertMaterial({ color: 0xC0C0C0 })
            );
            doorHandle.position.set(leftWallX + 0.07, DOOR_HEIGHT / 2, threeStarDoorCenterZ + doorHalfWidth - 0.15);
            leftWallGroup.add(doorHandle);

            group.add(leftWallGroup);
            roomS202Walls.left = leftWallGroup;

            // ========== RIGHT WALL (+X) - SHARED with Room S203 ==========
            // REMOVED: This wall is now created ONLY by Room S203 as its left wall
            // to prevent duplicate walls and z-fighting/jumping issues
            // The shared wall is positioned at the exact boundary between rooms
            roomS202Walls.right = null;  // No wall here - S203's left wall serves both rooms

            // ========== CEILING ==========
            const ceilingS202 = new THREE.Mesh(new THREE.PlaneGeometry(ROOM_S202_WIDTH, ROOM_S202_DEPTH), ceilingMaterial);
            ceilingS202.rotation.x = Math.PI / 2;
            ceilingS202.position.set(0, CEILING_HEIGHT, 0);
            ceilingS202.userData.isCeiling = true;
            group.add(ceilingS202);

            // ========== S202 - SOUND LIBRARY / RADIO ROOM ==========
            // CURATORIAL BRIEF: Collective listening space for sound library, radio,
            // DJ sets, readings, performances, poetry, round tables
            //
            // SPATIAL RULES:
            // - Primary function = LISTENING
            // - Clear central area for gatherings/performances
            // - Low seating that doesn't block circulation
            // - Speakers face inward, not blocked
            // - Minimum 1.1m circulation paths

            const mainRoomZ = VESTIBULE_DEPTH / 2 + 0.8;  // Center after vestibule
            const windowZ = ROOM_S202_DEPTH / 2 - 1.2;    // Near window wall (inside boundary)

            // Helper to add furniture with proper marking
            function addFurniture(item, name) {
                item.userData.isFurniture = true;
                item.userData.itemType = name;
                item.name = name;
                group.add(item);
            }

            // === AUDIO STATION - West wall, near entry ===
            const audioStation = createAudioStation();
            audioStation.position.set(-ROOM_S202_WIDTH / 2 + 0.5, 0, mainRoomZ - 1.0);
            audioStation.rotation.y = Math.PI / 2;
            addFurniture(audioStation, 'audio-station');

            // === SPEAKERS ON STANDS - CORNERS near window wall ===
            const speakerCornerOffset = 0.25;
            const speaker1 = createFloorSpeaker();
            speaker1.position.set(-ROOM_S202_WIDTH / 2 + speakerCornerOffset, 0, windowZ - speakerCornerOffset);
            speaker1.rotation.y = Math.PI * 0.75;
            addFurniture(speaker1, 'speaker-left');

            const speaker2 = createFloorSpeaker();
            speaker2.position.set(ROOM_S202_WIDTH / 2 - speakerCornerOffset, 0, windowZ - speakerCornerOffset);
            speaker2.rotation.y = Math.PI * 1.25;
            addFurniture(speaker2, 'speaker-right');

            // === CENTRAL GATHERING AREA ===
            const listeningMat = createAfricanNatte();
            listeningMat.position.set(0, 0.01, windowZ - 1.2);
            addFurniture(listeningMat, 'natte-mat');

            // === LOW SEATING - Perimeter ===
            const pouf1 = createSimplePouf(0x8b4513);
            pouf1.position.set(-ROOM_S202_WIDTH / 2 + 0.4, 0, windowZ - 1.5);
            addFurniture(pouf1, 'pouf-brown-1');

            const pouf2 = createSimplePouf(0x2f4f4f);
            pouf2.position.set(-ROOM_S202_WIDTH / 2 + 0.4, 0, windowZ - 2.2);
            addFurniture(pouf2, 'pouf-gray-1');

            const pouf3 = createSimplePouf(0x8b4513);
            pouf3.position.set(ROOM_S202_WIDTH / 2 - 0.4, 0, windowZ - 1.5);
            addFurniture(pouf3, 'pouf-brown-2');

            const pouf4 = createSimplePouf(0x2f4f4f);
            pouf4.position.set(ROOM_S202_WIDTH / 2 - 0.4, 0, windowZ - 2.2);
            addFurniture(pouf4, 'pouf-gray-2');

            // CENTER - on the listening mat
            const pouf5 = createSimplePouf(0xc41e3a);
            pouf5.position.set(-0.5, 0, windowZ - 1.2);
            addFurniture(pouf5, 'pouf-red-1');

            const pouf6 = createSimplePouf(0xc41e3a);
            pouf6.position.set(0.5, 0, windowZ - 1.2);
            addFurniture(pouf6, 'pouf-red-2');

            // === HEADPHONE STATION ===
            const headphoneStand = createHeadphoneStation();
            headphoneStand.position.set(ROOM_S202_WIDTH / 2 - 0.35, 0, mainRoomZ);
            headphoneStand.rotation.y = -Math.PI / 2;
            addFurniture(headphoneStand, 'headphone-station');

            // === AFRIKADAA WALL ART ===
            // Position posters ON the wall surface (wall is 0.152m thick, so +0.1 places them just inside room)
            const afrikadaaPoster1 = createAfrikadaaPoster('AFRIKADAA', 0xc41e3a, 0.5, 0.7);
            afrikadaaPoster1.position.set(-ROOM_S202_WIDTH / 2 + 0.1, 1.6, mainRoomZ + 0.5);
            afrikadaaPoster1.rotation.y = Math.PI / 2;
            afrikadaaPoster1.userData.isWallArt = true;
            addFurniture(afrikadaaPoster1, 'poster-afrikadaa-1');

            const afrikadaaPoster2 = createAfrikadaaPoster('PANAFRICAN', 0xfdd835, 0.4, 0.5);
            afrikadaaPoster2.position.set(-ROOM_S202_WIDTH / 2 + 0.1, 1.5, mainRoomZ - 0.3);
            afrikadaaPoster2.rotation.y = Math.PI / 2;
            afrikadaaPoster2.userData.isWallArt = true;
            addFurniture(afrikadaaPoster2, 'poster-afrikadaa-2');

            const afrikadaaPoster3 = createAfrikadaaPoster('DIASPORA', 0x00897b, 0.45, 0.6);
            afrikadaaPoster3.position.set(-ROOM_S202_WIDTH / 2 + 0.1, 1.7, mainRoomZ - 1.0);
            afrikadaaPoster3.rotation.y = Math.PI / 2;
            afrikadaaPoster3.userData.isWallArt = true;
            addFurniture(afrikadaaPoster3, 'poster-afrikadaa-3');

            // === MINIMAL LIGHTING ===
            const pendantLight = createSimplePendant();
            pendantLight.position.set(-ROOM_S202_WIDTH / 2 + 0.5, CEILING_HEIGHT - 0.4, mainRoomZ - 1.0);
            addFurniture(pendantLight, 'pendant-light-1');

            const pendantLight2 = createSimplePendant();
            pendantLight2.position.set(0, CEILING_HEIGHT - 0.4, windowZ - 1.2);
            addFurniture(pendantLight2, 'pendant-light-2');

            return group;
        }

        // ============ ROOM S203 - READING ROOM ============
        // LAYOUT: Windows on FRONT (+Z), Door to corridor on BACK (-Z), Door to S202 on LEFT (-X)
        function createRoomS203() {
            const group = new THREE.Group();

            // Floor
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(ROOM_S203_WIDTH, ROOM_S203_DEPTH), floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(0, 0.01, 0);
            group.add(floor);

            // BACK WALL (-Z) - Door to corridor (door is positioned toward LEFT, not centered)
            // From floor plan: door is closer to the shared wall with S202
            const backWallGroup = new THREE.Group();
            const doorOffsetX = -ROOM_S203_WIDTH / 4;  // Door offset toward left (shared wall side)

            // Left wall section (small, between door and left wall)
            const leftWallWidth = ROOM_S203_WIDTH / 2 + doorOffsetX - DOOR_WIDTH / 2;
            if (leftWallWidth > 0.1) {
                const backWallLeft = new THREE.Mesh(
                    new THREE.BoxGeometry(leftWallWidth, CEILING_HEIGHT, WALL_THICKNESS),
                    brickMaterial
                );
                backWallLeft.position.set(-ROOM_S203_WIDTH / 2 + leftWallWidth / 2, CEILING_HEIGHT / 2, -ROOM_S203_DEPTH / 2);
                backWallGroup.add(backWallLeft);
            }

            // Right wall section (larger, most of the poster wall)
            const rightWallWidth = ROOM_S203_WIDTH / 2 - doorOffsetX - DOOR_WIDTH / 2;
            const backWallRight = new THREE.Mesh(
                new THREE.BoxGeometry(rightWallWidth, CEILING_HEIGHT, WALL_THICKNESS),
                brickMaterial
            );
            backWallRight.position.set(ROOM_S203_WIDTH / 2 - rightWallWidth / 2, CEILING_HEIGHT / 2, -ROOM_S203_DEPTH / 2);
            backWallGroup.add(backWallRight);

            // Door header
            const backDoorHeader = new THREE.Mesh(
                new THREE.BoxGeometry(DOOR_WIDTH, CEILING_HEIGHT - DOOR_HEIGHT, WALL_THICKNESS),
                brickMaterial
            );
            backDoorHeader.position.set(doorOffsetX, DOOR_HEIGHT + (CEILING_HEIGHT - DOOR_HEIGHT) / 2, -ROOM_S203_DEPTH / 2);
            backWallGroup.add(backDoorHeader);

            // Poster wall on right section (main poster wall area)
            const posterWall = createPosterWall(rightWallWidth - 0.2, CEILING_HEIGHT - 0.3);
            posterWall.position.set(ROOM_S203_WIDTH / 2 - rightWallWidth / 2, CEILING_HEIGHT / 2, -ROOM_S203_DEPTH / 2 + WALL_THICKNESS / 2 + 0.02);
            backWallGroup.add(posterWall);

            group.add(backWallGroup);
            roomS203Walls.back = backWallGroup;

            // FRONT WALL (+Z) - PS1 Industrial Windows (same style as S202)
            const frontWallGroup = new THREE.Group();

            // Wall below windows
            const frontWallBase = new THREE.Mesh(
                new THREE.BoxGeometry(ROOM_S203_WIDTH, PS1_WINDOW_SILL, WALL_THICKNESS),
                brickMaterial
            );
            frontWallBase.position.set(0, PS1_WINDOW_SILL / 2, ROOM_S203_DEPTH / 2);
            frontWallGroup.add(frontWallBase);

            // Wall above windows
            const topWallHeightS203 = CEILING_HEIGHT - PS1_WINDOW_SILL - PS1_WINDOW_HEIGHT;
            const frontWallTop = new THREE.Mesh(
                new THREE.BoxGeometry(ROOM_S203_WIDTH, topWallHeightS203, WALL_THICKNESS),
                brickMaterial
            );
            frontWallTop.position.set(0, PS1_WINDOW_SILL + PS1_WINDOW_HEIGHT + topWallHeightS203 / 2, ROOM_S203_DEPTH / 2);
            frontWallGroup.add(frontWallTop);

            // Room S203 is wider, so it can have 3 windows with 2 columns
            const windowCenterYS203 = PS1_WINDOW_SILL + PS1_WINDOW_HEIGHT / 2;
            const totalWindowArea = ROOM_S203_WIDTH - 0.4;  // Leave some wall on sides
            const numWindows = 3;
            const numColumns = 2;
            const windowWidthS203 = (totalWindowArea - numColumns * PS1_COLUMN_WIDTH) / numWindows;
            const windowSpacingS203 = windowWidthS203 + PS1_COLUMN_WIDTH;

            // Create 3 windows with columns between
            for (let i = 0; i < numWindows; i++) {
                const xPos = -totalWindowArea / 2 + windowWidthS203 / 2 + i * windowSpacingS203;
                const win = createPS1Window(windowWidthS203 * 0.9, PS1_WINDOW_HEIGHT);
                win.position.set(xPos, windowCenterYS203, ROOM_S203_DEPTH / 2 - 0.02);
                frontWallGroup.add(win);

                // Add column after each window except the last
                if (i < numWindows - 1) {
                    const col = createFlutedColumn(PS1_WINDOW_HEIGHT);
                    col.position.set(xPos + windowSpacingS203 / 2, PS1_WINDOW_SILL, ROOM_S203_DEPTH / 2 - 0.02);
                    frontWallGroup.add(col);
                }
            }

            // Side wall sections
            const sideWidthS203 = 0.2;
            const leftSideS203 = new THREE.Mesh(
                new THREE.BoxGeometry(sideWidthS203, PS1_WINDOW_HEIGHT, WALL_THICKNESS),
                brickMaterial
            );
            leftSideS203.position.set(-ROOM_S203_WIDTH / 2 + sideWidthS203 / 2, windowCenterYS203, ROOM_S203_DEPTH / 2);
            frontWallGroup.add(leftSideS203);

            const rightSideS203 = new THREE.Mesh(
                new THREE.BoxGeometry(sideWidthS203, PS1_WINDOW_HEIGHT, WALL_THICKNESS),
                brickMaterial
            );
            rightSideS203.position.set(ROOM_S203_WIDTH / 2 - sideWidthS203 / 2, windowCenterYS203, ROOM_S203_DEPTH / 2);
            frontWallGroup.add(rightSideS203);

            group.add(frontWallGroup);
            roomS203Walls.front = frontWallGroup;

            // LEFT WALL (-X) - SHARED WALL with Room S202
            // This is the ONLY dividing wall between rooms (S202 does not create a right wall)
            // Position it at the left edge of S203, centered on the wall thickness
            const leftWall = new THREE.Mesh(
                new THREE.BoxGeometry(WALL_THICKNESS, CEILING_HEIGHT, ROOM_S203_DEPTH),
                brickMaterial
            );
            // Position exactly at room edge minus half wall thickness so it's centered between rooms
            leftWall.position.set(-ROOM_S203_WIDTH / 2 - WALL_THICKNESS / 2, CEILING_HEIGHT / 2, 0);
            group.add(leftWall);
            roomS203Walls.left = leftWall;

            // RIGHT WALL (+X) - Solid exterior wall
            const rightWall = new THREE.Mesh(new THREE.BoxGeometry(WALL_THICKNESS, CEILING_HEIGHT, ROOM_S203_DEPTH), brickMaterial);
            rightWall.position.set(ROOM_S203_WIDTH / 2, CEILING_HEIGHT / 2, 0);
            group.add(rightWall);
            roomS203Walls.right = rightWall;

            // Ceiling
            const ceilingS203 = new THREE.Mesh(new THREE.PlaneGeometry(ROOM_S203_WIDTH, ROOM_S203_DEPTH), ceilingMaterial);
            ceilingS203.rotation.x = Math.PI / 2;
            ceilingS203.position.set(0, CEILING_HEIGHT, 0);
            ceilingS203.userData.isCeiling = true;
            group.add(ceilingS203);

            // ========== S203 - PANAFRICAN LIBRARY / READING ROOM ==========
            // CURATORIAL BRIEF: Reading room for ~50 publications, AABF archives,
            // video interviews, publishing network mapping
            //
            // FUNCTIONS: Read, browse, watch, listen, move quietly
            //
            // SPATIAL RULES:
            // - Reading/browsing are PRIMARY
            // - Books visible, legible, face-up or face-out
            // - Clear viewing direction for screens
            // - Minimum 1.1m circulation paths
            // - 1.2m clearance from door
            // - NO domestic furniture (sofas, armchairs, coffee tables)

            // Helper to add furniture with proper marking
            function addFurniture(item, name, isWall = false) {
                item.userData.isFurniture = true;
                item.userData.itemType = name;
                item.userData.isWallArt = isWall;
                item.name = name;
                group.add(item);
            }

            // === READING AREA ===
            const readingTable = createReadingTable();
            readingTable.position.set(0, 0, -0.5);
            addFurniture(readingTable, 'reading-table');

            const chair1 = createStackableChair();
            chair1.position.set(-0.6, 0, -1.0);
            chair1.rotation.y = 0;
            addFurniture(chair1, 'chair-1');

            const chair2 = createStackableChair();
            chair2.position.set(0.6, 0, -1.0);
            chair2.rotation.y = 0;
            addFurniture(chair2, 'chair-2');

            const chair3 = createStackableChair();
            chair3.position.set(-0.6, 0, 0);
            chair3.rotation.y = Math.PI;
            addFurniture(chair3, 'chair-3');

            const chair4 = createStackableChair();
            chair4.position.set(0.6, 0, 0);
            chair4.rotation.y = Math.PI;
            addFurniture(chair4, 'chair-4');

            // === ARCHIVE WALL ===
            const archiveShelf1 = createWallShelf();
            archiveShelf1.position.set(ROOM_S203_WIDTH / 2 - 0.15, 1.2, -1.5);
            archiveShelf1.rotation.y = -Math.PI / 2;
            addFurniture(archiveShelf1, 'archive-shelf-1', true);

            const archiveShelf2 = createWallShelf();
            archiveShelf2.position.set(ROOM_S203_WIDTH / 2 - 0.15, 1.2, 0.5);
            archiveShelf2.rotation.y = -Math.PI / 2;
            addFurniture(archiveShelf2, 'archive-shelf-2', true);

            const archiveCabinet = createLowArchiveCabinet();
            archiveCabinet.position.set(ROOM_S203_WIDTH / 2 - 0.35, 0, -0.5);
            archiveCabinet.rotation.y = -Math.PI / 2;
            addFurniture(archiveCabinet, 'archive-cabinet');

            const bookDisplay = createWallShelf();
            bookDisplay.position.set(1.0, 1.2, -ROOM_S203_DEPTH / 2 + 0.15);
            addFurniture(bookDisplay, 'book-display', true);

            // === VIDEO/MEDIA AREA ===
            const screenStand1 = createScreenStand();
            screenStand1.position.set(-0.8, 0, 2.5);
            screenStand1.rotation.y = Math.PI;
            addFurniture(screenStand1, 'screen-stand-1');

            const screenStand2 = createScreenStand();
            screenStand2.position.set(0.8, 0, 2.5);
            screenStand2.rotation.y = Math.PI;
            addFurniture(screenStand2, 'screen-stand-2');

            const headphones1 = createHeadphoneStation();
            headphones1.position.set(-1.4, 0, 2.3);
            addFurniture(headphones1, 'headphone-station-1');

            const headphones2 = createHeadphoneStation();
            headphones2.position.set(1.4, 0, 2.3);
            addFurniture(headphones2, 'headphone-station-2');

            const viewStool1 = createSimpleStool();
            viewStool1.position.set(-0.8, 0, 1.8);
            addFurniture(viewStool1, 'stool-1');

            const viewStool2 = createSimpleStool();
            viewStool2.position.set(0.8, 0, 1.8);
            addFurniture(viewStool2, 'stool-2');

            // === AFRIKADAA POSTER WALL ===
            const posterA1 = createAfrikadaaPoster('AFRIKADAA', 0xd32f2f, 0.55, 0.75);
            posterA1.position.set(-ROOM_S203_WIDTH / 2 + 0.02, 1.7, -1.8);
            posterA1.rotation.y = Math.PI / 2;
            addFurniture(posterA1, 'poster-s203-1', true);

            const posterA2 = createAfrikadaaPoster('AFRICA', 0xfbc02d, 0.45, 0.6);
            posterA2.position.set(-ROOM_S203_WIDTH / 2 + 0.02, 1.5, -0.8);
            posterA2.rotation.y = Math.PI / 2;
            addFurniture(posterA2, 'poster-s203-2', true);

            const posterA3 = createAfrikadaaPoster('DIASPORA', 0x1976d2, 0.5, 0.65);
            posterA3.position.set(-ROOM_S203_WIDTH / 2 + 0.02, 1.75, 0.3);
            posterA3.rotation.y = Math.PI / 2;
            addFurniture(posterA3, 'poster-s203-3', true);

            const posterA4 = createAfrikadaaPoster('PANAFRICAN', 0x388e3c, 0.4, 0.55);
            posterA4.position.set(-ROOM_S203_WIDTH / 2 + 0.02, 1.45, 1.4);
            posterA4.rotation.y = Math.PI / 2;
            addFurniture(posterA4, 'poster-s203-4', true);

            const posterA5 = createAfrikadaaPoster('LIBRARY', 0x7b1fa2, 0.48, 0.68);
            posterA5.position.set(-ROOM_S203_WIDTH / 2 + 0.02, 1.65, 2.5);
            posterA5.rotation.y = Math.PI / 2;
            addFurniture(posterA5, 'poster-s203-5', true);

            // === MINIMAL LIGHTING ===
            const pendant1 = createSimplePendant();
            pendant1.position.set(0, CEILING_HEIGHT - 0.4, -0.5);
            addFurniture(pendant1, 'pendant-s203-1');

            const pendant2 = createSimplePendant();
            pendant2.position.set(0, CEILING_HEIGHT - 0.4, 2.0);
            addFurniture(pendant2, 'pendant-s203-2');

            return group;
        }

        // Create and position rooms
        const roomS202 = createRoomS202();
        roomS202.position.set(ROOM_S202_X, 0, 0);
        scene.add(roomS202);

        const roomS203 = createRoomS203();
        roomS203.position.set(ROOM_S203_X, 0, 0);
        scene.add(roomS203);

        // ============================================================
        // MAKE ALL DEFAULT FURNITURE EDITABLE
        // Items marked with userData.isFurniture are moved to scene root
        // and added to placedItems array for selection/editing
        // ============================================================
        function registerEditableFurniture() {
            function processRoom(roomGroup) {
                const furnitureToMove = [];

                // Find all direct children marked as furniture
                roomGroup.children.forEach(child => {
                    if (child.userData.isFurniture) {
                        furnitureToMove.push(child);
                    }
                });

                // Move furniture from room group to scene directly
                furnitureToMove.forEach(item => {
                    // Calculate world position
                    const worldPos = new THREE.Vector3();
                    item.getWorldPosition(worldPos);
                    const worldRot = item.rotation.clone();

                    // Remove from room group
                    roomGroup.remove(item);

                    // Add to scene directly with world position
                    item.position.copy(worldPos);
                    item.rotation.copy(worldRot);
                    item.userData.isPlacedItem = true;

                    scene.add(item);
                    placedItems.push(item);
                });
            }

            processRoom(roomS202);
            processRoom(roomS203);

            console.log('Registered', placedItems.length, 'editable furniture items');
        }

        // Register furniture after a short delay to ensure scene is ready
        setTimeout(registerEditableFurniture, 100);

        // Room labels
        function createLabel(text, position) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 128;
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 32px Helvetica';
            ctx.textAlign = 'center';
            ctx.fillText(text, canvas.width / 2, canvas.height / 2 + 10);
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(2.5, 0.6, 1);
            sprite.position.copy(position);
            return sprite;
        }

        labelsGroup.add(createLabel('ROOM S202 - SPECIAL SPECIAL', new THREE.Vector3(ROOM_S202_X, CEILING_HEIGHT + 0.5, 0)));
        labelsGroup.add(createLabel('ROOM S203 - READING ROOM', new THREE.Vector3(ROOM_S203_X, CEILING_HEIGHT + 0.5, 0)));
        scene.add(labelsGroup);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
        directionalLight.position.set(10, 15, 10);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
        fillLight.position.set(-10, 10, -10);
        scene.add(fillLight);
        const roomS202Light = new THREE.PointLight(0xffffee, 0.4, 12);
        roomS202Light.position.set(ROOM_S202_X, CEILING_HEIGHT - 0.5, 0);
        scene.add(roomS202Light);
        const roomS203Light = new THREE.PointLight(0xffffee, 0.4, 12);
        roomS203Light.position.set(ROOM_S203_X, CEILING_HEIGHT - 0.5, 0);
        scene.add(roomS203Light);

        // Camera controls
        let isMouseDown = false;
        let mouseX = 0, mouseY = 0;
        let targetRotationX = -Math.PI / 2, targetRotationY = 0.15;
        let currentRotationX = -Math.PI / 2, currentRotationY = 0.15;
        let cameraDistance = 3;
        // Default view: Inside S202, near east wall, looking at Afrikadaa posters on west wall
        let cameraTarget = new THREE.Vector3(ROOM_S202_X - 0.5, 1.5, 0);

        camera.position.set(ROOM_S202_X + 1.2, 1.6, 0);
        camera.lookAt(cameraTarget);

        container.addEventListener('mousedown', (e) => {
            if (!isCameraOrbitBlocked) {
                isMouseDown = true;
                mouseX = e.clientX;
                mouseY = e.clientY;
            }
        });
        container.addEventListener('mouseup', () => isMouseDown = false);
        container.addEventListener('mouseleave', () => isMouseDown = false);

        container.addEventListener('mousemove', (e) => {
            if (!isMouseDown || isCameraOrbitBlocked) return;
            targetRotationX += (e.clientX - mouseX) * 0.005;
            targetRotationY += (e.clientY - mouseY) * 0.005;
            targetRotationY = Math.max(-0.5, Math.min(1.2, targetRotationY));
            mouseX = e.clientX; mouseY = e.clientY;
        });

        container.addEventListener('wheel', (e) => {
            cameraDistance += e.deltaY * 0.01;
            cameraDistance = Math.max(3, Math.min(35, cameraDistance));
        });

        const keys = {};
        document.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
        document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

        // Touch controls
        container.addEventListener('touchstart', (e) => { isMouseDown = true; mouseX = e.touches[0].clientX; mouseY = e.touches[0].clientY; });
        container.addEventListener('touchend', () => isMouseDown = false);
        container.addEventListener('touchmove', (e) => {
            if (!isMouseDown) return;
            targetRotationX += (e.touches[0].clientX - mouseX) * 0.005;
            targetRotationY += (e.touches[0].clientY - mouseY) * 0.005;
            targetRotationY = Math.max(-0.5, Math.min(1.2, targetRotationY));
            mouseX = e.touches[0].clientX; mouseY = e.touches[0].clientY;
        });

        // View presets - CORRECTED FOR DOOR ENTRY PERSPECTIVE
        // Entry views: Camera at BACK (door, -Z) looking FORWARD toward windows (+Z)
        // rotX=0 means camera is at front looking back, rotX=Math.PI means camera at back looking forward
        const views = {
            overview: { rotX: 0, rotY: 0.5, dist: 18, target: new THREE.Vector3(0, 2, 0) },
            floorPlan: { rotX: 0, rotY: 1.5, dist: 14, target: new THREE.Vector3(0, 0, 0) },
            // Room S202 views - Entry through vestibule door, looking toward windows
            // rotX=Math.PI puts camera at -Z (door) looking toward +Z (windows)
            roomS202Entry: { rotX: Math.PI, rotY: 0.15, dist: 3, target: new THREE.Vector3(ROOM_S202_X, 1.5, -ROOM_S202_DEPTH / 2 + 1) },
            roomS202Inside: { rotX: Math.PI, rotY: 0.2, dist: 5, target: new THREE.Vector3(ROOM_S202_X, 1.5, 0) },
            roomS202Windows: { rotX: Math.PI, rotY: 0.15, dist: 4, target: new THREE.Vector3(ROOM_S202_X, 1.5, ROOM_S202_DEPTH / 4) },
            roomS202Table: { rotX: Math.PI * 0.8, rotY: 0.25, dist: 4, target: new THREE.Vector3(ROOM_S202_X, 0.8, 0) },
            // Room S203 views - Entry through corridor door, looking toward arched windows
            roomS203Entry: { rotX: Math.PI, rotY: 0.15, dist: 3, target: new THREE.Vector3(ROOM_S203_X, 1.5, -ROOM_S203_DEPTH / 2 + 1) },
            roomS203Inside: { rotX: Math.PI, rotY: 0.2, dist: 6, target: new THREE.Vector3(ROOM_S203_X, 1.5, 0) },
            roomS203Windows: { rotX: Math.PI, rotY: 0.15, dist: 4, target: new THREE.Vector3(ROOM_S203_X, 1.5, ROOM_S203_DEPTH / 4) },
            roomS203Seating: { rotX: Math.PI * 0.7, rotY: 0.2, dist: 4, target: new THREE.Vector3(ROOM_S203_X, 0.5, 0.5) },
            roomS203Shelves: { rotX: Math.PI * 1.2, rotY: 0.2, dist: 5, target: new THREE.Vector3(ROOM_S203_X, 1.2, -ROOM_S203_DEPTH / 3) }
        };

        function animateToView(view, duration = 1500) {
            const startRotX = currentRotationX, startRotY = currentRotationY;
            const startDist = cameraDistance;
            const startTarget = cameraTarget.clone();
            const startTime = Date.now();

            function update() {
                const elapsed = Date.now() - startTime;
                const t = Math.min(elapsed / duration, 1);
                const eased = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;

                targetRotationX = startRotX + (view.rotX - startRotX) * eased;
                targetRotationY = startRotY + (view.rotY - startRotY) * eased;
                cameraDistance = startDist + (view.dist - startDist) * eased;
                cameraTarget.lerpVectors(startTarget, view.target, eased);

                if (t < 1) requestAnimationFrame(update);
            }
            update();
        }

        window.setView = function(viewName) { const view = views[viewName]; if (view) animateToView(view); };
        window.focusRoom = function(room) {
            if (room === 'roomS202') setView('roomS202Inside');
            else if (room === 'roomS203') setView('roomS203Inside');
        };

        let tourRunning = false;
        window.startTour = function() {
            if (tourRunning) return;
            tourRunning = true;
            // Tour starts from entry doors, walking through each room
            const stops = ['overview', 'roomS202Entry', 'roomS202Inside', 'roomS202Windows', 'roomS202Table', 'roomS203Entry', 'roomS203Inside', 'roomS203Windows', 'roomS203Seating', 'roomS203Shelves', 'overview'];
            let i = 0;
            function next() {
                if (i >= stops.length) { tourRunning = false; return; }
                animateToView(views[stops[i++]], 2000);
                setTimeout(next, 3500);
            }
            next();
        };

        // Toggle functions
        let showGrid = true, showLabels = true, showCeiling = true, hideNearWall = false, showWireframe = false;

        window.toggleGrid = function() {
            showGrid = !showGrid;
            gridHelper.visible = showGrid;
            document.getElementById('gridBtn').classList.toggle('active', showGrid);
        };

        window.toggleLabels = function() {
            showLabels = !showLabels;
            labelsGroup.visible = showLabels;
            document.getElementById('labelsBtn').classList.toggle('active', showLabels);
        };

        window.toggleCeiling = function() {
            showCeiling = !showCeiling;
            // Find all ceilings in the scene
            scene.traverse((obj) => {
                if (obj.userData.isCeiling) obj.visible = showCeiling;
            });
            document.getElementById('ceilingBtn').classList.toggle('active', showCeiling);
        };

        window.toggleNearWall = function() {
            hideNearWall = !hideNearWall;
            document.getElementById('nearWallBtn').classList.toggle('active', hideNearWall);
        };

        window.toggleWireframe = function() {
            showWireframe = !showWireframe;
            document.getElementById('wireframeBtn').classList.toggle('active', showWireframe);
            scene.traverse((obj) => { if (obj.isMesh && obj.material) obj.material.wireframe = showWireframe; });
        };

        window.captureScreenshot = function() {
            const link = document.createElement('a');
            link.download = 'PanafricanLibrary_ReadingRoom.png';
            link.href = renderer.domElement.toDataURL('image/png');
            link.click();
        };

        window.toggleMoodboard = function() {
            const modal = document.getElementById('moodboard-modal');
            modal.classList.toggle('modal-hidden');
            if (!modal.classList.contains('modal-hidden')) {
                renderMoodboardGallery();
            }
        };

        // ============ MOOD BOARD MANAGEMENT ============
        let moodboardEditMode = false;
        let currentSlideIndex = 0;
        let currentFilter = 'all';
        let draggedImageIndex = null;

        // Default mood board images
        let moodboardImages = JSON.parse(localStorage.getItem('moodboardImages')) || [
            { src: 'photos refs reading room/Style mobilier/569a10d902522e95d504c7964c67310e.jpg', title: 'Ochre floor mattress with cushions', category: 'furniture' },
            { src: 'photos refs reading room/ambiance/352102ea74fd486ae6c0906204724e6d.jpg', title: 'Layered rugs, disco balls, wooden chairs', category: 'ambiance' },
            { src: 'photos refs reading room/Style mobilier/-natte-plastique-thies.jpg', title: 'Senegalese plastic woven mats (nattes)', category: 'furniture' },
            { src: 'photos refs reading room/inspiration afrique/The-Library-of-Muyinga-by-BC-architects_dezeen_8.jpg', title: 'Library of Muyinga - wooden platforms', category: 'inspiration' },
            { src: 'photos refs reading room/ambiance/_M5C0020.jpg', title: 'Colorful bean bags and poufs', category: 'ambiance' },
            { src: 'photos refs reading room/Style mobilier/tissu-wax.webp', title: 'African wax print fabric', category: 'pattern' }
        ];

        function saveMoodboardImages() {
            localStorage.setItem('moodboardImages', JSON.stringify(moodboardImages));
        }

        function getFilteredImages() {
            if (currentFilter === 'all') return moodboardImages;
            return moodboardImages.filter(img => img.category === currentFilter);
        }

        function renderMoodboardGallery() {
            const gallery = document.getElementById('moodboard-gallery');
            const countEl = document.getElementById('image-count');
            const filtered = getFilteredImages();

            countEl.textContent = `(${filtered.length} images)`;

            gallery.innerHTML = filtered.map((img, idx) => `
                <div class="moodboard-image-item ${moodboardEditMode ? 'editing' : ''}"
                     data-index="${moodboardImages.indexOf(img)}"
                     onclick="openSlideshow(${moodboardImages.indexOf(img)})"
                     draggable="${moodboardEditMode}">
                    <img src="${img.src}" alt="${img.title}" onerror="this.parentElement.style.display='none'">
                    <div class="image-overlay">
                        <div class="image-title">${img.title}</div>
                    </div>
                    <div class="image-actions">
                        <button class="image-action-btn move" title="Drag to reorder" onclick="event.stopPropagation()">â‹®â‹®</button>
                        <button class="image-action-btn delete" title="Remove" onclick="event.stopPropagation(); removeMoodboardImage(${moodboardImages.indexOf(img)})">âœ•</button>
                    </div>
                </div>
            `).join('');

            // Add drag-drop for reordering
            if (moodboardEditMode) {
                setupDragDrop();
            }
        }

        function setupDragDrop() {
            const items = document.querySelectorAll('.moodboard-image-item');
            items.forEach(item => {
                item.addEventListener('dragstart', (e) => {
                    draggedImageIndex = parseInt(item.dataset.index);
                    e.dataTransfer.effectAllowed = 'move';
                    item.style.opacity = '0.5';
                });
                item.addEventListener('dragend', () => {
                    item.style.opacity = '1';
                    draggedImageIndex = null;
                });
                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                });
                item.addEventListener('drop', (e) => {
                    e.preventDefault();
                    const targetIndex = parseInt(item.dataset.index);
                    if (draggedImageIndex !== null && draggedImageIndex !== targetIndex) {
                        reorderMoodboardImage(draggedImageIndex, targetIndex);
                    }
                });
            });
        }

        window.toggleMoodboardEdit = function() {
            moodboardEditMode = !moodboardEditMode;
            document.getElementById('edit-mode-btn').classList.toggle('active', moodboardEditMode);
            renderMoodboardGallery();
        };

        window.toggleAddImageForm = function() {
            const form = document.getElementById('add-image-form');
            form.classList.toggle('active');
            document.getElementById('add-image-btn').classList.toggle('active', form.classList.contains('active'));
        };

        window.filterMoodboard = function(filter) {
            currentFilter = filter;
            document.querySelectorAll('[data-filter]').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.filter === filter);
            });
            renderMoodboardGallery();
        };

        window.addMoodboardImage = function() {
            const urlInput = document.getElementById('new-image-url');
            const titleInput = document.getElementById('new-image-title');
            const categorySelect = document.getElementById('new-image-category');
            const dropZone = document.getElementById('drop-zone');

            const src = urlInput.value.trim() || dropZone.dataset.imageSrc;
            const title = titleInput.value.trim() || 'Untitled';
            const category = categorySelect.value;

            if (!src) {
                alert('Please provide an image URL or upload a file');
                return;
            }

            moodboardImages.push({ src, title, category });
            saveMoodboardImages();

            // Reset form
            urlInput.value = '';
            titleInput.value = '';
            dropZone.classList.remove('has-file');
            dropZone.innerHTML = 'ğŸ“· Drag & drop image here or click to browse';
            delete dropZone.dataset.imageSrc;
            toggleAddImageForm();

            renderMoodboardGallery();
        };

        window.removeMoodboardImage = function(index) {
            if (confirm('Remove this image from the mood board?')) {
                moodboardImages.splice(index, 1);
                saveMoodboardImages();
                renderMoodboardGallery();
            }
        };

        function reorderMoodboardImage(fromIndex, toIndex) {
            const item = moodboardImages.splice(fromIndex, 1)[0];
            moodboardImages.splice(toIndex, 0, item);
            saveMoodboardImages();
            renderMoodboardGallery();
        }

        // Image upload handling - with IndexedDB persistence
        window.handleImageSelect = async function(event) {
            const file = event.target.files[0];
            if (file) {
                const dropZone = document.getElementById('drop-zone');
                dropZone.innerHTML = 'â³ Processing...';

                try {
                    // Use enhanced handler that saves to IndexedDB
                    const dataUrl = await handleMoodboardImageUpload(file);
                    if (dataUrl) {
                        dropZone.dataset.imageSrc = dataUrl;
                        dropZone.dataset.fileName = file.name;
                        dropZone.classList.add('has-file');
                        dropZone.innerHTML = `âœ“ ${file.name}`;
                    }
                } catch (err) {
                    console.error('Image upload error:', err);
                    // Fallback to simple FileReader
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        dropZone.dataset.imageSrc = e.target.result;
                        dropZone.dataset.fileName = file.name;
                        dropZone.classList.add('has-file');
                        dropZone.innerHTML = `âœ“ ${file.name}`;
                    };
                    reader.readAsDataURL(file);
                }
            }
        };

        // Drop zone setup
        document.addEventListener('DOMContentLoaded', () => {
            const dropZone = document.getElementById('drop-zone');
            if (dropZone) {
                dropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    dropZone.classList.add('dragover');
                });
                dropZone.addEventListener('dragleave', () => {
                    dropZone.classList.remove('dragover');
                });
                dropZone.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    dropZone.classList.remove('dragover');
                    const file = e.dataTransfer.files[0];
                    if (file && file.type.startsWith('image/')) {
                        dropZone.innerHTML = 'â³ Processing...';
                        try {
                            const dataUrl = await handleMoodboardImageUpload(file);
                            if (dataUrl) {
                                dropZone.dataset.imageSrc = dataUrl;
                                dropZone.dataset.fileName = file.name;
                                dropZone.classList.add('has-file');
                                dropZone.innerHTML = `âœ“ ${file.name}`;
                            }
                        } catch (err) {
                            // Fallback
                            const reader = new FileReader();
                            reader.onload = (ev) => {
                                dropZone.dataset.imageSrc = ev.target.result;
                                dropZone.dataset.fileName = file.name;
                                dropZone.classList.add('has-file');
                                dropZone.innerHTML = `âœ“ ${file.name}`;
                            };
                            reader.readAsDataURL(file);
                        }
                    }
                });
            }
        });

        // ============ SLIDESHOW ============
        window.openSlideshow = function(index) {
            if (moodboardEditMode) return; // Don't open slideshow in edit mode
            currentSlideIndex = index;
            updateSlideshow();
            document.getElementById('slideshow-modal').classList.add('active');
        };

        window.closeSlideshow = function() {
            document.getElementById('slideshow-modal').classList.remove('active');
        };

        window.slideshowNav = function(direction) {
            currentSlideIndex += direction;
            if (currentSlideIndex < 0) currentSlideIndex = moodboardImages.length - 1;
            if (currentSlideIndex >= moodboardImages.length) currentSlideIndex = 0;
            updateSlideshow();
        };

        function updateSlideshow() {
            const img = moodboardImages[currentSlideIndex];
            document.getElementById('slideshow-image').src = img.src;
            document.getElementById('slideshow-caption').textContent = img.title;
            document.getElementById('slideshow-info').textContent = `${currentSlideIndex + 1} / ${moodboardImages.length}`;
        }

        // Keyboard navigation for slideshow
        document.addEventListener('keydown', (e) => {
            if (document.getElementById('slideshow-modal').classList.contains('active')) {
                if (e.key === 'ArrowLeft') slideshowNav(-1);
                if (e.key === 'ArrowRight') slideshowNav(1);
                if (e.key === 'Escape') closeSlideshow();
            }
        });

        // ============ DECORATOR MODE ============
        let decoratorMode = false;
        let selectedFurnitureType = null;
        let selectedPlacedItem = null;
        let placedItems = [];
        let isDraggingItem = false;
        let draggedLibraryItem = null;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.toggleDecorator = function() {
            const panel = document.getElementById('decorator-panel');
            panel.classList.toggle('open');
            decoratorMode = panel.classList.contains('open');
            if (!decoratorMode) {
                deselectAll();
            } else {
                // Setup drag-drop for library items when decorator opens
                setupLibraryDragDrop();
            }
        };

        // Setup drag-drop for all library item cards
        function setupLibraryDragDrop() {
            document.querySelectorAll('.item-card').forEach(card => {
                if (card.dataset.dragSetup) return; // Already setup
                card.dataset.dragSetup = 'true';
                card.draggable = true;

                card.addEventListener('dragstart', (e) => {
                    const type = card.onclick?.toString().match(/selectFurniture\('([^']+)'\)/)?.[1];
                    if (type) {
                        draggedLibraryItem = type;
                        e.dataTransfer.setData('text/plain', type);
                        e.dataTransfer.effectAllowed = 'copy';
                        card.classList.add('dragging');
                    }
                });

                card.addEventListener('dragend', () => {
                    card.classList.remove('dragging');
                    draggedLibraryItem = null;
                });
            });
        }

        // Canvas drop zone for library items and 3D files from Finder
        function setupCanvasDragDrop() {
            const canvas = document.getElementById('canvas-container');

            canvas.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
                canvas.classList.add('drag-over');
            });

            canvas.addEventListener('dragleave', (e) => {
                // Only remove if leaving the container entirely
                if (!canvas.contains(e.relatedTarget)) {
                    canvas.classList.remove('drag-over');
                }
            });

            canvas.addEventListener('drop', async (e) => {
                e.preventDefault();
                canvas.classList.remove('drag-over');

                const rect = canvas.getBoundingClientRect();
                const dropX = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                const dropY = -((e.clientY - rect.top) / rect.height) * 2 + 1;

                // Check for 3D file from Finder
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    const file = files[0];
                    const ext = file.name.split('.').pop().toLowerCase();
                    if (['glb', 'gltf', 'obj'].includes(ext)) {
                        await handleDropped3DFile(file, dropX, dropY);
                        return;
                    }
                }

                // Check for library item
                const furnitureType = e.dataTransfer.getData('text/plain');
                if (furnitureType) {
                    placeItemAtScreenPos(furnitureType, dropX, dropY);
                }
            });
        }

        // Handle 3D file dropped from Finder
        async function handleDropped3DFile(file, screenX, screenY) {
            const ext = file.name.split('.').pop().toLowerCase();
            const name = file.name.replace(/\.[^.]+$/, '');

            initLoaders();

            try {
                const arrayBuffer = await file.arrayBuffer();
                const blob = new Blob([arrayBuffer]);
                const url = URL.createObjectURL(blob);

                let object = null;

                if (ext === 'glb' || ext === 'gltf') {
                    if (!gltfLoader) {
                        alert('GLTF loader not available');
                        return;
                    }
                    object = await new Promise((resolve, reject) => {
                        gltfLoader.load(url, (gltf) => resolve(gltf.scene), undefined, reject);
                    });
                } else if (ext === 'obj') {
                    if (!objLoader) {
                        alert('OBJ loader not available');
                        return;
                    }
                    object = await new Promise((resolve, reject) => {
                        objLoader.load(url, resolve, undefined, reject);
                    });
                }

                URL.revokeObjectURL(url);

                if (object) {
                    // Auto-scale to reasonable size
                    const box = new THREE.Box3().setFromObject(object);
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    if (maxDim > 2) {
                        object.scale.multiplyScalar(1.5 / maxDim);
                    } else if (maxDim < 0.1) {
                        object.scale.multiplyScalar(0.5 / maxDim);
                    }

                    // Recalculate bounds after scaling
                    const newBox = new THREE.Box3().setFromObject(object);
                    object.position.y = -newBox.min.y; // Sit on floor

                    // Wrap in group for consistent handling
                    const group = new THREE.Group();
                    group.add(object);
                    group.userData.itemType = 'custom-' + name;
                    group.userData.isPlacedItem = true;

                    // Place at drop position
                    placeObjectAtScreenPos(group, screenX, screenY);
                }
            } catch (err) {
                console.error('Error loading dropped 3D file:', err);
                alert('Failed to load 3D file: ' + err.message);
            }
        }

        // Place furniture item at screen position
        function placeItemAtScreenPos(type, screenX, screenY) {
            const item = createFurnitureItem(type);
            placeObjectAtScreenPos(item, screenX, screenY);
        }

        // Place any object at screen position
        function placeObjectAtScreenPos(item, screenX, screenY) {
            mouse.x = screenX;
            mouse.y = screenY;
            raycaster.setFromCamera(mouse, camera);

            const floorPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const intersectPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(floorPlane, intersectPoint);

            if (intersectPoint) {
                intersectPoint.y = 0;
                const constrainedPos = constrainToRoom(intersectPoint);
                if (constrainedPos) {
                    item.position.copy(constrainedPos);
                    if (item.userData.isWallArt) {
                        item.position.y = 1.5;
                    }
                    scene.add(item);
                    placedItems.push(item);

                    // Select the newly placed item
                    selectedPlacedItem = item;
                    selectedFurnitureType = null;
                    document.querySelectorAll('.item-card').forEach(c => c.classList.remove('selected'));
                    updateSelectedInfo();
                } else {
                    console.log('Cannot place item outside room boundaries');
                }
            }
        }

        window.toggleCategory = function(catId) {
            document.getElementById(catId).classList.toggle('collapsed');
        };

        window.selectFurniture = function(type) {
            // Deselect previous
            document.querySelectorAll('.item-card').forEach(c => c.classList.remove('selected'));
            // Select new
            event.currentTarget.classList.add('selected');
            selectedFurnitureType = type;
            selectedPlacedItem = null;
            updateSelectedInfo();
        };

        function deselectAll() {
            document.querySelectorAll('.item-card').forEach(c => c.classList.remove('selected'));
            selectedFurnitureType = null;
            selectedPlacedItem = null;
            updateSelectedInfo();
        }

        function updateSelectedInfo() {
            const info = document.getElementById('selected-item-info');
            const nameSpan = document.getElementById('selected-name');
            if (selectedPlacedItem) {
                info.classList.add('visible');
                nameSpan.textContent = selectedPlacedItem.userData.itemType || 'Item';
                // Attach transform controls gizmo
                if (transformControls) {
                    transformControls.attach(selectedPlacedItem);
                }
            } else if (selectedFurnitureType) {
                info.classList.add('visible');
                nameSpan.textContent = selectedFurnitureType + ' (click to place)';
                // Detach transform controls
                if (transformControls) {
                    transformControls.detach();
                }
            } else {
                info.classList.remove('visible');
                // Detach transform controls
                if (transformControls) {
                    transformControls.detach();
                }
            }
        }

        // Create furniture based on type
        function createFurnitureItem(type) {
            let item;
            switch(type) {
                // Bean Bags - large triangular
                case 'beanbag-cream': item = createTriangleBeanbag(0xf5f0e8); break;
                case 'beanbag-orange': item = createTriangleBeanbag(0xfd7e14); break;
                case 'beanbag-magenta': item = createTriangleBeanbag(0xc2185b); break;
                case 'beanbag-teal': item = createTriangleBeanbag(0x26a69a); break;
                // Ethnic cushions
                case 'cushion-ethnic-orange': item = createEthnicCushion(0xfd7e14, 0xc96000); break;
                case 'cushion-ethnic-burgundy': item = createEthnicCushion(0x8b2942, 0x5a1a2a); break;
                case 'cushion-velvet-teal': item = createFloorCushion(0x00897b, 0.55); break;
                case 'cushion-round-green': item = createFloorCushion(0x7cb342, 0.45); break;
                case 'cushion-pebble-gray': item = createPebbleCushion(0x90a4ae); break;
                // Mattress & Seating
                case 'mattress-ochre': item = createTuftedFloorMattress(2.2, 1.4); break;
                case 'sofa-olive': item = createVelvetSofa(0x827717); break;
                case 'armchair-pink': item = createVintageArmchair(0xe91e63); break;
                // Tables
                case 'table-display': item = createDisplayTable(); break;
                case 'table-coffee': item = createLowCoffeeTable(); break;
                case 'table-side': item = createSideTable(); break;
                case 'bench-wood': item = createWoodenBench(); break;
                // Book Displays & Storage
                case 'bookcase-wall': item = createWallBookcase(); break;
                case 'book-cubby': item = createBookCubby(); break;
                case 'magazine-rack': item = createMagazineRack(); break;
                case 'book-stack': item = createBookStack(); break;
                case 'display-pink': item = createColorDisplay(0xf8bbd0); break;
                case 'shelf-leaning': item = createLeaningShelf(); break;
                // Rugs - Layered Persian & African
                case 'rug-persian-red': item = createLayeredRug(3.5, 2.5, 0xb71c1c); break;
                case 'rug-persian-cream': item = createLayeredRug(3.0, 2.2, 0xefebe9); break;
                case 'rug-natte-african': item = createAfricanNatte(); break;
                case 'rug-checkered-pink': item = createCheckeredRug(0xe91e63, 0xf8bbd0); break;
                case 'rug-checkered-teal': item = createCheckeredRug(0x00897b, 0xb2dfdb); break;
                case 'rug-wax-yellow': item = createWaxPrintRug(0xfdd835, 0xc41e3a); break;
                case 'rug-geometric-bw': item = createGeometricRug(); break;
                case 'tablecloth-tiedye': item = createTieDyeCloth(); break;
                // Lighting - Ethiopian & Disco
                case 'lamp-ethiopian': item = createEthiopianLamp(); break;
                case 'lamp-beaded': item = createBeadedLamp(); break;
                case 'disco-ball': item = createDiscoBall(); break;
                case 'disco-ball-cluster': item = createDiscoBallCluster(); break;
                case 'light-string': item = createStringLights(); break;
                case 'lantern-paper': item = createPaperLantern(); break;
                // Plants & African Decor
                case 'plant-palm': item = createPalmPlant(); break;
                case 'plant-hanging': item = createHangingPlant(); break;
                case 'plant-pothos': item = createPothosVine(); break;
                case 'basket-woven': item = createWovenBasket(); break;
                case 'pottery-african': item = createAfricanPottery(); break;
                case 'sculpture-wood': item = createWoodSculpture(); break;
                // Wall art
                case 'poster-afrikadaa-1': item = createWallPoster(0xff6b6b, 0.6, 0.8, 'Afrikadaa #1'); break;
                case 'poster-afrikadaa-2': item = createWallPoster(0x45b7d1, 0.5, 0.7, 'Afrikadaa #2'); break;
                case 'poster-afrikadaa-3': item = createWallPoster(0xe17055, 0.5, 0.65, 'African Art'); break;
                case 'poster-coolhunt-1': item = createWallPoster(0x1a1a1a, 0.5, 0.7, 'Fashion'); break;
                case 'poster-coolhunt-2': item = createWallPoster(0xc41e3a, 0.6, 0.8, 'Street Art'); break;
                case 'poster-coolhunt-3': item = createWallPoster(0x74b9ff, 0.4, 0.5, 'Design'); break;
                case 'poster-activist-1': item = createTextBanner('WE WANT TO LIVE FREE', 0x1a3a5c); break;
                case 'poster-activist-2': item = createTextBanner('SOMOS PERSONAS', 0xf5f0e8, 0x1a1a1a); break;
                case 'poster-activist-3': item = createWallPoster(0xc41e3a, 0.7, 0.9, 'Resistance'); break;
                default:
                    // Check if it's a custom model
                    if (type && type.startsWith('custom-model-')) {
                        const modelId = parseInt(type.replace('custom-model-', ''));
                        // Return a placeholder - actual model loading happens async
                        item = createCustomModelPlaceholder(modelId);
                    } else {
                        item = createFloorCushion(0x888888, 0.5);
                    }
            }
            item.userData.itemType = type;
            item.userData.isPlacedItem = true;
            return item;
        }

        // Placeholder for custom models while loading
        function createCustomModelPlaceholder(modelId) {
            const group = new THREE.Group();
            const geo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const mat = new THREE.MeshLambertMaterial({
                color: 0x4a90d9,
                transparent: true,
                opacity: 0.5
            });
            const box = new THREE.Mesh(geo, mat);
            box.position.y = 0.25;
            group.add(box);

            // Add loading indicator
            const edges = new THREE.EdgesGeometry(geo);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xffffff }));
            line.position.y = 0.25;
            group.add(line);

            group.userData.isPlaceholder = true;
            group.userData.customModelId = modelId;

            // Async load the actual model and replace placeholder
            loadAndReplaceCustomModel(group, modelId);

            return group;
        }

        // Load custom model and replace placeholder
        async function loadAndReplaceCustomModel(placeholder, modelId) {
            const model = uploadedModels.find(m => m.id === modelId);
            if (!model) return;

            initLoaders();

            try {
                const blob = new Blob([model.data]);
                const url = URL.createObjectURL(blob);

                let object = null;

                if (model.type === 'glb' || model.type === 'gltf') {
                    if (!gltfLoader) return;
                    object = await new Promise((resolve, reject) => {
                        gltfLoader.load(url, (gltf) => resolve(gltf.scene), undefined, reject);
                    });
                } else if (model.type === 'obj') {
                    if (!objLoader) return;
                    object = await new Promise((resolve, reject) => {
                        objLoader.load(url, resolve, undefined, reject);
                    });
                }

                URL.revokeObjectURL(url);

                if (object) {
                    // Auto-scale
                    const box = new THREE.Box3().setFromObject(object);
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    if (maxDim > 2) {
                        object.scale.multiplyScalar(1.5 / maxDim);
                    }

                    // Center
                    const newBox = new THREE.Box3().setFromObject(object);
                    object.position.y = -newBox.min.y;

                    // Clear placeholder contents
                    while (placeholder.children.length > 0) {
                        placeholder.remove(placeholder.children[0]);
                    }

                    // Add loaded model to placeholder group
                    placeholder.add(object);
                    placeholder.userData.isPlaceholder = false;
                    placeholder.userData.customModelName = model.name;
                }
            } catch (err) {
                console.error('Error loading custom model:', err);
            }
        }

        // Additional furniture creation functions
        function createBeanbag(color) {
            const group = new THREE.Group();
            const bean = new THREE.Mesh(
                new THREE.SphereGeometry(0.45, 16, 16),
                new THREE.MeshLambertMaterial({ color })
            );
            bean.scale.set(1.2, 0.7, 1);
            bean.position.set(0, 0.3, 0);
            group.add(bean);
            return group;
        }

        function createLowSofa() {
            const group = new THREE.Group();
            const mat = new THREE.MeshLambertMaterial({ color: 0x6c757d });
            const seat = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.3, 0.8), mat);
            seat.position.set(0, 0.25, 0);
            group.add(seat);
            const back = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.4, 0.15), mat);
            back.position.set(0, 0.5, -0.35);
            group.add(back);
            const armL = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.35, 0.8), mat);
            armL.position.set(-0.85, 0.35, 0);
            group.add(armL);
            const armR = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.35, 0.8), mat);
            armR.position.set(0.85, 0.35, 0);
            group.add(armR);
            return group;
        }

        function createDisplayTable() {
            const group = new THREE.Group();
            const tableMat = new THREE.MeshLambertMaterial({ color: 0xd4a76a });
            const top = new THREE.Mesh(new THREE.BoxGeometry(2, 0.04, 0.8), tableMat);
            top.position.set(0, 0.72, 0);
            group.add(top);
            const legs = [[0.9, 0.3], [0.9, -0.3], [-0.9, 0.3], [-0.9, -0.3]];
            legs.forEach(([x, z]) => {
                const leg = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.7, 0.05), tableMat);
                leg.position.set(x, 0.35, z);
                group.add(leg);
            });
            return group;
        }

        function createSideTable() {
            const group = new THREE.Group();
            const mat = new THREE.MeshLambertMaterial({ color: 0xffd93d });
            const top = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.25, 0.03, 16), mat);
            top.position.set(0, 0.45, 0);
            group.add(top);
            const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.04, 0.43, 8), mat);
            leg.position.set(0, 0.22, 0);
            group.add(leg);
            return group;
        }

        function createWoodenBench() {
            const group = new THREE.Group();
            const mat = new THREE.MeshLambertMaterial({ color: 0xd4a76a });
            const seat = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.05, 0.4), mat);
            seat.position.set(0, 0.45, 0);
            group.add(seat);
            const legs = [[0.65, 0.1], [0.65, -0.1], [-0.65, 0.1], [-0.65, -0.1]];
            legs.forEach(([x, z]) => {
                const leg = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.43, 0.05), mat);
                leg.position.set(x, 0.22, z);
                group.add(leg);
            });
            return group;
        }

        function createFoldingScreen() {
            const group = new THREE.Group();
            const mat = new THREE.MeshLambertMaterial({ color: 0xd4a76a, side: THREE.DoubleSide });
            for (let i = -1; i <= 1; i++) {
                const panel = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.8, 0.02), mat);
                panel.position.set(i * 0.5, 0.9, i * 0.1);
                panel.rotation.y = i * 0.3;
                group.add(panel);
            }
            return group;
        }

        function createWireRack() {
            const group = new THREE.Group();
            const mat = new THREE.MeshLambertMaterial({ color: 0x888888 });
            for (let y = 0; y < 4; y++) {
                const shelf = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.02, 0.3), mat);
                shelf.position.set(0, 0.3 + y * 0.3, 0);
                group.add(shelf);
            }
            const legs = [[0.18, 0.13], [0.18, -0.13], [-0.18, 0.13], [-0.18, -0.13]];
            legs.forEach(([x, z]) => {
                const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 1.2, 8), mat);
                leg.position.set(x, 0.6, z);
                group.add(leg);
            });
            return group;
        }

        function createStripedRug() {
            const group = new THREE.Group();
            const colors = [0xc9a227, 0x8b6914, 0xc9a227, 0x8b6914, 0xc9a227];
            const stripeWidth = 0.6;
            colors.forEach((color, i) => {
                const stripe = new THREE.Mesh(
                    new THREE.BoxGeometry(stripeWidth, 0.02, 2.5),
                    new THREE.MeshLambertMaterial({ color })
                );
                stripe.position.set((i - 2) * stripeWidth, 0.01, 0);
                group.add(stripe);
            });
            return group;
        }

        function createTablecloth(color) {
            const group = new THREE.Group();
            const cloth = new THREE.Mesh(
                new THREE.BoxGeometry(2.1, 0.02, 0.9),
                new THREE.MeshLambertMaterial({ color })
            );
            cloth.position.set(0, 0.74, 0);
            group.add(cloth);
            return group;
        }

        function createFloorLamp() {
            const group = new THREE.Group();
            const mat = new THREE.MeshLambertMaterial({ color: 0xf5f5f5 });
            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.18, 0.03, 16), mat);
            base.position.set(0, 0.015, 0);
            group.add(base);
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 1.5, 8), mat);
            pole.position.set(0, 0.78, 0);
            group.add(pole);
            const shade = new THREE.Mesh(
                new THREE.ConeGeometry(0.2, 0.25, 16, 1, true),
                new THREE.MeshLambertMaterial({ color: 0xf5f5dc, side: THREE.DoubleSide })
            );
            shade.position.set(0, 1.6, 0);
            shade.rotation.x = Math.PI;
            group.add(shade);
            return group;
        }

        function createDiscoBall() {
            const group = new THREE.Group();
            const ball = new THREE.Mesh(
                new THREE.SphereGeometry(0.15, 16, 16),
                new THREE.MeshLambertMaterial({ color: 0xc0c0c0 })
            );
            ball.position.set(0, 0, 0);
            group.add(ball);
            const cord = new THREE.Mesh(
                new THREE.CylinderGeometry(0.01, 0.01, 0.5, 8),
                new THREE.MeshLambertMaterial({ color: 0x333333 })
            );
            cord.position.set(0, 0.25, 0);
            group.add(cord);
            return group;
        }

        function createSmallPlant() {
            const group = new THREE.Group();
            const pot = new THREE.Mesh(
                new THREE.CylinderGeometry(0.08, 0.06, 0.12, 12),
                new THREE.MeshLambertMaterial({ color: 0x8b4513 })
            );
            pot.position.set(0, 0.06, 0);
            group.add(pot);
            const plant = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 8, 8),
                new THREE.MeshLambertMaterial({ color: 0x32cd32 })
            );
            plant.position.set(0, 0.18, 0);
            group.add(plant);
            return group;
        }

        function createVase() {
            const group = new THREE.Group();
            const vase = new THREE.Mesh(
                new THREE.CylinderGeometry(0.08, 0.12, 0.25, 12),
                new THREE.MeshLambertMaterial({ color: 0x4169e1 })
            );
            vase.position.set(0, 0.125, 0);
            group.add(vase);
            const flowers = new THREE.Mesh(
                new THREE.SphereGeometry(0.12, 8, 8),
                new THREE.MeshLambertMaterial({ color: 0xff69b4 })
            );
            flowers.position.set(0, 0.35, 0);
            group.add(flowers);
            return group;
        }

        function createWallPoster(color, width, height, text) {
            const group = new THREE.Group();
            const poster = new THREE.Mesh(
                new THREE.BoxGeometry(width, height, 0.02),
                new THREE.MeshLambertMaterial({ color })
            );
            poster.position.set(0, height/2, 0);
            group.add(poster);
            // Frame
            const frameMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
            const frameT = new THREE.Mesh(new THREE.BoxGeometry(width + 0.04, 0.02, 0.03), frameMat);
            frameT.position.set(0, height + 0.01, 0.01);
            group.add(frameT);
            const frameB = new THREE.Mesh(new THREE.BoxGeometry(width + 0.04, 0.02, 0.03), frameMat);
            frameB.position.set(0, -0.01, 0.01);
            group.add(frameB);
            const frameL = new THREE.Mesh(new THREE.BoxGeometry(0.02, height + 0.04, 0.03), frameMat);
            frameL.position.set(-width/2 - 0.01, height/2, 0.01);
            group.add(frameL);
            const frameR = new THREE.Mesh(new THREE.BoxGeometry(0.02, height + 0.04, 0.03), frameMat);
            frameR.position.set(width/2 + 0.01, height/2, 0.01);
            group.add(frameR);
            group.userData.isWallArt = true;
            return group;
        }

        function createTextBanner(text, bgColor, textColor = 0xffffff) {
            const group = new THREE.Group();
            const banner = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 1.0, 0.02),
                new THREE.MeshLambertMaterial({ color: bgColor })
            );
            banner.position.set(0, 0.5, 0);
            group.add(banner);
            group.userData.isWallArt = true;
            group.userData.bannerText = text;
            return group;
        }

        // ==========================================
        // PANAFRICAN-INSPIRED FURNITURE FUNCTIONS
        // Based on reference images from the mood board
        // ==========================================

        // TRIANGLE BEAN BAGS - Large triangular floor cushions
        function createTriangleBeanbag(color) {
            const group = new THREE.Group();
            // Large triangular floor cushion/beanbag - FLAT on the floor
            // Using a flattened cylinder (like a thick triangular cushion)
            const height = 0.2;  // Low to the ground
            const radius = 0.55;
            const geometry = new THREE.CylinderGeometry(radius * 0.3, radius, height, 3);
            const material = new THREE.MeshLambertMaterial({ color });
            const bean = new THREE.Mesh(geometry, material);
            bean.rotation.y = Math.PI / 6;  // Rotate for visual interest
            bean.position.set(0, height / 2, 0);  // Sits flat on floor (y=0)
            group.add(bean);
            return group;
        }

        // ETHNIC/VELVET CUSHIONS - Colorful floor cushions
        function createEthnicCushion(colors) {
            const group = new THREE.Group();
            const cushion = new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 0.15, 0.5),
                new THREE.MeshLambertMaterial({ color: colors[0] })
            );
            cushion.position.set(0, 0.08, 0);
            group.add(cushion);
            // Add pattern stripe
            const stripe = new THREE.Mesh(
                new THREE.BoxGeometry(0.52, 0.02, 0.1),
                new THREE.MeshLambertMaterial({ color: colors[1] || 0xffd700 })
            );
            stripe.position.set(0, 0.16, 0);
            group.add(stripe);
            return group;
        }

        function createVelvetCushion(color) {
            const group = new THREE.Group();
            const cushion = new THREE.Mesh(
                new THREE.BoxGeometry(0.45, 0.12, 0.45),
                new THREE.MeshLambertMaterial({ color })
            );
            cushion.position.set(0, 0.06, 0);
            group.add(cushion);
            // Tufted center button
            const button = new THREE.Mesh(
                new THREE.CylinderGeometry(0.03, 0.03, 0.02, 8),
                new THREE.MeshLambertMaterial({ color: 0x333333 })
            );
            button.position.set(0, 0.13, 0);
            group.add(button);
            return group;
        }

        function createPebbleCushion(color) {
            const group = new THREE.Group();
            const cushion = new THREE.Mesh(
                new THREE.SphereGeometry(0.25, 12, 12),
                new THREE.MeshLambertMaterial({ color })
            );
            cushion.scale.set(1, 0.4, 1);
            cushion.position.set(0, 0.1, 0);
            group.add(cushion);
            return group;
        }

        // ========== EXHIBITION FURNITURE (Curatorial) ==========
        // These are appropriate for a 3-day public exhibition context
        // NOT domestic/lounge furniture

        // SIMPLE POUF - Low, robust seating for collective use
        function createSimplePouf(color) {
            const group = new THREE.Group();
            const mat = new THREE.MeshLambertMaterial({ color });
            const pouf = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.28, 0.35, 16), mat);
            pouf.position.set(0, 0.175, 0);
            group.add(pouf);
            return group;
        }

        // AUDIO STATION - DJ/Radio terminal
        function createAudioStation() {
            const group = new THREE.Group();
            const woodMat = new THREE.MeshLambertMaterial({ color: 0x8b7355 });
            const metalMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
            // Table
            const table = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.05, 0.6), woodMat);
            table.position.set(0, 0.75, 0);
            group.add(table);
            // Legs
            for (let x of [-0.55, 0.55]) {
                for (let z of [-0.25, 0.25]) {
                    const leg = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.75, 0.04), metalMat);
                    leg.position.set(x, 0.375, z);
                    group.add(leg);
                }
            }
            // Equipment (mixer/laptop placeholder)
            const equipment = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.08, 0.3), metalMat);
            equipment.position.set(0, 0.82, 0);
            group.add(equipment);
            return group;
        }

        // FLOOR SPEAKER - Exhibition audio
        function createFloorSpeaker() {
            // Speaker on stand - cabinet sits DIRECTLY on stand top plate
            const group = new THREE.Group();
            const mat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
            const metalMat = new THREE.MeshLambertMaterial({ color: 0x333333 });

            // Speaker Stand
            const standHeight = 0.75;  // Stand pole height
            const topPlateY = standHeight + 0.02;  // Top of stand
            const cabinetHeight = 0.4;  // Speaker cabinet height
            const cabinetY = topPlateY + cabinetHeight / 2 + 0.01;  // Cabinet center (sits on top plate)

            // Base plate (on floor)
            const basePlate = new THREE.Mesh(new THREE.BoxGeometry(0.32, 0.02, 0.32), metalMat);
            basePlate.position.set(0, 0.01, 0);
            group.add(basePlate);

            // Center pole
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.022, 0.022, standHeight, 8), metalMat);
            pole.position.set(0, standHeight / 2 + 0.02, 0);
            group.add(pole);

            // Top plate (speaker sits here)
            const topPlate = new THREE.Mesh(new THREE.BoxGeometry(0.26, 0.02, 0.22), metalMat);
            topPlate.position.set(0, topPlateY, 0);
            group.add(topPlate);

            // Speaker Cabinet - sits directly on top plate, NO gap
            const cabinet = new THREE.Mesh(new THREE.BoxGeometry(0.24, cabinetHeight, 0.20), mat);
            cabinet.position.set(0, cabinetY, 0);
            group.add(cabinet);

            // Woofer (driver faces +Z, when rotated 180deg faces into room)
            const woofer = new THREE.Mesh(
                new THREE.CylinderGeometry(0.07, 0.07, 0.03, 16),
                new THREE.MeshLambertMaterial({ color: 0x444444 })
            );
            woofer.rotation.x = Math.PI / 2;
            woofer.position.set(0, cabinetY - 0.06, 0.11);
            group.add(woofer);

            // Tweeter
            const tweeter = new THREE.Mesh(
                new THREE.CylinderGeometry(0.025, 0.025, 0.02, 12),
                new THREE.MeshLambertMaterial({ color: 0x666666 })
            );
            tweeter.rotation.x = Math.PI / 2;
            tweeter.position.set(0, cabinetY + 0.10, 0.11);
            group.add(tweeter);

            // LED indicator
            const led = new THREE.Mesh(
                new THREE.SphereGeometry(0.008, 8, 8),
                new THREE.MeshLambertMaterial({ color: 0x00ff00, emissive: 0x00ff00 })
            );
            led.position.set(0, cabinetY + 0.17, 0.11);
            group.add(led);

            return group;
        }

        // AFRIKADAA WALL POSTER - Magazine cover style artwork
        // Creates a framed poster with text overlay for wall decoration
        function createAfrikadaaPoster(text, color, width, height) {
            const group = new THREE.Group();

            // Frame
            const frameThickness = 0.025;
            const frameDepth = 0.02;
            const frameMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });

            // Frame sides
            const topFrame = new THREE.Mesh(new THREE.BoxGeometry(width + frameThickness * 2, frameThickness, frameDepth), frameMat);
            topFrame.position.set(0, height / 2 + frameThickness / 2, 0);
            group.add(topFrame);

            const bottomFrame = new THREE.Mesh(new THREE.BoxGeometry(width + frameThickness * 2, frameThickness, frameDepth), frameMat);
            bottomFrame.position.set(0, -height / 2 - frameThickness / 2, 0);
            group.add(bottomFrame);

            const leftFrame = new THREE.Mesh(new THREE.BoxGeometry(frameThickness, height, frameDepth), frameMat);
            leftFrame.position.set(-width / 2 - frameThickness / 2, 0, 0);
            group.add(leftFrame);

            const rightFrame = new THREE.Mesh(new THREE.BoxGeometry(frameThickness, height, frameDepth), frameMat);
            rightFrame.position.set(width / 2 + frameThickness / 2, 0, 0);
            group.add(rightFrame);

            // Poster background (colored)
            const posterMat = new THREE.MeshLambertMaterial({ color: color });
            const poster = new THREE.Mesh(new THREE.PlaneGeometry(width, height), posterMat);
            poster.position.set(0, 0, 0.005);
            group.add(poster);

            // Abstract geometric elements (Afrikadaa style - bold, graphic)
            const accentMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
            const darkMat = new THREE.MeshLambertMaterial({ color: 0x000000 });

            // Diagonal stripe
            const stripe = new THREE.Mesh(new THREE.PlaneGeometry(width * 0.15, height * 1.2), accentMat);
            stripe.position.set(-width * 0.2, 0, 0.006);
            stripe.rotation.z = Math.PI / 6;
            group.add(stripe);

            // Circle element
            const circle = new THREE.Mesh(new THREE.CircleGeometry(width * 0.12, 24), darkMat);
            circle.position.set(width * 0.25, height * 0.2, 0.007);
            group.add(circle);

            // Small accent squares
            const sq1 = new THREE.Mesh(new THREE.PlaneGeometry(width * 0.08, width * 0.08), accentMat);
            sq1.position.set(width * 0.3, -height * 0.3, 0.007);
            group.add(sq1);

            const sq2 = new THREE.Mesh(new THREE.PlaneGeometry(width * 0.05, width * 0.05), darkMat);
            sq2.position.set(-width * 0.35, height * 0.35, 0.007);
            group.add(sq2);

            // Text bar at bottom (simulated text block)
            const textBar = new THREE.Mesh(new THREE.PlaneGeometry(width * 0.7, height * 0.08), darkMat);
            textBar.position.set(0, -height * 0.38, 0.008);
            group.add(textBar);

            // White text underline
            const textLine = new THREE.Mesh(new THREE.PlaneGeometry(width * 0.5, height * 0.015), accentMat);
            textLine.position.set(0, -height * 0.42, 0.009);
            group.add(textLine);

            return group;
        }

        // HEADPHONE STATION - Standing/wall mount
        function createHeadphoneStation() {
            const group = new THREE.Group();
            const metalMat = new THREE.MeshLambertMaterial({ color: 0x555555 });
            // Stand
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 1.2, 8), metalMat);
            pole.position.set(0, 0.6, 0);
            group.add(pole);
            // Base
            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 0.03, 16), metalMat);
            base.position.set(0, 0.015, 0);
            group.add(base);
            // Headphone hook
            const hook = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.02, 0.08), metalMat);
            hook.position.set(0, 1.1, 0.05);
            group.add(hook);
            // Headphones
            const hpMat = new THREE.MeshLambertMaterial({ color: 0x222222 });
            const hpBand = new THREE.Mesh(new THREE.TorusGeometry(0.08, 0.015, 8, 16, Math.PI), hpMat);
            hpBand.position.set(0, 1.08, 0.05);
            group.add(hpBand);
            return group;
        }

        // READING TABLE - Simple, robust, rectangular
        function createReadingTable() {
            const group = new THREE.Group();
            const woodMat = new THREE.MeshLambertMaterial({ color: 0xb5906c });
            const metalMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
            // Top
            const top = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.04, 0.9), woodMat);
            top.position.set(0, 0.72, 0);
            group.add(top);
            // Metal frame legs
            for (let x of [-0.85, 0.85]) {
                const legFrame = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.7, 0.8), metalMat);
                legFrame.position.set(x, 0.35, 0);
                group.add(legFrame);
            }
            // Cross bar
            const crossBar = new THREE.Mesh(new THREE.BoxGeometry(1.66, 0.03, 0.03), metalMat);
            crossBar.position.set(0, 0.15, 0);
            group.add(crossBar);
            return group;
        }

        // STACKABLE CHAIR - Simple, functional
        function createStackableChair() {
            const group = new THREE.Group();
            const woodMat = new THREE.MeshLambertMaterial({ color: 0xc4a77d });
            const metalMat = new THREE.MeshLambertMaterial({ color: 0x444444 });
            // Seat
            const seat = new THREE.Mesh(new THREE.BoxGeometry(0.42, 0.025, 0.4), woodMat);
            seat.position.set(0, 0.45, 0);
            group.add(seat);
            // Back
            const back = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.35, 0.02), woodMat);
            back.position.set(0, 0.7, -0.18);
            group.add(back);
            // Legs (metal tube)
            for (let x of [-0.18, 0.18]) {
                for (let z of [-0.15, 0.15]) {
                    const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.012, 0.45, 8), metalMat);
                    leg.position.set(x, 0.225, z);
                    group.add(leg);
                }
            }
            return group;
        }

        // WALL SHELF - For archives and books
        function createWallShelf() {
            const group = new THREE.Group();
            const woodMat = new THREE.MeshLambertMaterial({ color: 0xb5906c });
            const metalMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
            // Shelf
            const shelf = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.025, 0.25), woodMat);
            shelf.position.set(0, 0, 0);
            group.add(shelf);
            // Brackets
            const bracket1 = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.15, 0.2), metalMat);
            bracket1.position.set(-0.5, -0.075, 0);
            group.add(bracket1);
            const bracket2 = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.15, 0.2), metalMat);
            bracket2.position.set(0.5, -0.075, 0);
            group.add(bracket2);
            // Some books
            const bookColors = [0x8b0000, 0x1a3a5c, 0x2e7d32, 0xf57c00];
            for (let i = 0; i < 4; i++) {
                const book = new THREE.Mesh(
                    new THREE.BoxGeometry(0.15, 0.22, 0.03),
                    new THREE.MeshLambertMaterial({ color: bookColors[i] })
                );
                book.position.set(-0.4 + i * 0.25, 0.12, 0);
                group.add(book);
            }
            return group;
        }

        // LOW ARCHIVE CABINET
        function createLowArchiveCabinet() {
            const group = new THREE.Group();
            const woodMat = new THREE.MeshLambertMaterial({ color: 0xa08060 });
            // Main body
            const body = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.6, 0.4), woodMat);
            body.position.set(0, 0.3, 0);
            group.add(body);
            // Drawer lines
            const lineMat = new THREE.MeshLambertMaterial({ color: 0x5a4535 });
            for (let y of [0.15, 0.35, 0.55]) {
                const line = new THREE.Mesh(new THREE.BoxGeometry(0.96, 0.01, 0.01), lineMat);
                line.position.set(0, y, 0.2);
                group.add(line);
            }
            return group;
        }

        // SCREEN STAND - For video content
        function createScreenStand() {
            const group = new THREE.Group();
            const metalMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const screenMat = new THREE.MeshLambertMaterial({ color: 0x111111 });
            // Pole
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 1.5, 8), metalMat);
            pole.position.set(0, 0.75, 0);
            group.add(pole);
            // Base
            const base = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.03, 0.4), metalMat);
            base.position.set(0, 0.015, 0);
            group.add(base);
            // Screen
            const screen = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.35, 0.03), screenMat);
            screen.position.set(0, 1.4, 0);
            group.add(screen);
            // Screen content (placeholder)
            const content = new THREE.Mesh(
                new THREE.PlaneGeometry(0.55, 0.3),
                new THREE.MeshLambertMaterial({ color: 0x2a4a6a })
            );
            content.position.set(0, 1.4, 0.02);
            group.add(content);
            return group;
        }

        // SIMPLE STOOL - For viewing areas
        function createSimpleStool() {
            const group = new THREE.Group();
            const woodMat = new THREE.MeshLambertMaterial({ color: 0xb5906c });
            const metalMat = new THREE.MeshLambertMaterial({ color: 0x444444 });
            // Seat
            const seat = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 0.03, 16), woodMat);
            seat.position.set(0, 0.45, 0);
            group.add(seat);
            // Legs
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.012, 0.44, 8), metalMat);
                leg.position.set(Math.cos(angle) * 0.1, 0.22, Math.sin(angle) * 0.1);
                group.add(leg);
            }
            return group;
        }

        // SIMPLE PENDANT LIGHT - Functional, not decorative
        function createSimplePendant() {
            const group = new THREE.Group();
            const metalMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const lightMat = new THREE.MeshLambertMaterial({ color: 0xffffee, emissive: 0x444422 });
            // Cord
            const cord = new THREE.Mesh(new THREE.CylinderGeometry(0.005, 0.005, 0.3, 8), metalMat);
            cord.position.set(0, 0.15, 0);
            group.add(cord);
            // Shade
            const shade = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.2, 0.15, 16, 1, true), metalMat);
            shade.position.set(0, -0.05, 0);
            group.add(shade);
            // Bulb
            const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.05, 12, 12), lightMat);
            bulb.position.set(0, -0.02, 0);
            group.add(bulb);
            return group;
        }

        // OLIVE VELVET SOFA - Low-profile tufted sofa
        function createOliveSofa() {
            const group = new THREE.Group();
            const mat = new THREE.MeshLambertMaterial({ color: 0x6b8e23 }); // Olive green
            // Seat
            const seat = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.25, 0.9), mat);
            seat.position.set(0, 0.2, 0);
            group.add(seat);
            // Low back
            const back = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.35, 0.15), mat);
            back.position.set(0, 0.45, -0.4);
            group.add(back);
            // Rounded arms
            const armMat = new THREE.MeshLambertMaterial({ color: 0x5a7d1a });
            const armL = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.9, 12), armMat);
            armL.rotation.x = Math.PI / 2;
            armL.position.set(-0.95, 0.3, 0);
            group.add(armL);
            const armR = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.9, 12), armMat);
            armR.rotation.x = Math.PI / 2;
            armR.position.set(0.95, 0.3, 0);
            group.add(armR);
            // Tufting buttons
            for (let x = -0.6; x <= 0.6; x += 0.4) {
                for (let z = -0.2; z <= 0.2; z += 0.4) {
                    const btn = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.02, 0.02, 0.02, 8),
                        new THREE.MeshLambertMaterial({ color: 0x333333 })
                    );
                    btn.position.set(x, 0.34, z);
                    group.add(btn);
                }
            }
            return group;
        }

        // PINK VELVET ARMCHAIR
        function createPinkArmchair() {
            const group = new THREE.Group();
            const mat = new THREE.MeshLambertMaterial({ color: 0xe91e63 }); // Pink
            // Seat
            const seat = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.2, 0.7), mat);
            seat.position.set(0, 0.25, 0);
            group.add(seat);
            // Back - curved
            const back = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.6, 0.1), mat);
            back.position.set(0, 0.6, -0.3);
            group.add(back);
            // Arms
            const armL = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.3, 0.6), mat);
            armL.position.set(-0.35, 0.4, 0);
            group.add(armL);
            const armR = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.3, 0.6), mat);
            armR.position.set(0.35, 0.4, 0);
            group.add(armR);
            // Legs - wooden
            const legMat = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
            [[-0.25, -0.25], [-0.25, 0.25], [0.25, -0.25], [0.25, 0.25]].forEach(([x, z]) => {
                const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.02, 0.15, 8), legMat);
                leg.position.set(x, 0.075, z);
                group.add(leg);
            });
            return group;
        }

        // BOOK DISPLAYS & STORAGE
        function createWallBookcase() {
            const group = new THREE.Group();
            const woodMat = new THREE.MeshLambertMaterial({ color: 0xd4a76a });
            // Back panel
            const back = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.8, 0.03), woodMat);
            back.position.set(0, 0.9, -0.15);
            group.add(back);
            // Shelves
            for (let y = 0.15; y <= 1.65; y += 0.3) {
                const shelf = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.03, 0.3), woodMat);
                shelf.position.set(0, y, 0);
                group.add(shelf);
                // Add some books
                const bookColors = [0xc41e3a, 0x1a3a5c, 0xfdd835, 0x4caf50, 0x9c27b0];
                for (let i = 0; i < 5; i++) {
                    const book = new THREE.Mesh(
                        new THREE.BoxGeometry(0.05 + Math.random() * 0.03, 0.2 + Math.random() * 0.05, 0.15),
                        new THREE.MeshLambertMaterial({ color: bookColors[i % bookColors.length] })
                    );
                    book.position.set(-0.45 + i * 0.2, y + 0.12, 0);
                    group.add(book);
                }
            }
            // Sides
            const sideL = new THREE.Mesh(new THREE.BoxGeometry(0.03, 1.8, 0.3), woodMat);
            sideL.position.set(-0.6, 0.9, 0);
            group.add(sideL);
            const sideR = new THREE.Mesh(new THREE.BoxGeometry(0.03, 1.8, 0.3), woodMat);
            sideR.position.set(0.6, 0.9, 0);
            group.add(sideR);
            return group;
        }

        function createBookCubby() {
            const group = new THREE.Group();
            const woodMat = new THREE.MeshLambertMaterial({ color: 0xdeb887 }); // Light wood
            // Create cubby grid
            const cubbies = 3;
            const cubbySize = 0.35;
            for (let x = 0; x < cubbies; x++) {
                for (let y = 0; y < cubbies; y++) {
                    // Cubby box
                    const box = new THREE.Mesh(
                        new THREE.BoxGeometry(cubbySize, cubbySize, 0.3),
                        woodMat
                    );
                    box.position.set((x - 1) * (cubbySize + 0.02), y * (cubbySize + 0.02) + cubbySize/2, 0);
                    group.add(box);
                    // Random content
                    if (Math.random() > 0.3) {
                        const content = new THREE.Mesh(
                            new THREE.BoxGeometry(cubbySize * 0.8, cubbySize * 0.7, 0.15),
                            new THREE.MeshLambertMaterial({ color: [0xc41e3a, 0x1a3a5c, 0xfdd835, 0x4caf50][Math.floor(Math.random() * 4)] })
                        );
                        content.position.set((x - 1) * (cubbySize + 0.02), y * (cubbySize + 0.02) + cubbySize/2, 0.05);
                        group.add(content);
                    }
                }
            }
            return group;
        }

        function createMagazineRack() {
            const group = new THREE.Group();
            const wireMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
            // Wire frame
            for (let i = 0; i < 4; i++) {
                const wire = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.01, 0.01, 0.6, 8),
                    wireMat
                );
                wire.rotation.z = Math.PI / 6;
                wire.position.set(-0.15 + i * 0.1, 0.35, 0);
                group.add(wire);
            }
            // Base
            const base = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.02, 0.2), wireMat);
            base.position.set(0, 0.02, 0);
            group.add(base);
            // Magazines
            const magColors = [0xff6b6b, 0x45b7d1, 0xfdd835, 0x4caf50];
            for (let i = 0; i < 4; i++) {
                const mag = new THREE.Mesh(
                    new THREE.BoxGeometry(0.02, 0.28, 0.2),
                    new THREE.MeshLambertMaterial({ color: magColors[i] })
                );
                mag.rotation.z = Math.PI / 6;
                mag.position.set(-0.12 + i * 0.08, 0.25 + i * 0.03, 0);
                group.add(mag);
            }
            return group;
        }

        function createBookStack() {
            const group = new THREE.Group();
            const colors = [0xc41e3a, 0x1a3a5c, 0xfdd835, 0x4caf50, 0x9c27b0, 0xff6b6b];
            let y = 0;
            for (let i = 0; i < 5; i++) {
                const book = new THREE.Mesh(
                    new THREE.BoxGeometry(0.2 + Math.random() * 0.05, 0.03 + Math.random() * 0.02, 0.15),
                    new THREE.MeshLambertMaterial({ color: colors[i % colors.length] })
                );
                book.position.set((Math.random() - 0.5) * 0.03, y + 0.015, 0);
                book.rotation.y = (Math.random() - 0.5) * 0.2;
                group.add(book);
                y += 0.035;
            }
            return group;
        }

        function createColorDisplay(color) {
            const group = new THREE.Group();
            const mat = new THREE.MeshLambertMaterial({ color });
            // Pedestal display
            const base = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.6, 0.4), mat);
            base.position.set(0, 0.3, 0);
            group.add(base);
            // Books on top
            const bookMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
            for (let i = 0; i < 3; i++) {
                const book = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.04, 0.12), bookMat);
                book.position.set(-0.1 + i * 0.1, 0.62 + i * 0.04, 0);
                book.rotation.y = (Math.random() - 0.5) * 0.3;
                group.add(book);
            }
            return group;
        }

        function createLeaningShelf() {
            const group = new THREE.Group();
            const woodMat = new THREE.MeshLambertMaterial({ color: 0xd4a76a });
            // Leaning frame
            const angle = Math.PI / 12;
            for (let side = -1; side <= 1; side += 2) {
                const leg = new THREE.Mesh(new THREE.BoxGeometry(0.04, 1.5, 0.04), woodMat);
                leg.position.set(side * 0.4, 0.7, -0.1);
                leg.rotation.x = -angle;
                group.add(leg);
            }
            // Shelves
            for (let i = 0; i < 4; i++) {
                const shelf = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.02, 0.25), woodMat);
                shelf.position.set(0, 0.2 + i * 0.35, -0.05 - i * 0.08);
                group.add(shelf);
            }
            return group;
        }

        // RUGS - Layered Persian & African
        function createLayeredRug(width, depth, color) {
            const group = new THREE.Group();
            const rugMat = new THREE.MeshLambertMaterial({ color });
            const rug = new THREE.Mesh(new THREE.BoxGeometry(width, 0.02, depth), rugMat);
            rug.position.set(0, 0.01, 0);
            group.add(rug);
            // Border
            const borderMat = new THREE.MeshLambertMaterial({ color: darkenColor(color, 0.3) });
            const borderW = 0.08;
            const borderT = new THREE.Mesh(new THREE.BoxGeometry(width, 0.025, borderW), borderMat);
            borderT.position.set(0, 0.012, depth/2 - borderW/2);
            group.add(borderT);
            const borderB = new THREE.Mesh(new THREE.BoxGeometry(width, 0.025, borderW), borderMat);
            borderB.position.set(0, 0.012, -depth/2 + borderW/2);
            group.add(borderB);
            const borderL = new THREE.Mesh(new THREE.BoxGeometry(borderW, 0.025, depth), borderMat);
            borderL.position.set(-width/2 + borderW/2, 0.012, 0);
            group.add(borderL);
            const borderR = new THREE.Mesh(new THREE.BoxGeometry(borderW, 0.025, depth), borderMat);
            borderR.position.set(width/2 - borderW/2, 0.012, 0);
            group.add(borderR);
            return group;
        }

        function darkenColor(color, amount) {
            const r = ((color >> 16) & 255) * (1 - amount);
            const g = ((color >> 8) & 255) * (1 - amount);
            const b = (color & 255) * (1 - amount);
            return (Math.floor(r) << 16) | (Math.floor(g) << 8) | Math.floor(b);
        }

        // NATTE PLASTIQUE - Senegalese woven plastic mat (checkered pattern)
        function createAfricanNatte() {
            const group = new THREE.Group();
            const width = 2.2, depth = 1.6;
            // Base mat
            const baseMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
            const base = new THREE.Mesh(new THREE.BoxGeometry(width, 0.015, depth), baseMat);
            base.position.set(0, 0.008, 0);
            group.add(base);
            // Checkered pattern (like Senegalese nattes plastiques)
            const colors = [0xff1493, 0x00ced1, 0xffd700, 0xf5f0e8, 0xff6b6b, 0x32cd32];
            const squareSize = 0.15;
            const cols = Math.floor(width / squareSize);
            const rows = Math.floor(depth / squareSize);
            for (let x = 0; x < cols; x++) {
                for (let z = 0; z < rows; z++) {
                    if ((x + z) % 2 === 0) {
                        const color = colors[(x + z * 2) % colors.length];
                        const square = new THREE.Mesh(
                            new THREE.BoxGeometry(squareSize * 0.9, 0.018, squareSize * 0.9),
                            new THREE.MeshLambertMaterial({ color })
                        );
                        square.position.set(
                            -width/2 + squareSize/2 + x * squareSize,
                            0.01,
                            -depth/2 + squareSize/2 + z * squareSize
                        );
                        group.add(square);
                    }
                }
            }
            return group;
        }

        function createCheckeredRug(color1, color2) {
            const group = new THREE.Group();
            const size = 0.3;
            const count = 6;
            for (let x = 0; x < count; x++) {
                for (let z = 0; z < count; z++) {
                    const color = (x + z) % 2 === 0 ? color1 : color2;
                    const tile = new THREE.Mesh(
                        new THREE.BoxGeometry(size, 0.02, size),
                        new THREE.MeshLambertMaterial({ color })
                    );
                    tile.position.set((x - count/2 + 0.5) * size, 0.01, (z - count/2 + 0.5) * size);
                    group.add(tile);
                }
            }
            return group;
        }

        function createWaxPrintRug(color1, color2) {
            const group = new THREE.Group();
            const width = 2.0, depth = 1.5;
            // Base
            const base = new THREE.Mesh(
                new THREE.BoxGeometry(width, 0.02, depth),
                new THREE.MeshLambertMaterial({ color: color1 })
            );
            base.position.set(0, 0.01, 0);
            group.add(base);
            // African wax print pattern - circular motifs
            for (let x = -0.6; x <= 0.6; x += 0.4) {
                for (let z = -0.4; z <= 0.4; z += 0.4) {
                    const circle = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.12, 0.12, 0.025, 16),
                        new THREE.MeshLambertMaterial({ color: color2 })
                    );
                    circle.position.set(x, 0.012, z);
                    group.add(circle);
                    // Inner circle
                    const inner = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.06, 0.06, 0.027, 12),
                        new THREE.MeshLambertMaterial({ color: color1 })
                    );
                    inner.position.set(x, 0.014, z);
                    group.add(inner);
                }
            }
            return group;
        }

        function createGeometricRug() {
            const group = new THREE.Group();
            const width = 2.2, depth = 1.6;
            // Base - cream
            const base = new THREE.Mesh(
                new THREE.BoxGeometry(width, 0.02, depth),
                new THREE.MeshLambertMaterial({ color: 0xf5f0e8 })
            );
            base.position.set(0, 0.01, 0);
            group.add(base);
            // Black geometric triangles
            const triMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
            const triShape = new THREE.Shape();
            triShape.moveTo(0, 0.15);
            triShape.lineTo(-0.1, 0);
            triShape.lineTo(0.1, 0);
            triShape.lineTo(0, 0.15);
            const triGeo = new THREE.ShapeGeometry(triShape);
            for (let x = -0.7; x <= 0.7; x += 0.35) {
                for (let z = -0.5; z <= 0.5; z += 0.3) {
                    const tri = new THREE.Mesh(triGeo, triMat);
                    tri.rotation.x = -Math.PI / 2;
                    tri.position.set(x, 0.012, z);
                    if (Math.random() > 0.5) tri.rotation.z = Math.PI;
                    group.add(tri);
                }
            }
            return group;
        }

        function createTieDyeCloth() {
            const group = new THREE.Group();
            // Table-sized cloth
            const cloth = new THREE.Mesh(
                new THREE.BoxGeometry(1.8, 0.01, 0.8),
                new THREE.MeshLambertMaterial({ color: 0x4169e1 })
            );
            cloth.position.set(0, 0.72, 0);
            group.add(cloth);
            // Tie-dye circles
            const dyeColors = [0xffffff, 0x9c27b0, 0x00bcd4];
            for (let i = 0; i < 5; i++) {
                const circle = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1 + Math.random() * 0.1, 0.1, 0.015, 12),
                    new THREE.MeshLambertMaterial({ color: dyeColors[i % dyeColors.length] })
                );
                circle.position.set(-0.6 + i * 0.3, 0.725, (Math.random() - 0.5) * 0.4);
                group.add(circle);
            }
            return group;
        }

        // LIGHTING - Ethiopian & Disco
        function createEthiopianLamp() {
            const group = new THREE.Group();
            // Woven basket shade
            const shadeMat = new THREE.MeshLambertMaterial({ color: 0xd4a76a, side: THREE.DoubleSide });
            const shade = new THREE.Mesh(
                new THREE.ConeGeometry(0.25, 0.35, 12, 1, true),
                shadeMat
            );
            shade.position.set(0, 0, 0);
            shade.rotation.x = Math.PI;
            group.add(shade);
            // Beaded fringe
            const beadMat = new THREE.MeshLambertMaterial({ color: 0xc41e3a });
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                for (let j = 0; j < 4; j++) {
                    const bead = new THREE.Mesh(
                        new THREE.SphereGeometry(0.015, 6, 6),
                        j % 2 === 0 ? beadMat : new THREE.MeshLambertMaterial({ color: 0xfdd835 })
                    );
                    bead.position.set(
                        Math.cos(angle) * 0.23,
                        -0.38 - j * 0.04,
                        Math.sin(angle) * 0.23
                    );
                    group.add(bead);
                }
            }
            // Cord
            const cord = new THREE.Mesh(
                new THREE.CylinderGeometry(0.01, 0.01, 0.5, 8),
                new THREE.MeshLambertMaterial({ color: 0x8b4513 })
            );
            cord.position.set(0, 0.42, 0);
            group.add(cord);
            return group;
        }

        function createBeadedLamp() {
            const group = new THREE.Group();
            // Cylinder shade
            const shadeMat = new THREE.MeshLambertMaterial({ color: 0xf5f5dc, side: THREE.DoubleSide });
            const shade = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.2, 0.3, 12, 1, true),
                shadeMat
            );
            shade.position.set(0, 0, 0);
            group.add(shade);
            // Colorful beads hanging
            const beadColors = [0xc41e3a, 0xfdd835, 0x4caf50, 0x2196f3, 0x9c27b0];
            for (let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2;
                const color = beadColors[i % beadColors.length];
                for (let j = 0; j < 6; j++) {
                    const bead = new THREE.Mesh(
                        new THREE.SphereGeometry(0.012, 6, 6),
                        new THREE.MeshLambertMaterial({ color })
                    );
                    bead.position.set(
                        Math.cos(angle) * 0.18,
                        -0.18 - j * 0.025,
                        Math.sin(angle) * 0.18
                    );
                    group.add(bead);
                }
            }
            // Cord
            const cord = new THREE.Mesh(
                new THREE.CylinderGeometry(0.01, 0.01, 0.4, 8),
                new THREE.MeshLambertMaterial({ color: 0x333333 })
            );
            cord.position.set(0, 0.35, 0);
            group.add(cord);
            return group;
        }

        function createDiscoBallCluster() {
            const group = new THREE.Group();
            const ballMat = new THREE.MeshLambertMaterial({ color: 0xc0c0c0 });
            const cordMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
            // Multiple balls at different heights
            const positions = [
                { x: 0, y: 0, z: 0, size: 0.15, cordLen: 0.3 },
                { x: 0.25, y: 0.15, z: 0.1, size: 0.1, cordLen: 0.15 },
                { x: -0.2, y: 0.1, z: -0.1, size: 0.12, cordLen: 0.2 },
                { x: 0.1, y: -0.1, z: 0.2, size: 0.08, cordLen: 0.4 }
            ];
            positions.forEach(p => {
                const ball = new THREE.Mesh(new THREE.SphereGeometry(p.size, 12, 12), ballMat);
                ball.position.set(p.x, p.y, p.z);
                group.add(ball);
                const cord = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.008, 0.008, p.cordLen, 8),
                    cordMat
                );
                cord.position.set(p.x, p.y + p.size + p.cordLen/2, p.z);
                group.add(cord);
            });
            return group;
        }

        function createStringLights() {
            const group = new THREE.Group();
            const wireMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const bulbColors = [0xfdd835, 0xff6b6b, 0x4caf50, 0x2196f3, 0x9c27b0];
            // Wire
            const points = [];
            for (let i = 0; i <= 10; i++) {
                points.push(new THREE.Vector3(
                    -1.5 + i * 0.3,
                    Math.sin(i * 0.5) * 0.1,
                    0
                ));
            }
            // Bulbs along the wire
            for (let i = 0; i < 10; i++) {
                const bulb = new THREE.Mesh(
                    new THREE.SphereGeometry(0.03, 8, 8),
                    new THREE.MeshLambertMaterial({ color: bulbColors[i % bulbColors.length], emissive: bulbColors[i % bulbColors.length], emissiveIntensity: 0.3 })
                );
                bulb.position.set(-1.5 + i * 0.3, Math.sin(i * 0.5) * 0.1 - 0.05, 0);
                group.add(bulb);
                // Wire segment
                if (i < 9) {
                    const wire = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.005, 0.005, 0.3, 6),
                        wireMat
                    );
                    wire.position.set(-1.35 + i * 0.3, Math.sin(i * 0.5 + 0.25) * 0.1, 0);
                    wire.rotation.z = Math.PI / 2;
                    group.add(wire);
                }
            }
            return group;
        }

        function createPaperLantern() {
            const group = new THREE.Group();
            const lanternMat = new THREE.MeshLambertMaterial({
                color: 0xfff8e1,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.9
            });
            const lantern = new THREE.Mesh(
                new THREE.SphereGeometry(0.2, 16, 12),
                lanternMat
            );
            lantern.scale.set(1, 1.2, 1);
            lantern.position.set(0, 0, 0);
            group.add(lantern);
            // Wire frame rings
            const wireMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
            for (let i = -0.15; i <= 0.15; i += 0.1) {
                const ring = new THREE.Mesh(
                    new THREE.TorusGeometry(0.18, 0.005, 8, 16),
                    wireMat
                );
                ring.position.set(0, i, 0);
                ring.rotation.x = Math.PI / 2;
                group.add(ring);
            }
            // Cord
            const cord = new THREE.Mesh(
                new THREE.CylinderGeometry(0.01, 0.01, 0.3, 8),
                wireMat
            );
            cord.position.set(0, 0.38, 0);
            group.add(cord);
            return group;
        }

        // PLANTS & AFRICAN DECOR
        function createPalmPlant() {
            const group = new THREE.Group();
            // Pot
            const potMat = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
            const pot = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.12, 0.25, 12), potMat);
            pot.position.set(0, 0.125, 0);
            group.add(pot);
            // Soil
            const soil = new THREE.Mesh(
                new THREE.CylinderGeometry(0.14, 0.14, 0.03, 12),
                new THREE.MeshLambertMaterial({ color: 0x3e2723 })
            );
            soil.position.set(0, 0.24, 0);
            group.add(soil);
            // Palm fronds
            const leafMat = new THREE.MeshLambertMaterial({ color: 0x2e7d32, side: THREE.DoubleSide });
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const leaf = new THREE.Mesh(
                    new THREE.BoxGeometry(0.08, 0.5, 0.01),
                    leafMat
                );
                leaf.position.set(
                    Math.cos(angle) * 0.1,
                    0.5,
                    Math.sin(angle) * 0.1
                );
                leaf.rotation.x = -0.5;
                leaf.rotation.y = angle;
                leaf.rotation.z = 0.3;
                group.add(leaf);
            }
            return group;
        }

        function createHangingPlant() {
            const group = new THREE.Group();
            // Macrame holder
            const cordMat = new THREE.MeshLambertMaterial({ color: 0xf5f5dc });
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const cord = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.008, 0.008, 0.4, 6),
                    cordMat
                );
                cord.position.set(Math.cos(angle) * 0.1, 0.2, Math.sin(angle) * 0.1);
                group.add(cord);
            }
            // Pot
            const pot = new THREE.Mesh(
                new THREE.CylinderGeometry(0.12, 0.1, 0.15, 12),
                new THREE.MeshLambertMaterial({ color: 0xd4a76a })
            );
            pot.position.set(0, 0, 0);
            group.add(pot);
            // Trailing vines
            const vineMat = new THREE.MeshLambertMaterial({ color: 0x4caf50 });
            for (let i = 0; i < 5; i++) {
                const angle = (i / 5) * Math.PI * 2;
                for (let j = 0; j < 4; j++) {
                    const leaf = new THREE.Mesh(
                        new THREE.SphereGeometry(0.025, 6, 6),
                        vineMat
                    );
                    leaf.position.set(
                        Math.cos(angle) * (0.12 + j * 0.03),
                        -0.1 - j * 0.08,
                        Math.sin(angle) * (0.12 + j * 0.03)
                    );
                    group.add(leaf);
                }
            }
            return group;
        }

        function createPothosVine() {
            const group = new THREE.Group();
            // Small pot
            const pot = new THREE.Mesh(
                new THREE.CylinderGeometry(0.08, 0.06, 0.1, 10),
                new THREE.MeshLambertMaterial({ color: 0xffffff })
            );
            pot.position.set(0, 0.05, 0);
            group.add(pot);
            // Trailing vine with heart-shaped leaves
            const leafMat = new THREE.MeshLambertMaterial({ color: 0x66bb6a });
            const vineMat = new THREE.MeshLambertMaterial({ color: 0x2e7d32 });
            for (let v = 0; v < 3; v++) {
                const angle = (v / 3) * Math.PI * 2;
                for (let i = 0; i < 6; i++) {
                    // Vine segment
                    const vine = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.005, 0.005, 0.08, 6),
                        vineMat
                    );
                    vine.position.set(
                        Math.cos(angle) * 0.06 + Math.sin(i) * 0.02,
                        -i * 0.06,
                        Math.sin(angle) * 0.06
                    );
                    vine.rotation.z = 0.3;
                    group.add(vine);
                    // Leaf
                    const leaf = new THREE.Mesh(
                        new THREE.SphereGeometry(0.03, 6, 6),
                        leafMat
                    );
                    leaf.scale.set(1, 0.3, 1.2);
                    leaf.position.set(
                        Math.cos(angle) * 0.08 + Math.sin(i) * 0.03,
                        -i * 0.06 - 0.02,
                        Math.sin(angle) * 0.08
                    );
                    group.add(leaf);
                }
            }
            return group;
        }

        function createWovenBasket() {
            const group = new THREE.Group();
            const basketMat = new THREE.MeshLambertMaterial({ color: 0xd4a76a });
            const basket = new THREE.Mesh(
                new THREE.CylinderGeometry(0.2, 0.15, 0.25, 16),
                basketMat
            );
            basket.position.set(0, 0.125, 0);
            group.add(basket);
            // Weave pattern stripes
            const stripeMat = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
            for (let i = 0; i < 4; i++) {
                const stripe = new THREE.Mesh(
                    new THREE.TorusGeometry(0.17 - i * 0.01, 0.01, 8, 16),
                    stripeMat
                );
                stripe.position.set(0, 0.05 + i * 0.05, 0);
                stripe.rotation.x = Math.PI / 2;
                group.add(stripe);
            }
            return group;
        }

        function createAfricanPottery() {
            const group = new THREE.Group();
            // Rounded pot with narrow neck
            const potMat = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
            const body = new THREE.Mesh(
                new THREE.SphereGeometry(0.15, 12, 12),
                potMat
            );
            body.scale.set(1, 0.8, 1);
            body.position.set(0, 0.12, 0);
            group.add(body);
            const neck = new THREE.Mesh(
                new THREE.CylinderGeometry(0.06, 0.1, 0.1, 12),
                potMat
            );
            neck.position.set(0, 0.27, 0);
            group.add(neck);
            // Geometric pattern
            const patternMat = new THREE.MeshLambertMaterial({ color: 0xf5f0e8 });
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const dot = new THREE.Mesh(
                    new THREE.SphereGeometry(0.015, 6, 6),
                    patternMat
                );
                dot.position.set(
                    Math.cos(angle) * 0.14,
                    0.12,
                    Math.sin(angle) * 0.14
                );
                group.add(dot);
            }
            return group;
        }

        function createWoodSculpture() {
            const group = new THREE.Group();
            const woodMat = new THREE.MeshLambertMaterial({ color: 0x5d4037 });
            // Abstract figure
            const base = new THREE.Mesh(
                new THREE.CylinderGeometry(0.08, 0.1, 0.05, 12),
                woodMat
            );
            base.position.set(0, 0.025, 0);
            group.add(base);
            const body = new THREE.Mesh(
                new THREE.CylinderGeometry(0.04, 0.06, 0.3, 8),
                woodMat
            );
            body.position.set(0, 0.2, 0);
            group.add(body);
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.06, 10, 10),
                woodMat
            );
            head.scale.set(1, 1.3, 0.8);
            head.position.set(0, 0.42, 0);
            group.add(head);
            // Arms
            const armL = new THREE.Mesh(
                new THREE.CylinderGeometry(0.015, 0.015, 0.15, 6),
                woodMat
            );
            armL.position.set(-0.08, 0.25, 0);
            armL.rotation.z = 0.5;
            group.add(armL);
            const armR = new THREE.Mesh(
                new THREE.CylinderGeometry(0.015, 0.015, 0.15, 6),
                woodMat
            );
            armR.position.set(0.08, 0.25, 0);
            armR.rotation.z = -0.5;
            group.add(armR);
            return group;
        }

        // ============ MOUSE INTERACTION FOR DECORATOR ============
        let isMouseDraggingItem = false;
        let mouseDownTime = 0;
        let mouseDownPos = { x: 0, y: 0 };

        // Mousedown - start potential drag or selection
        container.addEventListener('mousedown', function(event) {
            if (!decoratorMode) return;
            if (event.button !== 0) return; // Left click only

            mouseDownTime = Date.now();
            mouseDownPos = { x: event.clientX, y: event.clientY };

            const rect = container.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Check if clicking on existing placed item
            const itemIntersects = raycaster.intersectObjects(placedItems, true);
            if (itemIntersects.length > 0) {
                let obj = itemIntersects[0].object;
                while (obj.parent && !obj.userData.isPlacedItem) obj = obj.parent;
                if (obj.userData.isPlacedItem) {
                    selectedPlacedItem = obj;
                    selectedFurnitureType = null;
                    document.querySelectorAll('.item-card').forEach(c => c.classList.remove('selected'));
                    updateSelectedInfo();
                    isMouseDraggingItem = true;
                    isCameraOrbitBlocked = true; // BLOCK camera orbit while dragging furniture
                    container.style.cursor = 'grabbing';
                    event.preventDefault();
                    event.stopPropagation();
                    return;
                }
            }
        });

        // Mousemove - drag selected item (STRICT: only moves within room bounds)
        let mouseDragLastValidPos = null;
        container.addEventListener('mousemove', function(event) {
            if (!decoratorMode || !isMouseDraggingItem || !selectedPlacedItem) return;

            const rect = container.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const floorPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const intersectPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(floorPlane, intersectPoint);

            if (intersectPoint) {
                intersectPoint.y = 0;
                const constrained = constrainToRoom(intersectPoint);
                if (constrained) {
                    // VALID position - move item
                    selectedPlacedItem.position.x = constrained.x;
                    selectedPlacedItem.position.z = constrained.z;
                    if (!selectedPlacedItem.userData.isWallArt) {
                        selectedPlacedItem.position.y = 0;
                    }
                    mouseDragLastValidPos = selectedPlacedItem.position.clone();
                }
                // If constrained returns null, item stays at last valid position
            }
        });

        // Mouseup - end drag or click to place new item
        container.addEventListener('mouseup', function(event) {
            const wasDragging = isMouseDraggingItem;
            const clickDuration = Date.now() - mouseDownTime;
            const moveDistance = Math.sqrt(
                Math.pow(event.clientX - mouseDownPos.x, 2) +
                Math.pow(event.clientY - mouseDownPos.y, 2)
            );

            isMouseDraggingItem = false;
            isCameraOrbitBlocked = false; // UNBLOCK camera orbit
            container.style.cursor = '';

            // If we were dragging an item, don't place a new one
            if (wasDragging) return;

            // Short click with minimal movement = place new item
            if (clickDuration < 300 && moveDistance < 10 && selectedFurnitureType) {
                const rect = container.getBoundingClientRect();
                const screenX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                const screenY = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                placeItemAtScreenPos(selectedFurnitureType, screenX, screenY);
            }
        });

        // Click on empty space to deselect
        container.addEventListener('click', function(event) {
            if (!decoratorMode) return;

            const rect = container.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // If click didn't hit any placed item and we have no furniture selected, deselect
            const itemIntersects = raycaster.intersectObjects(placedItems, true);
            if (itemIntersects.length === 0 && !selectedFurnitureType) {
                selectedPlacedItem = null;
                updateSelectedInfo();
            }
        });

        // Initialize canvas drag-drop on load
        setupCanvasDragDrop();

        // ============================================================
        // STRICT ROOM BOUNDARY RULES - NO EXCEPTIONS
        // Items can ONLY be placed INSIDE rooms. Period.
        // ============================================================
        function constrainToRoom(pos, assetId = null) {
            const x = pos.x;
            const z = pos.z;

            // STRICT Room S202 boundaries (left room)
            const s202Bounds = ROOM_GEOMETRY['S202'].bounds;
            const s202Door = ROOM_GEOMETRY['S202'].doorZone;
            const WALL_MARGIN = 0.3; // Keep items 30cm from walls
            const s202Left = s202Bounds.minX + WALL_MARGIN;
            const s202Right = s202Bounds.maxX - WALL_MARGIN;
            const s202Front = s202Bounds.maxZ - WALL_MARGIN;
            const s202Back = s202Bounds.minZ + WALL_MARGIN;

            // STRICT Room S203 boundaries (right room)
            const s203Bounds = ROOM_GEOMETRY['S203'].bounds;
            const s203Door = ROOM_GEOMETRY['S203'].doorZone;
            const s203Left = s203Bounds.minX + WALL_MARGIN;
            const s203Right = s203Bounds.maxX - WALL_MARGIN;
            const s203Front = s203Bounds.maxZ - WALL_MARGIN;
            const s203Back = s203Bounds.minZ + WALL_MARGIN;

            // STRICT CHECK: Is position INSIDE S202?
            const inS202 = x >= s202Left && x <= s202Right &&
                           z >= s202Back && z <= s202Front;

            // STRICT CHECK: Is position INSIDE S203?
            const inS203 = x >= s203Left && x <= s203Right &&
                           z >= s203Back && z <= s203Front;

            // RULE: If not inside ANY room, REJECT placement entirely
            if (!inS202 && !inS203) {
                console.warn('REJECTED: Placement outside room boundaries at', x.toFixed(2), z.toFixed(2));
                return null; // REJECT - cannot place outside rooms
            }

            // Helper: Check if position is in door zone (blocked area)
            function isInDoorZone(px, pz, doorZone) {
                return px >= doorZone.minX - 0.2 && px <= doorZone.maxX + 0.2 &&
                       pz >= doorZone.minZ && pz <= doorZone.maxZ + 0.3;
            }

            // If in S202
            if (inS202) {
                // Check door zone - push away if too close
                if (isInDoorZone(x, z, s202Door)) {
                    // Push south away from door
                    const safeZ = s202Door.maxZ + 0.4;
                    if (safeZ <= s202Front) {
                        return new THREE.Vector3(x, 0, safeZ);
                    }
                    // Can't place here at all
                    console.warn('REJECTED: Too close to S202 door');
                    return null;
                }
                return new THREE.Vector3(x, 0, z);
            }

            // If in S203
            if (inS203) {
                // Check door zone - push away if too close
                if (isInDoorZone(x, z, s203Door)) {
                    // Push south away from door
                    const safeZ = s203Door.maxZ + 0.4;
                    if (safeZ <= s203Front) {
                        return new THREE.Vector3(x, 0, safeZ);
                    }
                    // Can't place here at all
                    console.warn('REJECTED: Too close to S203 door');
                    return null;
                }
                return new THREE.Vector3(x, 0, z);
            }

            // Should never reach here, but safety fallback
            return null;
        }

        // Check if a new placement would be valid (no collisions)
        function wouldCollideWithExisting(newPosition, newAssetId, excludeItem = null) {
            const asset = ASSET_WHITELIST[newAssetId];
            if (!asset) return false; // Unknown asset, allow placement

            // Create temporary placement to check
            const tempPlacement = {
                assetId: newAssetId,
                roomId: getObjectRoom({ position: newPosition }) || 'S203',
                x: newPosition.x,
                z: newPosition.z,
                rotation: 0
            };

            const newAABB = getAABBWithClearance(tempPlacement);
            if (!newAABB) return false;

            // Check against all existing placed items
            for (const item of placedItems) {
                if (item === excludeItem) continue;

                const itemAssetId = item.userData.assetId || 'unknown';
                const itemPlacement = objectToPlacement(item, itemAssetId, getObjectRoom(item) || 'S203');
                const existingAABB = getAABBWithClearance(itemPlacement);

                if (existingAABB && aabbsOverlap(newAABB, existingAABB)) {
                    console.log(`Collision detected: ${newAssetId} would collide with ${itemAssetId}`);
                    return true;
                }
            }

            return false;
        }

        // Visual feedback for invalid placement
        let invalidPlacementTimeout = null;
        function showInvalidPlacementFeedback(position) {
            // Create a red indicator at the position
            const indicator = new THREE.Mesh(
                new THREE.RingGeometry(0.3, 0.5, 16),
                new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.5 })
            );
            indicator.rotation.x = -Math.PI / 2;
            indicator.position.set(position.x, 0.01, position.z);
            scene.add(indicator);

            // Remove after 1 second
            setTimeout(() => {
                scene.remove(indicator);
            }, 1000);
        }

        window.moveItem = function(dx, dz) {
            if (selectedPlacedItem) {
                const newPos = selectedPlacedItem.position.clone();
                newPos.x += dx;
                newPos.z += dz;
                const constrained = constrainToRoom(newPos);
                if (constrained) {
                    selectedPlacedItem.position.x = constrained.x;
                    selectedPlacedItem.position.z = constrained.z;
                    selectedPlacedItem.position.y = 0; // Snap to floor
                }
            }
        };

        window.rotateItem = function(degrees) {
            if (selectedPlacedItem) {
                selectedPlacedItem.rotation.y += degrees * Math.PI / 180;
            }
        };

        window.deleteItem = function() {
            if (selectedPlacedItem) {
                if (transformControls) transformControls.detach();
                scene.remove(selectedPlacedItem);
                placedItems = placedItems.filter(i => i !== selectedPlacedItem);
                selectedPlacedItem = null;
                updateSelectedInfo();
            }
        };

        // Keyboard shortcuts for transform modes (when decorator mode active)
        document.addEventListener('keydown', (e) => {
            if (!decoratorMode || !transformControls) return;

            switch(e.key.toLowerCase()) {
                case 'g': // Grab/translate mode
                case 't':
                    transformControls.setMode('translate');
                    break;
                case 'r': // Rotate mode
                    transformControls.setMode('rotate');
                    break;
                case 'delete':
                case 'backspace':
                    if (selectedPlacedItem) {
                        e.preventDefault();
                        deleteItem();
                    }
                    break;
                case 'escape':
                    deselectAll();
                    break;
            }
        });

        window.saveLayout = async function() {
            const layout = placedItems.map(item => ({
                type: item.userData.itemType,
                position: { x: item.position.x, y: item.position.y, z: item.position.z },
                rotation: { y: item.rotation.y }
            }));

            // Save to localStorage as backup
            localStorage.setItem('panafricanLibraryLayout', JSON.stringify(layout));

            // Also save to Vercel Blob for persistent shared storage
            try {
                const response = await fetch('/api/layout', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(layout)
                });
                const result = await response.json();
                if (result.success) {
                    alert('Layout saved! This layout will be visible to all visitors.');
                } else {
                    alert('Layout saved locally. Cloud sync failed: ' + (result.error || 'Unknown error'));
                }
            } catch (err) {
                console.error('Cloud save error:', err);
                alert('Layout saved locally. Cloud sync unavailable.');
            }
        };

        window.loadLayout = async function() {
            try {
                // First try to load from Vercel Blob (shared layout)
                const response = await fetch('/api/layout');
                const result = await response.json();

                if (result.success && result.layout && result.layout.length > 0) {
                    applyLayout(result.layout);
                    alert('Shared layout loaded from cloud!');
                    return;
                }
            } catch (err) {
                console.error('Cloud load error:', err);
            }

            // Fallback to localStorage
            const saved = localStorage.getItem('panafricanLibraryLayout');
            if (saved) {
                const layout = JSON.parse(saved);
                applyLayout(layout);
                alert('Layout loaded from local storage.');
            } else {
                alert('No saved layout found.');
            }
        };

        function applyLayout(layout) {
            // Clear existing placed items
            placedItems.forEach(item => scene.remove(item));
            placedItems = [];
            // Recreate items
            layout.forEach(data => {
                const item = createFurnitureItem(data.type);
                item.position.set(data.position.x, data.position.y, data.position.z);
                item.rotation.y = data.rotation.y;
                scene.add(item);
                placedItems.push(item);
            });
        }

        // Auto-load shared layout on page load
        async function autoLoadLayout() {
            try {
                const response = await fetch('/api/layout');
                const result = await response.json();

                if (result.success && result.layout && result.layout.length > 0) {
                    applyLayout(result.layout);
                    console.log('Auto-loaded shared layout from cloud');
                }
            } catch (err) {
                // Silently fail - just use empty layout
                console.log('No shared layout available');
            }
        }

        // Call autoLoadLayout after scene is ready
        setTimeout(autoLoadLayout, 1000);

        window.resetLayout = function() {
            if (confirm('Reset to default layout? This will remove all placed items.')) {
                placedItems.forEach(item => scene.remove(item));
                placedItems = [];
                deselectAll();
            }
        };

        window.exportLayout = function() {
            const layout = placedItems.map(item => ({
                type: item.userData.itemType,
                position: { x: item.position.x, y: item.position.y, z: item.position.z },
                rotation: { y: item.rotation.y }
            }));
            const blob = new Blob([JSON.stringify(layout, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'panafrican-library-layout.json';
            a.click();
        };

        // Wall visibility based on camera position
        function updateWallVisibility() {
            if (!hideNearWall) {
                // Show all walls
                Object.values(roomS202Walls).forEach(w => { if (w) w.visible = true; });
                Object.values(roomS203Walls).forEach(w => { if (w) w.visible = true; });
                return;
            }

            // Determine which wall is closest to camera
            const camX = camera.position.x;
            const camZ = camera.position.z;

            // Room S202 walls
            // FRONT wall (windows) - hide when camera is in front (positive Z)
            if (roomS202Walls.front) roomS202Walls.front.visible = camZ < ROOM_S202_DEPTH / 4;

            // BACK wall (corridor entry) - hide when camera is behind (negative Z)
            // Also hide entire vestibule (all corridor walls) when hiding back area
            const hideBackArea = camZ < -ROOM_S202_DEPTH / 4;
            if (roomS202Walls.back) roomS202Walls.back.visible = !hideBackArea;
            if (roomS202Walls.vestibuleGroup) roomS202Walls.vestibuleGroup.visible = !hideBackArea;

            // LEFT wall (Three Star door) - hide when camera is to the left
            if (roomS202Walls.left) roomS202Walls.left.visible = camX > ROOM_S202_X - ROOM_S202_WIDTH / 2;

            // RIGHT wall (solid shared wall with S203) - hide when camera is to the right
            if (roomS202Walls.right) roomS202Walls.right.visible = camX < ROOM_S202_X + ROOM_S202_WIDTH / 2;

            // Room S203 walls
            // FRONT wall (windows) - hide when camera is in front
            if (roomS203Walls.front) roomS203Walls.front.visible = camZ < ROOM_S203_DEPTH / 4;

            // BACK wall (corridor entry + poster wall) - hide when camera is behind
            if (roomS203Walls.back) roomS203Walls.back.visible = camZ > -ROOM_S203_DEPTH / 4;

            // LEFT wall (SHARED MIDDLE WALL with S202) - ALWAYS VISIBLE
            // This is the dividing wall between the two rooms, never hide it
            if (roomS203Walls.left) roomS203Walls.left.visible = true;

            // RIGHT wall (solid exterior) - hide when camera is to the right
            if (roomS203Walls.right) roomS203Walls.right.visible = camX < ROOM_S203_X + ROOM_S203_WIDTH / 2;
        }

        // Auto ceiling visibility based on camera height
        function updateCeilingVisibility() {
            const camY = camera.position.y;
            const isAbove = camY > CEILING_HEIGHT + 1;

            if (showCeiling) {
                // Auto-hide ceiling when viewing from above
                scene.traverse((obj) => {
                    if (obj.userData.isCeiling) {
                        obj.visible = !isAbove;
                    }
                });
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            currentRotationX += (targetRotationX - currentRotationX) * 0.05;
            currentRotationY += (targetRotationY - currentRotationY) * 0.05;

            if (keys['w']) cameraTarget.z -= 0.1;
            if (keys['s']) cameraTarget.z += 0.1;
            if (keys['a']) cameraTarget.x -= 0.1;
            if (keys['d']) cameraTarget.x += 0.1;

            camera.position.x = cameraTarget.x + Math.sin(currentRotationX) * Math.cos(currentRotationY) * cameraDistance;
            camera.position.y = cameraTarget.y + Math.sin(currentRotationY) * cameraDistance;
            camera.position.z = cameraTarget.z + Math.cos(currentRotationX) * Math.cos(currentRotationY) * cameraDistance;
            camera.lookAt(cameraTarget);

            updateWallVisibility();
            updateCeilingVisibility();

            renderer.render(scene, camera);
        }
        animate();

        // Initialize transform controls for visual editing gizmos
        initTransformControls();

        // Initialize drag-drop systems
        setupCanvasDragDrop();
        setupLibraryDragDrop();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ========== ADMIN SYSTEM ==========
        let adminUser = null;
        let adminToken = null;
        let selectedRenderStyle = 'photorealistic';

        // Check for saved admin session
        const savedAdmin = localStorage.getItem('panafricanAdmin');
        if (savedAdmin) {
            try {
                const data = JSON.parse(savedAdmin);
                adminUser = data.email;
                adminToken = data.token;
                document.getElementById('admin-btn').classList.add('logged-in');
                document.getElementById('admin-btn').textContent = 'ğŸ‘¤ ' + (data.name || 'Admin');
            } catch(e) {}
        }

        window.toggleAdminLogin = function() {
            if (adminUser) {
                toggleAdminPanel();
            } else {
                document.getElementById('login-modal').classList.add('visible');
                document.getElementById('login-email').focus();
            }
        };

        window.closeLoginModal = function() {
            document.getElementById('login-modal').classList.remove('visible');
            document.getElementById('login-email').value = '';
            document.getElementById('login-error').textContent = '';
        };

        window.attemptLogin = async function() {
            const email = document.getElementById('login-email').value.trim();
            if (!email) {
                document.getElementById('login-error').textContent = 'Please enter your email';
                return;
            }

            try {
                const response = await fetch('/api/auth', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ email })
                });
                const result = await response.json();

                if (result.success && result.isAdmin) {
                    adminUser = result.email;
                    adminToken = result.token;
                    localStorage.setItem('panafricanAdmin', JSON.stringify({
                        email: result.email,
                        token: result.token,
                        name: result.name
                    }));
                    document.getElementById('admin-btn').classList.add('logged-in');
                    document.getElementById('admin-btn').textContent = 'ğŸ‘¤ ' + result.name;
                    document.getElementById('admin-user-name').textContent = 'Logged in as: ' + result.name;
                    closeLoginModal();
                    toggleAdminPanel();
                    loadAdminConfigs();
                } else {
                    document.getElementById('login-error').textContent = 'Not an authorized admin email';
                }
            } catch (err) {
                document.getElementById('login-error').textContent = 'Login failed: ' + err.message;
            }
        };

        window.logoutAdmin = function() {
            adminUser = null;
            adminToken = null;
            localStorage.removeItem('panafricanAdmin');
            document.getElementById('admin-btn').classList.remove('logged-in');
            document.getElementById('admin-btn').textContent = 'ğŸ” Admin';
            document.getElementById('admin-panel').classList.remove('open');
        };

        window.toggleAdminPanel = function() {
            if (!adminUser) {
                toggleAdminLogin();
                return;
            }
            const panel = document.getElementById('admin-panel');
            panel.classList.toggle('open');
            if (panel.classList.contains('open')) {
                loadAdminConfigs();
                updateCameraPositionDisplay();
            }
        };

        window.switchAdminTab = function(tab) {
            document.querySelectorAll('.admin-tab').forEach(t => t.classList.remove('active'));
            event.currentTarget.classList.add('active');
            document.querySelectorAll('.admin-content').forEach(c => c.style.display = 'none');
            document.getElementById('admin-tab-' + tab).style.display = 'block';
        };

        function updateCameraPositionDisplay() {
            const display = document.getElementById('camera-position-display');
            if (display) {
                display.innerHTML = `Position: (${camera.position.x.toFixed(2)}, ${camera.position.y.toFixed(2)}, ${camera.position.z.toFixed(2)})<br>Target: (${cameraTarget.x.toFixed(2)}, ${cameraTarget.y.toFixed(2)}, ${cameraTarget.z.toFixed(2)})<br>Distance: ${cameraDistance.toFixed(2)} | RotX: ${currentRotationX.toFixed(2)} | RotY: ${currentRotationY.toFixed(2)}`;
            }
        }

        setInterval(() => {
            if (document.getElementById('admin-panel').classList.contains('open')) {
                updateCameraPositionDisplay();
            }
        }, 500);

        async function loadAdminConfigs() {
            try {
                const layoutRes = await fetch('/api/config?type=layout');
                const layoutData = await layoutRes.json();
                renderConfigList('saved-layouts-list', layoutData.configs || [], 'layout');
            } catch (e) {
                document.getElementById('saved-layouts-list').innerHTML = '<div style="color:#666;font-size:12px;padding:10px;">Failed to load</div>';
            }
            try {
                const viewRes = await fetch('/api/config?type=view');
                const viewData = await viewRes.json();
                renderConfigList('saved-views-list', viewData.configs || [], 'view');
            } catch (e) {
                document.getElementById('saved-views-list').innerHTML = '<div style="color:#666;font-size:12px;padding:10px;">Failed to load</div>';
            }
            try {
                const moodRes = await fetch('/api/config?type=mood');
                const moodData = await moodRes.json();
                renderConfigList('saved-mood-list', moodData.configs || [], 'mood');
            } catch (e) {
                document.getElementById('saved-mood-list').innerHTML = '<div style="color:#666;font-size:12px;padding:10px;">Failed to load</div>';
            }
        }

        function renderConfigList(containerId, configs, type) {
            const container = document.getElementById(containerId);
            if (configs.length === 0) {
                container.innerHTML = '<div style="color:#666;font-size:12px;padding:10px;">No saved ' + type + 's yet</div>';
                return;
            }
            container.innerHTML = configs.map(cfg => `
                <div class="saved-config-item">
                    <div>
                        <div class="saved-config-name">${cfg.name}</div>
                        <div class="saved-config-meta">By ${cfg.author} â€¢ ${new Date(cfg.createdAt).toLocaleDateString()}</div>
                    </div>
                    <div class="saved-config-actions">
                        <button class="saved-config-btn" onclick="loadConfig('${type}', '${cfg.name}')">Load</button>
                        <button class="saved-config-btn danger" onclick="deleteConfig('${type}', '${cfg.name}')">âœ•</button>
                    </div>
                </div>
            `).join('');
        }

        // ============ LOCAL STORAGE BASED CONFIG MANAGEMENT ============
        // Fallback to localStorage when API is unavailable

        let savedLayouts = JSON.parse(localStorage.getItem('savedLayouts')) || [];
        let savedViews = JSON.parse(localStorage.getItem('savedViews')) || [];
        let draggedConfigIndex = null;
        let draggedConfigType = null;

        function saveLayoutsToStorage() {
            localStorage.setItem('savedLayouts', JSON.stringify(savedLayouts));
        }

        function saveViewsToStorage() {
            localStorage.setItem('savedViews', JSON.stringify(savedViews));
        }

        window.saveAdminLayout = function() {
            const name = document.getElementById('layout-name').value.trim();
            const description = document.getElementById('layout-description')?.value.trim() || '';
            if (!name) { alert('Please enter a layout name'); return; }

            const layout = placedItems.map(item => ({
                type: item.userData.itemType,
                position: { x: item.position.x, y: item.position.y, z: item.position.z },
                rotation: { y: item.rotation.y }
            }));

            const layoutEntry = {
                id: Date.now(),
                name: name,
                description: description,
                data: layout,
                author: adminUser || 'Admin',
                createdAt: new Date().toISOString()
            };

            savedLayouts.push(layoutEntry);
            saveLayoutsToStorage();

            document.getElementById('layout-name').value = '';
            if (document.getElementById('layout-description')) {
                document.getElementById('layout-description').value = '';
            }

            renderLayoutsList();
            alert('Layout saved!');
        };

        window.saveAdminView = function() {
            const name = document.getElementById('view-name').value.trim();
            const description = document.getElementById('view-description').value.trim();
            if (!name) { alert('Please enter a view name'); return; }

            const viewEntry = {
                id: Date.now(),
                name: name,
                description: description,
                data: {
                    position: { x: camera.position.x, y: camera.position.y, z: camera.position.z },
                    target: { x: cameraTarget.x, y: cameraTarget.y, z: cameraTarget.z },
                    distance: cameraDistance,
                    rotationX: currentRotationX,
                    rotationY: currentRotationY
                },
                author: adminUser || 'Admin',
                createdAt: new Date().toISOString()
            };

            savedViews.push(viewEntry);
            saveViewsToStorage();

            document.getElementById('view-name').value = '';
            document.getElementById('view-description').value = '';

            renderViewsList();
            alert('View saved!');
        };

        window.loadLayout = function(index) {
            const layout = savedLayouts[index];
            if (layout && layout.data) {
                applyLayout(layout.data);
                alert(`Layout "${layout.name}" loaded!`);
            }
        };

        window.loadView = function(index) {
            const view = savedViews[index];
            if (view && view.data) {
                const data = view.data;
                cameraTarget.set(data.target.x, data.target.y, data.target.z);
                cameraDistance = data.distance;
                targetRotationX = data.rotationX;
                targetRotationY = data.rotationY;
                currentRotationX = data.rotationX;
                currentRotationY = data.rotationY;
                alert(`View "${view.name}" applied!`);
            }
        };

        window.deleteLayout = function(index, event) {
            event.stopPropagation();
            const layout = savedLayouts[index];
            if (confirm(`Delete layout "${layout.name}"?`)) {
                savedLayouts.splice(index, 1);
                saveLayoutsToStorage();
                renderLayoutsList();
            }
        };

        window.deleteView = function(index, event) {
            event.stopPropagation();
            const view = savedViews[index];
            if (confirm(`Delete view "${view.name}"?`)) {
                savedViews.splice(index, 1);
                saveViewsToStorage();
                renderViewsList();
            }
        };

        window.editLayout = function(index, event) {
            event.stopPropagation();
            const layout = savedLayouts[index];
            const newName = prompt('Edit layout name:', layout.name);
            if (newName && newName.trim()) {
                const newDesc = prompt('Edit description:', layout.description || '');
                savedLayouts[index].name = newName.trim();
                savedLayouts[index].description = newDesc || '';
                saveLayoutsToStorage();
                renderLayoutsList();
            }
        };

        window.editView = function(index, event) {
            event.stopPropagation();
            const view = savedViews[index];
            const newName = prompt('Edit view name:', view.name);
            if (newName && newName.trim()) {
                const newDesc = prompt('Edit description:', view.description || '');
                savedViews[index].name = newName.trim();
                savedViews[index].description = newDesc || '';
                saveViewsToStorage();
                renderViewsList();
            }
        };

        window.updateViewPosition = function(index, event) {
            event.stopPropagation();
            const view = savedViews[index];
            if (confirm(`Update "${view.name}" with current camera position?`)) {
                savedViews[index].data = {
                    position: { x: camera.position.x, y: camera.position.y, z: camera.position.z },
                    target: { x: cameraTarget.x, y: cameraTarget.y, z: cameraTarget.z },
                    distance: cameraDistance,
                    rotationX: currentRotationX,
                    rotationY: currentRotationY
                };
                saveViewsToStorage();
                renderViewsList();
                alert('View position updated!');
            }
        };

        function renderLayoutsList() {
            const container = document.getElementById('saved-layouts-list');
            const countEl = document.getElementById('layouts-count');
            if (countEl) countEl.textContent = `(${savedLayouts.length})`;

            if (savedLayouts.length === 0) {
                container.innerHTML = '<div style="color: #666; font-size: 12px; padding: 10px;">No layouts saved yet</div>';
                return;
            }

            container.innerHTML = savedLayouts.map((layout, idx) => `
                <div class="saved-config-item" draggable="true" data-index="${idx}" data-type="layout"
                     onclick="loadLayout(${idx})">
                    <div class="saved-config-info">
                        <div class="saved-config-name">${layout.name}</div>
                        <div class="saved-config-meta">${layout.description || ''} â€¢ ${new Date(layout.createdAt).toLocaleDateString()}</div>
                    </div>
                    <div class="saved-config-actions">
                        <button class="saved-config-btn move" title="Drag to reorder">â‹®â‹®</button>
                        <button class="saved-config-btn edit" onclick="editLayout(${idx}, event)" title="Edit">âœï¸</button>
                        <button class="saved-config-btn danger" onclick="deleteLayout(${idx}, event)" title="Delete">âœ•</button>
                    </div>
                </div>
            `).join('');

            setupConfigDragDrop('layout');
        }

        function renderViewsList() {
            const container = document.getElementById('saved-views-list');
            const countEl = document.getElementById('views-count');
            if (countEl) countEl.textContent = `(${savedViews.length})`;

            if (savedViews.length === 0) {
                container.innerHTML = '<div style="color: #666; font-size: 12px; padding: 10px;">No views saved yet</div>';
                return;
            }

            container.innerHTML = savedViews.map((view, idx) => `
                <div class="saved-config-item" draggable="true" data-index="${idx}" data-type="view"
                     onclick="loadView(${idx})">
                    <div class="saved-config-info">
                        <div class="saved-config-name">${view.name}</div>
                        <div class="saved-config-meta">${view.description || ''} â€¢ ${new Date(view.createdAt).toLocaleDateString()}</div>
                    </div>
                    <div class="saved-config-actions">
                        <button class="saved-config-btn move" title="Drag to reorder">â‹®â‹®</button>
                        <button class="saved-config-btn" onclick="updateViewPosition(${idx}, event)" title="Update to current">ğŸ“</button>
                        <button class="saved-config-btn edit" onclick="editView(${idx}, event)" title="Edit">âœï¸</button>
                        <button class="saved-config-btn danger" onclick="deleteView(${idx}, event)" title="Delete">âœ•</button>
                    </div>
                </div>
            `).join('');

            setupConfigDragDrop('view');
        }

        function setupConfigDragDrop(type) {
            const container = document.getElementById(type === 'layout' ? 'saved-layouts-list' : 'saved-views-list');
            const items = container.querySelectorAll('.saved-config-item');

            items.forEach(item => {
                item.addEventListener('dragstart', (e) => {
                    draggedConfigIndex = parseInt(item.dataset.index);
                    draggedConfigType = type;
                    item.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                });

                item.addEventListener('dragend', () => {
                    item.classList.remove('dragging');
                    draggedConfigIndex = null;
                    draggedConfigType = null;
                    items.forEach(i => i.classList.remove('drag-over'));
                });

                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    items.forEach(i => i.classList.remove('drag-over'));
                    item.classList.add('drag-over');
                });

                item.addEventListener('drop', (e) => {
                    e.preventDefault();
                    const targetIndex = parseInt(item.dataset.index);
                    if (draggedConfigIndex !== null && draggedConfigIndex !== targetIndex && draggedConfigType === type) {
                        reorderConfig(type, draggedConfigIndex, targetIndex);
                    }
                    items.forEach(i => i.classList.remove('drag-over'));
                });
            });
        }

        function reorderConfig(type, fromIndex, toIndex) {
            const arr = type === 'layout' ? savedLayouts : savedViews;
            const item = arr.splice(fromIndex, 1)[0];
            arr.splice(toIndex, 0, item);

            if (type === 'layout') {
                saveLayoutsToStorage();
                renderLayoutsList();
            } else {
                saveViewsToStorage();
                renderViewsList();
            }
        }

        window.exportLayoutFile = function() {
            const layout = placedItems.map(item => ({
                type: item.userData.itemType,
                position: { x: item.position.x, y: item.position.y, z: item.position.z },
                rotation: { y: item.rotation.y }
            }));
            const blob = new Blob([JSON.stringify(layout, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'panafrican-library-layout-' + new Date().toISOString().slice(0,10) + '.json';
            a.click();
        };

        window.importLayoutFile = function() {
            document.getElementById('import-layout-input').click();
        };

        window.handleLayoutImport = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    if (Array.isArray(data)) {
                        const name = prompt('Name for imported layout:', file.name.replace('.json', ''));
                        if (name) {
                            savedLayouts.push({
                                id: Date.now(),
                                name: name,
                                description: 'Imported from file',
                                data: data,
                                author: adminUser || 'Admin',
                                createdAt: new Date().toISOString()
                            });
                            saveLayoutsToStorage();
                            renderLayoutsList();
                            alert('Layout imported successfully!');
                        }
                    } else {
                        alert('Invalid layout file format');
                    }
                } catch (err) {
                    alert('Failed to parse layout file: ' + err.message);
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Reset file input
        };

        window.updateCameraDisplay = function() {
            const display = document.getElementById('camera-position-display');
            if (display) {
                display.innerHTML = `
                    Position: (${camera.position.x.toFixed(2)}, ${camera.position.y.toFixed(2)}, ${camera.position.z.toFixed(2)})<br>
                    Target: (${cameraTarget.x.toFixed(2)}, ${cameraTarget.y.toFixed(2)}, ${cameraTarget.z.toFixed(2)})<br>
                    Distance: ${cameraDistance.toFixed(2)}<br>
                    RotX: ${currentRotationX.toFixed(3)} | RotY: ${currentRotationY.toFixed(3)}
                `;
            }
        };

        // Initialize lists on admin panel open
        function initAdminLists() {
            renderLayoutsList();
            renderViewsList();
            updateCameraDisplay();
        }

        window.saveMoodEntry = async function() {
            const title = document.getElementById('mood-title').value.trim();
            const imageUrl = document.getElementById('mood-image-url').value.trim();
            const description = document.getElementById('mood-description').value.trim();
            const category = document.getElementById('mood-category').value;
            if (!title || !imageUrl) { alert('Please enter a title and image URL'); return; }

            // Add to moodboard images array
            moodboardImages.push({
                src: imageUrl,
                title: title + (description ? ' - ' + description : ''),
                category: category
            });
            saveMoodboardImages();

            document.getElementById('mood-title').value = '';
            document.getElementById('mood-image-url').value = '';
            document.getElementById('mood-description').value = '';

            alert('Added to mood board!');
        };

        // ========== AI RENDER SYSTEM ==========
        let capturedImageData = null;

        window.openRenderModal = function() {
            document.getElementById('render-modal').classList.add('visible');
            captureForRender();
        };

        window.closeRenderModal = function() {
            document.getElementById('render-modal').classList.remove('visible');
            capturedImageData = null;
        };

        window.selectRenderStyle = function(style, btn) {
            selectedRenderStyle = style;
            document.querySelectorAll('.render-style-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
        };

        function captureForRender() {
            renderer.render(scene, camera);
            const dataURL = renderer.domElement.toDataURL('image/png');
            capturedImageData = dataURL;
            document.getElementById('render-input-preview').innerHTML = `<img src="${dataURL}" alt="3D Scene">`;
        }

        window.generateRender = async function() {
            if (!capturedImageData) { alert('Please wait for capture'); return; }
            const btn = document.getElementById('generate-render-btn');
            const status = document.getElementById('render-status');
            const statusText = document.getElementById('render-status-text');
            const outputPreview = document.getElementById('render-output-preview');

            btn.disabled = true;
            status.style.display = 'block';
            statusText.textContent = 'Generating photorealistic render... This may take 10-30 seconds';
            outputPreview.innerHTML = '<span class="render-spinner"></span>';

            try {
                const customPrompt = document.getElementById('render-custom-prompt').value.trim();
                const response = await fetch('/api/render', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        imageBase64: capturedImageData,
                        style: selectedRenderStyle,
                        prompt: customPrompt
                    })
                });
                const result = await response.json();
                if (result.success && result.image) {
                    outputPreview.innerHTML = `<img src="${result.image}" alt="AI Render">`;
                    statusText.textContent = 'Render complete!';
                    setTimeout(() => {
                        status.innerHTML = `
                            <button class="admin-btn admin-btn-success" onclick="downloadRender()">ğŸ’¾ Download Render</button>
                            <button class="admin-btn admin-btn-secondary" onclick="captureForRender()">ğŸ”„ Capture New View</button>
                        `;
                    }, 1000);
                    window.lastRenderImage = result.image;
                } else {
                    throw new Error(result.error || result.text || 'Unknown error');
                }
            } catch (err) {
                statusText.textContent = 'Error: ' + err.message;
                outputPreview.innerHTML = 'Generation failed';
            } finally {
                btn.disabled = false;
            }
        };

        window.downloadRender = function() {
            if (!window.lastRenderImage) return;
            const a = document.createElement('a');
            a.href = window.lastRenderImage;
            a.download = 'panafrican-library-render-' + selectedRenderStyle + '-' + new Date().toISOString().slice(0,19).replace(/:/g, '-') + '.png';
            a.click();
        };

    </script>
</body>
</html>
