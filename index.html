<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Panafrican Library Will Not Be Colonized | Reading Room 3D</title>
    <meta name="description" content="A curatorial Reading Room conceived as a living archive of panafrican and diasporic publishing. Interactive 3D simulation.">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background: #1a1a1a;
            color: #fff;
            overflow: hidden;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px;
            border-radius: 8px;
            max-width: 320px;
            z-index: 100;
            border: 1px solid rgba(255,255,255,0.1);
        }
        /* Mobile responsive styles */
        @media (max-width: 768px) {
            #info-panel {
                top: 10px;
                left: 10px;
                right: 10px;
                max-width: none;
                padding: 12px;
            }
            #info-panel h1 { font-size: 14px; }
            #info-panel h2 { font-size: 9px; margin-bottom: 10px; }
            #info-panel p { font-size: 11px; margin-bottom: 10px; }
            .room-btn { padding: 6px 10px; font-size: 10px; }
            .room-desc { font-size: 10px; padding: 6px 8px; }
            .room-desc strong { font-size: 11px; }
            #controls-panel {
                top: auto;
                bottom: 180px;
                right: 10px;
                left: 10px;
                max-height: 40vh;
                display: flex;
                flex-wrap: wrap;
                gap: 5px;
                padding: 10px;
            }
            .control-section {
                flex: 1 1 45%;
                min-width: 140px;
                margin-bottom: 5px;
                padding-bottom: 5px;
            }
            .control-btn { padding: 6px 8px; font-size: 10px; }
            .section-title { font-size: 9px; margin-bottom: 5px; }
            #dimensions-panel { display: none; }
            #credits {
                bottom: 10px;
                right: 10px;
                left: auto;
                padding: 8px 10px;
                font-size: 8px;
            }
            #help-text {
                bottom: 150px;
                font-size: 10px;
                padding: 6px 12px;
            }
            #toggle-btns {
                bottom: 100px;
                padding: 0 10px;
            }
            .toggle-btn { padding: 5px 8px; font-size: 9px; }
            #capture-btn {
                bottom: 60px;
                padding: 8px 15px;
                font-size: 11px;
            }
        }
        @media (max-width: 480px) {
            #info-panel {
                padding: 10px;
            }
            #info-panel h1 { font-size: 12px; }
            #info-panel p { display: none; }
            .room-descriptions { display: none; }
            #controls-panel {
                max-height: 35vh;
            }
            .control-section { flex: 1 1 100%; }
            #credits { display: none; }
        }
        #info-panel h1 {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        #info-panel h2 {
            font-size: 11px;
            font-weight: 400;
            color: #888;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        #info-panel p {
            font-size: 13px;
            line-height: 1.6;
            color: #ccc;
            margin-bottom: 15px;
        }
        .room-btn {
            display: inline-block;
            padding: 8px 14px;
            margin: 4px 4px 4px 0;
            background: rgba(100, 149, 237, 0.3);
            border: 1px solid cornflowerblue;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }
        .room-btn:hover {
            background: cornflowerblue;
        }
        .room-buttons {
            margin-bottom: 12px;
        }
        .room-descriptions {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .room-desc {
            font-size: 11px;
            line-height: 1.5;
            color: #aaa;
            padding: 8px 10px;
            background: rgba(255,255,255,0.05);
            border-radius: 4px;
            border-left: 3px solid cornflowerblue;
        }
        .room-desc strong {
            color: cornflowerblue;
            font-size: 12px;
        }
        #controls-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            border: 1px solid rgba(255,255,255,0.1);
            max-height: 80vh;
            overflow-y: auto;
        }
        .control-section {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .control-section:last-child { border-bottom: none; }
        .section-title {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }
        .control-btn {
            display: block;
            width: 100%;
            padding: 8px 12px;
            margin: 4px 0;
            background: rgba(255,255,255,0.1);
            border: none;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            text-align: left;
            transition: all 0.3s;
        }
        .control-btn:hover {
            background: rgba(255,255,255,0.2);
        }
        .control-btn.active {
            background: rgba(100, 149, 237, 0.4);
            border: 1px solid cornflowerblue;
        }
        #dimensions-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.85);
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            border: 1px solid rgba(255,255,255,0.1);
            font-size: 11px;
            max-width: 420px;
        }
        #dimensions-panel h3 {
            font-size: 12px;
            margin-bottom: 10px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .dim-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .dim-row:last-child { border-bottom: none; }
        .dim-label { color: #888; }
        .dim-value { color: #fff; font-family: monospace; }
        #credits {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 12px 15px;
            border-radius: 8px;
            z-index: 100;
            border: 1px solid rgba(255,255,255,0.1);
            font-size: 10px;
            text-align: right;
        }
        #credits a { color: cornflowerblue; text-decoration: none; }
        #credits a:hover { text-decoration: underline; }
        #help-text {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 12px;
            color: #888;
            z-index: 100;
        }
        #toggle-btns {
            position: absolute;
            bottom: 130px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
            z-index: 100;
            max-width: 500px;
        }
        .toggle-btn {
            padding: 6px 12px;
            background: rgba(0,0,0,0.7);
            border: 1px solid rgba(255,255,255,0.2);
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }
        .toggle-btn.active {
            background: rgba(100, 149, 237, 0.5);
            border-color: cornflowerblue;
        }
        #capture-btn {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background: cornflowerblue;
            border: none;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            z-index: 100;
        }
        .icon { margin-right: 6px; }
        #moodboard-btn {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(calc(-50% - 70px));
            padding: 10px 20px;
            background: #8b2942;
            border: none;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            z-index: 100;
        }
        #moodboard-btn:hover { background: #a03050; }
        #capture-btn { transform: translateX(calc(-50% - 210px)); }
        .modal-hidden { display: none; }
        #moodboard-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 1000;
            overflow-y: auto;
            padding: 40px 20px;
        }
        .modal-content {
            max-width: 900px;
            margin: 0 auto;
            background: #1a1a1a;
            border-radius: 12px;
            padding: 30px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .modal-close {
            position: absolute;
            top: 20px;
            right: 30px;
            background: none;
            border: none;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
        }
        .modal-content h2 {
            font-size: 24px;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        .modal-content > p {
            color: #888;
            margin-bottom: 25px;
            font-size: 14px;
        }
        .moodboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }
        .moodboard-section {
            background: rgba(255,255,255,0.05);
            padding: 20px;
            border-radius: 8px;
        }
        .moodboard-section h3 {
            font-size: 14px;
            color: cornflowerblue;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .image-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        .ref-image {
            aspect-ratio: 4/3;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .ref-image span {
            background: rgba(0,0,0,0.6);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 11px;
        }
        .color-palette {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .color-swatch {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .color-swatch:hover { transform: scale(1.1); }
        .color-swatch.editing { position: relative; }
        .color-swatch.editing::after {
            content: '‚úï';
            position: absolute;
            top: -6px;
            right: -6px;
            width: 16px;
            height: 16px;
            background: #c41e3a;
            color: #fff;
            border-radius: 50%;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }
        .section-edit-btn {
            background: none;
            border: 1px solid #444;
            color: #888;
            padding: 2px 6px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            margin-left: 8px;
            vertical-align: middle;
        }
        .section-edit-btn:hover, .section-edit-btn.active { background: rgba(255,255,255,0.1); color: #fff; }
        .color-add-form, .pattern-add-form, .furniture-add-form, .functions-add-form {
            display: flex;
            gap: 6px;
            align-items: center;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        .editable-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 0;
        }
        .editable-item .remove-btn {
            background: #c41e3a;
            border: none;
            color: #fff;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 10px;
            display: none;
            align-items: center;
            justify-content: center;
        }
        .editable-item.editing .remove-btn { display: flex; }
        .editable-item .edit-input {
            background: #1a1a1a;
            border: 1px solid #444;
            color: #fff;
            padding: 4px 8px;
            font-size: 11px;
            border-radius: 3px;
            flex: 1;
        }
        .pattern-swatch {
            position: relative;
            cursor: grab;
            transition: transform 0.15s, box-shadow 0.15s;
            border: 2px solid transparent;
        }
        .pattern-swatch:hover {
            transform: scale(1.1);
            box-shadow: 0 2px 8px rgba(255,215,0,0.4);
            border-color: #ffd700;
        }
        .pattern-swatch:active {
            cursor: grabbing;
        }
        .pattern-swatch.editing::after {
            content: '‚úï';
            position: absolute;
            top: -6px;
            right: -6px;
            width: 16px;
            height: 16px;
            background: #c41e3a;
            color: #fff;
            border-radius: 50%;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }
        .mini-pattern {
            transition: transform 0.1s;
            border: 1px solid #333;
        }
        .mini-pattern:hover {
            transform: scale(1.15);
            border-color: #ffd700;
        }
        #texture-panel {
            border: 1px solid #333;
        }
        #texture-panel h5 {
            border-bottom: 1px solid #333;
            padding-bottom: 6px;
        }
        .design-list {
            list-style: none;
            font-size: 13px;
            line-height: 2;
        }
        .layout-info p {
            font-size: 12px;
            line-height: 1.8;
            color: #ccc;
            margin-bottom: 10px;
        }
        /* Mood Board Image Gallery */
        .moodboard-images {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        .moodboard-image-item {
            position: relative;
            border-radius: 6px;
            overflow: hidden;
            cursor: pointer;
            aspect-ratio: 4/3;
            background: #333;
        }
        .moodboard-image-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.3s, opacity 0.3s;
        }
        .moodboard-image-item:hover img {
            transform: scale(1.05);
        }
        .moodboard-image-item .image-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0,0,0,0.8));
            padding: 20px 8px 8px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .moodboard-image-item:hover .image-overlay {
            opacity: 1;
        }
        .moodboard-image-item .image-title {
            font-size: 10px;
            color: #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .moodboard-image-item.editing .image-actions {
            display: flex;
        }
        .image-actions {
            position: absolute;
            top: 5px;
            right: 5px;
            display: none;
            gap: 4px;
        }
        .image-action-btn {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .image-action-btn.delete { background: #e53935; color: #fff; }
        .image-action-btn.move { background: #555; color: #fff; cursor: grab; }
        .image-action-btn:hover { opacity: 0.8; }
        /* Slideshow Modal */
        #slideshow-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            z-index: 2000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        #slideshow-modal.active { display: flex; }
        .slideshow-image-container {
            max-width: 90vw;
            max-height: 75vh;
            position: relative;
        }
        .slideshow-image-container img {
            max-width: 100%;
            max-height: 75vh;
            border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }
        .slideshow-controls {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            align-items: center;
        }
        .slideshow-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: #fff;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.2s;
        }
        .slideshow-btn:hover { background: rgba(255,255,255,0.2); }
        .slideshow-btn.nav { padding: 12px 20px; font-size: 20px; }
        .slideshow-info {
            color: #888;
            font-size: 14px;
        }
        .slideshow-caption {
            color: #fff;
            text-align: center;
            margin-top: 15px;
            font-size: 16px;
            max-width: 600px;
        }
        .slideshow-close {
            position: absolute;
            top: 20px;
            right: 30px;
            background: none;
            border: none;
            color: #fff;
            font-size: 32px;
            cursor: pointer;
        }
        /* Mood Board Edit Mode */
        .moodboard-toolbar {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        .moodboard-toolbar-btn {
            padding: 8px 16px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.05);
            color: #fff;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }
        .moodboard-toolbar-btn:hover { background: rgba(255,255,255,0.15); }
        .moodboard-toolbar-btn.active { background: #8b2942; border-color: #8b2942; }
        .moodboard-toolbar-btn.primary { background: #2e7d32; border-color: #2e7d32; }
        .add-image-form {
            display: none;
            background: rgba(255,255,255,0.05);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }
        .add-image-form.active { display: block; }
        .add-image-form input, .add-image-form select {
            width: 100%;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.2);
            background: rgba(0,0,0,0.3);
            color: #fff;
            margin-bottom: 10px;
            font-size: 13px;
        }
        .add-image-form input::placeholder { color: #888; }
        .drop-zone {
            border: 2px dashed rgba(255,255,255,0.3);
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            color: #888;
            margin-bottom: 10px;
            cursor: pointer;
            transition: border-color 0.2s, background 0.2s;
        }
        .drop-zone:hover, .drop-zone.dragover {
            border-color: #8b2942;
            background: rgba(139,41,66,0.1);
        }
        .drop-zone.has-file {
            border-color: #2e7d32;
            background: rgba(46,125,50,0.1);
        }
        @media (max-width: 768px) {
            .modal-content { padding: 20px; }
            .moodboard-grid { grid-template-columns: 1fr; }
        }
        /* Decorator Mode Styles */
        #decorator-btn {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(calc(-50% + 70px));
            padding: 10px 20px;
            background: #20c997;
            border: none;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            z-index: 100;
        }
        #decorator-btn:hover { background: #1aa87c; }
        #decorator-panel {
            position: fixed;
            top: 0;
            right: -350px;
            width: 350px;
            height: 100%;
            background: rgba(20,20,20,0.98);
            z-index: 1001;
            transition: right 0.3s ease;
            overflow-y: auto;
            border-left: 1px solid rgba(255,255,255,0.1);
        }
        #decorator-panel.open { right: 0; }
        .decorator-header {
            padding: 20px;
            background: rgba(0,0,0,0.5);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .decorator-header h2 { font-size: 16px; margin: 0; }
        .decorator-close {
            background: none;
            border: none;
            color: #fff;
            font-size: 20px;
            cursor: pointer;
        }
        .decorator-category {
            padding: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .decorator-category h3 {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #20c997;
            margin-bottom: 12px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .decorator-category h3::after { content: '‚ñº'; font-size: 8px; }
        .decorator-category.collapsed h3::after { content: '‚ñ∂'; }
        .decorator-category.collapsed .item-grid { display: none; }
        .decorator-category.collapsed .upload-section { display: none; }
        /* 3D File Upload Styles */
        .upload-section {
            padding: 10px;
            margin-bottom: 10px;
        }
        .file-drop-zone {
            border: 2px dashed rgba(255,255,255,0.3);
            border-radius: 8px;
            padding: 20px 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 10px;
        }
        .file-drop-zone:hover, .file-drop-zone.dragover {
            border-color: #20c997;
            background: rgba(32,201,151,0.1);
        }
        .file-drop-zone.has-file {
            border-color: #20c997;
            background: rgba(32,201,151,0.15);
        }
        .file-drop-zone .drop-icon { font-size: 28px; margin-bottom: 8px; }
        .file-drop-zone .drop-text { font-size: 11px; color: #888; }
        .file-drop-zone .drop-formats { font-size: 9px; color: #666; margin-top: 5px; }
        .uploaded-models-list {
            max-height: 200px;
            overflow-y: auto;
        }
        .uploaded-model-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 10px;
            background: rgba(255,255,255,0.05);
            border-radius: 4px;
            margin-bottom: 6px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .uploaded-model-item:hover { background: rgba(255,255,255,0.1); }
        .uploaded-model-item.selected { background: rgba(32,201,151,0.2); border: 1px solid #20c997; }
        .uploaded-model-info { flex: 1; min-width: 0; }
        .uploaded-model-name { font-size: 11px; color: #fff; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .uploaded-model-meta { font-size: 9px; color: #888; }
        .uploaded-model-actions { display: flex; gap: 5px; }
        .model-action-btn {
            width: 24px;
            height: 24px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .model-action-btn.delete { background: rgba(220,53,69,0.5); color: #fff; }
        .model-action-btn.place { background: rgba(32,201,151,0.5); color: #fff; }
        .item-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }
        .item-card {
            background: rgba(255,255,255,0.08);
            border-radius: 6px;
            padding: 8px;
            cursor: grab;
            text-align: center;
            transition: all 0.2s;
            border: 2px solid transparent;
            user-select: none;
        }
        .item-card:hover { background: rgba(255,255,255,0.15); }
        .item-card.selected { border-color: #20c997; background: rgba(32,201,151,0.2); }
        .item-card:active { cursor: grabbing; }
        .item-card.dragging { opacity: 0.5; transform: scale(0.95); }
        .item-preview {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 4px;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            background: transparent !important;
        }
        .item-name {
            font-size: 9px;
            color: #ccc;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .decorator-actions {
            padding: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .decorator-action-btn {
            flex: 1 1 45%;
            padding: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }
        .decorator-action-btn.primary { background: #20c997; color: #fff; }
        .decorator-action-btn.secondary { background: rgba(255,255,255,0.1); color: #fff; }
        .decorator-action-btn.danger { background: #dc3545; color: #fff; flex: 1 1 100%; }
        .decorator-action-btn:hover { opacity: 0.8; }
        .decorator-help {
            padding: 12px 15px;
            background: rgba(32,201,151,0.1);
            border-top: 1px solid rgba(32,201,151,0.3);
            font-size: 10px;
            color: #aaa;
            line-height: 1.6;
        }
        .decorator-help strong { color: #20c997; }
        #canvas-container.drag-over {
            outline: 3px dashed #20c997;
            outline-offset: -3px;
        }
        #canvas-container.drag-over::after {
            content: 'Drop to place';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(32,201,151,0.9);
            color: #fff;
            padding: 20px 40px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            pointer-events: none;
            z-index: 1000;
        }
        .decorator-instructions {
            padding: 15px;
            background: rgba(0,0,0,0.3);
            font-size: 11px;
            color: #888;
            line-height: 1.6;
        }
        .decorator-instructions strong { color: #fff; }
        #selected-item-info {
            padding: 15px;
            background: rgba(32,201,151,0.1);
            border-top: 1px solid rgba(32,201,151,0.3);
            display: none;
        }
        #selected-item-info.visible { display: block; }
        #selected-item-info h4 { font-size: 12px; margin-bottom: 8px; }
        .item-controls {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }
        .item-control-btn {
            padding: 6px 10px;
            background: rgba(255,255,255,0.1);
            border: none;
            color: #fff;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
        }
        .item-control-btn:hover { background: rgba(255,255,255,0.2); }
        .item-control-btn.danger { background: rgba(220,53,69,0.5); }
        .item-control-btn.danger:hover { background: rgba(220,53,69,0.7); }
        /* Wall art section special styling */
        .art-item-card {
            grid-column: span 2;
        }
        .art-item-card .item-preview {
            aspect-ratio: 4/3;
        }
        @media (max-width: 768px) {
            #decorator-panel { width: 100%; right: -100%; }
        }
        /* Admin Mode Styles */
        #admin-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 8px 16px;
            background: rgba(139, 41, 66, 0.8);
            border: 1px solid #8b2942;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            z-index: 100;
        }
        #admin-btn:hover { background: #8b2942; }
        #admin-profile {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 6px 12px;
            background: rgba(32, 201, 151, 0.9);
            border: 1px solid #1aa87c;
            border-radius: 4px;
            z-index: 100;
        }
        #admin-name {
            color: #fff;
            font-size: 12px;
            font-weight: 500;
        }
        #admin-logout-btn {
            padding: 4px 10px;
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: #fff;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
        }
        #admin-logout-btn:hover { background: rgba(255,255,255,0.3); }
        #render-btn {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(calc(-50% + 210px));
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            z-index: 100;
        }
        #render-btn:hover { opacity: 0.9; }
        #render-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        /* Login Modal */
        #login-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 2000;
            display: none;
            justify-content: center;
            align-items: center;
        }
        #login-modal.visible { display: flex; }
        .login-box {
            background: #1a1a1a;
            padding: 40px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.1);
            max-width: 400px;
            width: 90%;
            text-align: center;
        }
        .login-box h2 { margin-bottom: 10px; font-size: 20px; }
        .login-box p { color: #888; margin-bottom: 25px; font-size: 13px; }
        .login-input {
            width: 100%;
            padding: 12px 15px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            color: #fff;
            font-size: 14px;
            margin-bottom: 15px;
        }
        .login-input:focus { outline: none; border-color: #8b2942; }
        .login-submit {
            width: 100%;
            padding: 12px;
            background: #8b2942;
            border: none;
            border-radius: 6px;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
        }
        .login-submit:hover { background: #a03050; }
        .login-cancel {
            background: transparent;
            border: 1px solid rgba(255,255,255,0.2);
            margin-top: 10px;
        }
        .login-error { color: #dc3545; font-size: 12px; margin-top: 10px; }
        /* Admin Panel */
        #admin-panel {
            position: fixed;
            top: 0;
            left: -400px;
            width: 400px;
            height: 100%;
            background: rgba(20,20,20,0.98);
            z-index: 1500;
            transition: left 0.3s ease;
            overflow-y: auto;
            border-right: 1px solid rgba(255,255,255,0.1);
        }
        #admin-panel.open { left: 0; }
        .admin-header {
            padding: 20px;
            background: linear-gradient(135deg, #8b2942 0%, #5a1a2a 100%);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .admin-header h2 { font-size: 16px; margin: 0; }
        .admin-user { font-size: 11px; color: rgba(255,255,255,0.7); }
        .admin-close {
            background: none;
            border: none;
            color: #fff;
            font-size: 20px;
            cursor: pointer;
        }
        .admin-tabs {
            display: flex;
            background: rgba(0,0,0,0.3);
        }
        .admin-tab {
            flex: 1;
            padding: 12px;
            background: transparent;
            border: none;
            color: #888;
            font-size: 11px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
        }
        .admin-tab:hover { color: #fff; }
        .admin-tab.active { color: #fff; border-bottom-color: #8b2942; }
        .admin-content { padding: 20px; }
        .admin-section {
            margin-bottom: 25px;
        }
        .admin-section h3 {
            font-size: 12px;
            color: #8b2942;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
        }
        .admin-input-group {
            margin-bottom: 12px;
        }
        .admin-input-group label {
            display: block;
            font-size: 11px;
            color: #888;
            margin-bottom: 5px;
        }
        .admin-input {
            width: 100%;
            padding: 10px;
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 4px;
            color: #fff;
            font-size: 12px;
        }
        .admin-input:focus { outline: none; border-color: #8b2942; }
        .admin-textarea {
            min-height: 80px;
            resize: vertical;
        }
        .admin-btn {
            padding: 10px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            margin-right: 8px;
            margin-bottom: 8px;
        }
        .admin-btn-primary { background: #8b2942; color: #fff; }
        .admin-btn-secondary { background: rgba(255,255,255,0.1); color: #fff; }
        .admin-btn-success { background: #20c997; color: #fff; }
        .admin-btn:hover { opacity: 0.8; }
        .saved-config-list {
            max-height: 200px;
            overflow-y: auto;
        }
        .saved-config-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: rgba(255,255,255,0.05);
            border-radius: 4px;
            margin-bottom: 8px;
        }
        .saved-config-item:hover { background: rgba(255,255,255,0.1); }
        .saved-config-name { font-size: 12px; }
        .saved-config-meta { font-size: 10px; color: #888; }
        .saved-config-actions { display: flex; gap: 5px; }
        .saved-config-btn {
            padding: 4px 8px;
            background: rgba(255,255,255,0.1);
            border: none;
            border-radius: 3px;
            color: #fff;
            font-size: 10px;
            cursor: pointer;
        }
        .saved-config-btn.danger { background: rgba(220,53,69,0.5); }
        .saved-config-btn.edit { background: rgba(255,193,7,0.5); }
        .saved-config-btn.move { cursor: grab; background: rgba(108,117,125,0.5); }
        .saved-config-item.dragging { opacity: 0.5; border: 1px dashed #8b2942; }
        .saved-config-item.drag-over { border-top: 2px solid #8b2942; }
        .saved-config-info { flex: 1; }
        .edit-inline-input {
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.2);
            color: #fff;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 12px;
            width: 100%;
            margin-bottom: 5px;
        }
        /* Render Modal */
        #render-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            z-index: 2000;
            display: none;
            justify-content: center;
            align-items: center;
        }
        #render-modal.visible { display: flex; }
        .render-box {
            background: #1a1a1a;
            padding: 30px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.1);
            max-width: 900px;
            width: 95%;
            max-height: 90vh;
            overflow-y: auto;
        }
        .render-box h2 { margin-bottom: 5px; }
        .render-box > p { color: #888; margin-bottom: 20px; font-size: 13px; }
        .render-preview {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        .render-preview-box {
            background: rgba(0,0,0,0.5);
            border-radius: 8px;
            padding: 15px;
        }
        .render-preview-box h4 {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 10px;
        }
        .render-preview-img {
            width: 100%;
            aspect-ratio: 16/10;
            background: #000;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #444;
            font-size: 12px;
            overflow: hidden;
        }
        .render-preview-img img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        .render-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }
        .render-style-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }
        .render-style-btn {
            padding: 10px;
            background: rgba(255,255,255,0.08);
            border: 2px solid transparent;
            border-radius: 6px;
            color: #fff;
            font-size: 10px;
            cursor: pointer;
            text-align: center;
        }
        .render-style-btn:hover { background: rgba(255,255,255,0.15); }
        .render-style-btn.active { border-color: #667eea; background: rgba(102,126,234,0.2); }
        .render-actions {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }
        .render-btn-generate {
            flex: 1;
            padding: 14px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 6px;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
        }
        .render-btn-generate:disabled { opacity: 0.5; cursor: not-allowed; }
        .render-btn-close {
            padding: 14px 24px;
            background: rgba(255,255,255,0.1);
            border: none;
            border-radius: 6px;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
        }
        .render-status {
            text-align: center;
            padding: 20px;
            color: #888;
            font-size: 13px;
        }
        .render-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
            vertical-align: middle;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Mobile Footer Actions - Fixed bottom bar on mobile */
        #mobile-footer-actions {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(20, 20, 20, 0.95);
            backdrop-filter: blur(10px);
            padding: 12px 10px;
            padding-bottom: max(12px, env(safe-area-inset-bottom));
            z-index: 200;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            justify-content: space-around;
            align-items: center;
            gap: 8px;
        }
        #mobile-footer-actions button {
            flex: 1;
            max-width: 60px;
            padding: 10px 8px;
            background: rgba(100, 149, 237, 0.3);
            border: 1px solid cornflowerblue;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.2s ease;
        }
        #mobile-footer-actions button:active {
            background: rgba(100, 149, 237, 0.6);
            transform: scale(0.95);
        }

        @media (max-width: 768px) {
            #admin-btn { display: none; }
            #render-btn { display: none; }
            #capture-btn { display: none; }
            #moodboard-btn { display: none; }
            #decorator-btn { display: none; }
            #mobile-footer-actions { display: flex; }
            #admin-panel { width: 100%; left: -100%; }
            .render-preview { grid-template-columns: 1fr; }
            .render-options { grid-template-columns: 1fr; }
            .render-style-grid { grid-template-columns: repeat(2, 1fr); }
            #toggle-btns {
                bottom: 70px;
                padding: 0 10px;
            }
            #help-text {
                bottom: 110px;
            }
            #controls-panel {
                bottom: 140px;
                max-height: 30vh;
            }
            #credits {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div id="info-panel">
        <h1>The Panafrican Library Will Not Be Colonized</h1>
        <h2>Reading Room ‚Ä¢ Interactive 3D</h2>
        <p>A curatorial Reading Room conceived as a living archive of panafrican and diasporic publishing. A space to read, listen, and slow down.</p>
        <div class="room-buttons">
            <button class="room-btn" onclick="focusRoom('threeStarRoom')">Three Star (West)</button>
            <button class="room-btn" onclick="focusRoom('specialSpecialRoom')">Special Special (East)</button>
        </div>
        <div class="room-descriptions">
            <div class="room-desc" id="desc-S202">
                <strong>The Pan-African Library</strong><br>
                Curatorial selection of ~50 independent publications ‚Äî zines, fanzines, essays, archives, catalogues, and experimental editions. AABF 10-year archives with posters, visuals, documents, and manifestos. Video space with filmed interviews with publishers and activists. Mapping African publishing networks across the continent.
            </div>
            <div class="room-desc" id="desc-S203">
                <strong>Sound Library</strong><br>
                Audio/radio listening station with speakers, headphones, DJ table & vinyl. Screens with media players. Floor cushions and woven mats. Sound works from Afrikadaa collective and Station of Commons radio. Collective listening and reading sessions, performances, poetry.
            </div>
        </div>
    </div>

    <div id="controls-panel">
        <div class="control-section">
            <div class="section-title">Overview</div>
            <button class="control-btn" onclick="setView('overview')"><span class="icon">üè†</span>Bird's Eye</button>
            <button class="control-btn" onclick="setView('floorPlan')"><span class="icon">üìê</span>Floor Plan View</button>
        </div>
        <div class="control-section">
            <div class="section-title">Three Star (West) ‚Äî Pan-African Library</div>
            <button class="control-btn" onclick="setView('threeStarRoomEntry')"><span class="icon">üö™</span>Entry Vestibule</button>
            <button class="control-btn" onclick="setView('threeStarRoomInside')"><span class="icon">üîä</span>Inside View</button>
            <button class="control-btn" onclick="setView('threeStarRoomWindows')"><span class="icon">ü™ü</span>Window Wall</button>
            <button class="control-btn" onclick="setView('threeStarRoomTable')"><span class="icon">üìö</span>Display Table</button>
        </div>
        <div class="control-section">
            <div class="section-title">Special Special (East) ‚Äî Sound Library</div>
            <button class="control-btn" onclick="setView('specialSpecialRoomEntry')"><span class="icon">üö™</span>Entry (from door)</button>
            <button class="control-btn" onclick="setView('specialSpecialRoomInside')"><span class="icon">üìñ</span>Inside View</button>
            <button class="control-btn" onclick="setView('specialSpecialRoomWindows')"><span class="icon">ü™ü</span>Arched Windows</button>
            <button class="control-btn" onclick="setView('specialSpecialRoomSeating')"><span class="icon">üõãÔ∏è</span>Seating Area</button>
            <button class="control-btn" onclick="setView('specialSpecialRoomShelves')"><span class="icon">üìö</span>Book Displays</button>
        </div>
        <div class="control-section">
            <button class="control-btn" onclick="startTour()"><span class="icon">üé¨</span>Auto Tour</button>
        </div>
    </div>

    <div id="dimensions-panel">
        <h3>Room Dimensions (from floor plan)</h3>
        <div class="dim-row">
            <span class="dim-label">Three Star (West)</span>
            <span class="dim-value">17'-4¬Ω" √ó 25'-3¬æ" | 5.29m √ó 7.71m</span>
        </div>
        <div class="dim-row">
            <span class="dim-label">Three Star Area</span>
            <span class="dim-value">438.7 sq ft | 40.8 m¬≤</span>
        </div>
        <div class="dim-row">
            <span class="dim-label">Special Special (East)</span>
            <span class="dim-value">11'-5‚Öù" √ó 15'-1¬Ω" | 3.49m √ó 4.61m</span>
        </div>
        <div class="dim-row">
            <span class="dim-label">Special Special Area</span>
            <span class="dim-value">173.1 sq ft | 16.1 m¬≤</span>
        </div>
        <div class="dim-row">
            <span class="dim-label">Ceiling Height</span>
            <span class="dim-value">12'-0" | 3.66m</span>
        </div>
        <div class="dim-row">
            <span class="dim-label">Door Openings</span>
            <span class="dim-value">3'-5‚Öõ" √ó 7'-0" | 1.04m √ó 2.13m</span>
        </div>
        <div class="dim-row">
            <span class="dim-label">Total Combined Area</span>
            <span class="dim-value">611.8 sq ft | 56.9 m¬≤</span>
        </div>
    </div>

    <div id="credits">
        <div style="margin-bottom: 8px; color: #888;">A project by</div>
        <div><a href="http://www.afrikadaa.com/" target="_blank">Pascale Obolo / Afrikadaa</a></div>
        <div><a href="http://coolhuntparis.com" target="_blank">Nalini Cazaux / Coolhunt Paris</a></div>
        <div style="margin-top: 8px; color: #888;">3D Simulation by</div>
        <div><a href="http://luvlab.io" target="_blank">Gordon Cyrus / Luvlab</a></div>
    </div>

    <div id="help-text">‚Ä¢ Drag to rotate ‚Ä¢ Scroll to zoom ‚Ä¢ WASD to move</div>

    <div id="toggle-btns">
        <button class="toggle-btn active" onclick="toggleGrid()" id="gridBtn">Grid</button>
        <button class="toggle-btn active" onclick="toggleLabels()" id="labelsBtn">Labels</button>
        <button class="toggle-btn active" onclick="toggleCeiling()" id="ceilingBtn">Ceiling</button>
        <button class="toggle-btn" onclick="toggleNearWall()" id="nearWallBtn">Hide Near Wall</button>
        <button class="toggle-btn" onclick="toggleWireframe()" id="wireframeBtn">Wireframe</button>
    </div>

    <button id="capture-btn" onclick="captureScreenshot()">üì∑ Capture</button>
    <button id="moodboard-btn" onclick="toggleMoodboard()">üé® Mood Board</button>
    <button id="decorator-btn" onclick="toggleDecorator()">üõãÔ∏è Decorator</button>
    <button id="render-btn" onclick="openRenderModal()">‚ú® AI Render</button>
    <button id="admin-btn" onclick="toggleAdminLogin()">üîê Admin</button>
    <div id="admin-profile" style="display:none;">
        <span id="admin-name" onclick="toggleAdminPanel()" style="cursor:pointer;">üë§ Admin</span>
        <button id="admin-logout-btn" onclick="logoutAdmin()">Logout</button>
    </div>

    <!-- Mood Board Modal -->
    <div id="moodboard-modal" class="modal-hidden">
        <div class="modal-content">
            <button class="modal-close" onclick="toggleMoodboard()">‚úï</button>
            <h2>Reference Images & Mood Board</h2>
            <p>Design inspiration for The Panafrican Library Reading Room ‚Äî Afrikadaa √ó Coolhunt Paris</p>

            <!-- Toolbar -->
            <div class="moodboard-toolbar">
                <button class="moodboard-toolbar-btn" onclick="toggleMoodboardEdit()" id="edit-mode-btn">‚úèÔ∏è Edit Mode</button>
                <button class="moodboard-toolbar-btn primary" onclick="toggleAddImageForm()" id="add-image-btn">‚ûï Add Image</button>
                <span id="category-filter-buttons">
                    <!-- Dynamically rendered category filters -->
                </span>
                <button class="moodboard-toolbar-btn" onclick="toggleCategoryManager()" id="manage-categories-btn" title="Manage Categories">‚öôÔ∏è</button>
            </div>

            <!-- Category Manager -->
            <div class="category-manager" id="category-manager" style="display:none; background: rgba(0,0,0,0.8); padding: 15px; border-radius: 6px; margin-bottom: 15px;">
                <h4 style="color: #fff; margin-bottom: 10px;">Manage Categories</h4>
                <div id="category-list" style="margin-bottom: 10px;">
                    <!-- Rendered by JS -->
                </div>
                <div style="display: flex; gap: 6px; align-items: center;">
                    <input type="text" id="new-category-value" placeholder="category-key" style="width: 100px; padding: 6px; font-size: 11px; border: 1px solid #444; border-radius: 3px; background: #1a1a1a; color: #fff;">
                    <input type="text" id="new-category-label" placeholder="Category Label" style="flex: 1; padding: 6px; font-size: 11px; border: 1px solid #444; border-radius: 3px; background: #1a1a1a; color: #fff;">
                    <button class="moodboard-toolbar-btn primary" onclick="addCategory()" style="padding: 6px 10px;">Add</button>
                </div>
            </div>

            <!-- Add Image Form -->
            <div class="add-image-form" id="add-image-form">
                <div class="drop-zone" id="drop-zone" onclick="document.getElementById('image-file-input').click()">
                    üì∑ Drag & drop images here or click to browse<br>
                    <span style="font-size: 10px; color: #888;">Select multiple files at once!</span>
                </div>
                <input type="file" id="image-file-input" accept="image/*" multiple style="display:none" onchange="handleMultiImageSelect(event)">
                <div id="upload-queue" style="display:none; max-height: 150px; overflow-y: auto; margin: 8px 0; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 4px;">
                    <!-- Upload queue will be shown here -->
                </div>
                <input type="text" id="new-image-url" placeholder="Or paste image URL...">
                <input type="text" id="new-image-title" placeholder="Image title / description (for single upload)">
                <select id="new-image-category">
                    <!-- Rendered by JS -->
                </select>
                <div style="display: flex; gap: 10px;">
                    <button class="moodboard-toolbar-btn primary" onclick="addMoodboardImage()" style="flex:1" id="add-single-btn">Add Image</button>
                    <button class="moodboard-toolbar-btn primary" onclick="addAllQueuedImages()" style="flex:1; display:none;" id="add-all-btn">‚ûï Add All (<span id="queue-count">0</span>)</button>
                    <button class="moodboard-toolbar-btn" onclick="toggleAddImageForm()" style="flex:1">Cancel</button>
                </div>
            </div>

            <!-- Edit Image Modal -->
            <div id="edit-image-modal" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.9); z-index:2000; justify-content:center; align-items:center;">
                <div style="background:#222; padding:20px; border-radius:8px; max-width:400px; width:90%;">
                    <h3 style="color:#fff; margin-bottom:15px;">Edit Image Details</h3>
                    <input type="hidden" id="edit-image-index">
                    <div style="margin-bottom:10px;">
                        <label style="color:#888; font-size:11px;">Title</label>
                        <input type="text" id="edit-image-title" style="width:100%; padding:8px; font-size:12px; border:1px solid #444; border-radius:4px; background:#1a1a1a; color:#fff; margin-top:4px;">
                    </div>
                    <div style="margin-bottom:15px;">
                        <label style="color:#888; font-size:11px;">Category</label>
                        <select id="edit-image-category" style="width:100%; padding:8px; font-size:12px; border:1px solid #444; border-radius:4px; background:#1a1a1a; color:#fff; margin-top:4px;">
                            <!-- Rendered by JS -->
                        </select>
                    </div>
                    <div style="display:flex; gap:10px;">
                        <button class="moodboard-toolbar-btn primary" onclick="saveImageEdit()" style="flex:1;">Save</button>
                        <button class="moodboard-toolbar-btn" onclick="closeImageEdit()" style="flex:1;">Cancel</button>
                    </div>
                </div>
            </div>

            <!-- Reference Images Gallery -->
            <div class="moodboard-section" style="grid-column: 1 / -1;">
                <h3>üì∏ Reference Images <span id="image-count" style="color:#888; font-weight:normal;"></span></h3>
                <div class="moodboard-images" id="moodboard-gallery">
                    <!-- Images will be populated by JavaScript -->
                </div>
            </div>

            <div class="moodboard-grid">
                <div class="moodboard-section">
                    <h3>üé® Color Palette <button class="section-edit-btn" onclick="toggleColorPaletteEdit()" id="color-edit-btn">‚úèÔ∏è</button></h3>
                    <p style="font-size: 11px; color: #666; margin-bottom: 8px;">Based on Panafrican reference imagery</p>
                    <div class="color-palette" id="color-palette-container">
                        <!-- Colors rendered by JS -->
                    </div>
                    <div class="color-add-form" id="color-add-form" style="display:none;">
                        <input type="color" id="new-color-value" value="#fd7e14">
                        <input type="text" id="new-color-name" placeholder="Color name..." style="flex:1; padding:4px; font-size:11px; border:1px solid #444; border-radius:3px; background:#1a1a1a; color:#fff;">
                        <button class="moodboard-toolbar-btn primary" onclick="addColorSwatch()" style="padding:4px 8px; font-size:10px;">Add</button>
                    </div>
                </div>
                <div class="moodboard-section">
                    <h3>üåç Patterns <button class="section-edit-btn" onclick="togglePatternEdit()" id="pattern-edit-btn">‚úèÔ∏è</button></h3>
                    <div class="pattern-grid" id="pattern-grid-container" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px;">
                        <!-- Patterns rendered by JS -->
                    </div>
                    <p style="font-size: 10px; color: #888; margin-top: 6px;">Drag patterns onto furniture ‚Ä¢ Ankara ‚Ä¢ Kente ‚Ä¢ Adinkra</p>
                    <div class="pattern-add-form" id="pattern-add-form" style="display:none; margin-top:8px;">
                        <input type="text" id="new-pattern-name" placeholder="Pattern name..." style="width:100%; padding:4px; font-size:11px; border:1px solid #444; border-radius:3px; background:#1a1a1a; color:#fff; margin-bottom:4px;">
                        <input type="file" id="new-pattern-file" accept="image/*" style="width:100%; padding:4px; font-size:11px; border:1px solid #444; border-radius:3px; background:#1a1a1a; color:#fff; margin-bottom:4px;">
                        <div style="display:flex; gap:4px;">
                            <button class="moodboard-toolbar-btn primary" onclick="addPatternFromFile()" style="padding:4px 8px; font-size:10px; flex:1;">üìÅ Add from File</button>
                            <button class="moodboard-toolbar-btn" onclick="loadPatternsFromFolder()" style="padding:4px 8px; font-size:10px; flex:1;">üìÇ Load Folder</button>
                        </div>
                        <input type="text" id="new-pattern-url" placeholder="...or paste image URL" style="width:100%; padding:4px; font-size:11px; border:1px solid #444; border-radius:3px; background:#1a1a1a; color:#fff; margin-top:4px; margin-bottom:4px;">
                        <button class="moodboard-toolbar-btn" onclick="addPatternSwatch()" style="padding:4px 8px; font-size:10px; width:100%;">üîó Add from URL</button>
                    </div>
                </div>
                <div class="moodboard-section">
                    <h3>üõãÔ∏è Key Furniture <button class="section-edit-btn" onclick="toggleFurnitureEdit()" id="furniture-edit-btn">‚úèÔ∏è</button></h3>
                    <div id="furniture-list-container">
                        <!-- Furniture items rendered by JS -->
                    </div>
                    <div class="furniture-add-form" id="furniture-add-form" style="display:none; margin-top:8px;">
                        <input type="text" id="new-furniture-emoji" placeholder="Emoji" style="width:40px; padding:4px; font-size:11px; border:1px solid #444; border-radius:3px; background:#1a1a1a; color:#fff;">
                        <input type="text" id="new-furniture-text" placeholder="Furniture description..." style="flex:1; padding:4px; font-size:11px; border:1px solid #444; border-radius:3px; background:#1a1a1a; color:#fff;">
                        <button class="moodboard-toolbar-btn primary" onclick="addFurnitureItem()" style="padding:4px 8px; font-size:10px;">Add</button>
                    </div>
                </div>
                <div class="moodboard-section">
                    <h3>üìç Room Functions <button class="section-edit-btn" onclick="toggleFunctionsEdit()" id="functions-edit-btn">‚úèÔ∏è</button></h3>
                    <div class="layout-info" id="functions-container" style="font-size: 12px;">
                        <!-- Room functions rendered by JS -->
                    </div>
                    <div class="functions-add-form" id="functions-add-form" style="display:none; margin-top:8px;">
                        <input type="text" id="new-function-title" placeholder="Section title..." style="width:100%; padding:4px; font-size:11px; border:1px solid #444; border-radius:3px; background:#1a1a1a; color:#fff; margin-bottom:4px;">
                        <textarea id="new-function-text" placeholder="Description..." style="width:100%; padding:4px; font-size:11px; border:1px solid #444; border-radius:3px; background:#1a1a1a; color:#fff; resize:vertical; min-height:40px;"></textarea>
                        <button class="moodboard-toolbar-btn primary" onclick="addFunctionItem()" style="padding:4px 8px; font-size:10px; width:100%; margin-top:4px;">Add Section</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Slideshow Modal -->
    <div id="slideshow-modal">
        <button class="slideshow-close" onclick="closeSlideshow()">‚úï</button>
        <div class="slideshow-image-container">
            <img id="slideshow-image" src="" alt="Reference image">
        </div>
        <div class="slideshow-caption" id="slideshow-caption"></div>
        <div class="slideshow-controls">
            <button class="slideshow-btn nav" onclick="slideshowNav(-1)">‚Üê</button>
            <span class="slideshow-info" id="slideshow-info">1 / 6</span>
            <button class="slideshow-btn nav" onclick="slideshowNav(1)">‚Üí</button>
        </div>
    </div>

    <!-- Login Modal -->
    <div id="login-modal">
        <div class="login-box">
            <h2>üîê Admin Login</h2>
            <p>Enter your authorized email to access admin features</p>
            <input type="email" id="login-email" class="login-input" placeholder="your@email.com" onkeypress="if(event.key==='Enter')attemptLogin()">
            <button class="login-submit" onclick="attemptLogin()">Login</button>
            <button class="login-submit login-cancel" onclick="closeLoginModal()">Cancel</button>
            <div id="login-error" class="login-error"></div>
        </div>
    </div>

    <!-- Admin Panel -->
    <div id="admin-panel">
        <div class="admin-header">
            <div>
                <h2>üõ†Ô∏è Admin Panel</h2>
                <div class="admin-user" id="admin-user-name">Logged in as: Admin</div>
            </div>
            <button class="admin-close" onclick="toggleAdminPanel()">‚úï</button>
        </div>

        <div class="admin-tabs">
            <button class="admin-tab active" onclick="switchAdminTab('layouts')">Layouts</button>
            <button class="admin-tab" onclick="switchAdminTab('views')">Views</button>
            <button class="admin-tab" onclick="switchAdminTab('moodboard')">Mood Board</button>
            <button class="admin-tab" onclick="switchAdminTab('renders')">AI Renders</button>
        </div>

        <div class="admin-content" id="admin-tab-layouts">
            <div class="admin-section">
                <h3>Save Current Layout</h3>
                <div class="admin-input-group">
                    <label>Configuration Name</label>
                    <input type="text" class="admin-input" id="layout-name" placeholder="e.g., Opening Night Setup">
                </div>
                <div class="admin-input-group">
                    <label>Description (optional)</label>
                    <input type="text" class="admin-input" id="layout-description" placeholder="e.g., With all furniture in place">
                </div>
                <button class="admin-btn admin-btn-primary" onclick="saveAdminLayout()">üíæ Save Layout</button>
                <button class="admin-btn admin-btn-secondary" onclick="exportLayoutFile()">üì§ Export JSON</button>
                <button class="admin-btn admin-btn-secondary" onclick="importLayoutFile()">üì• Import JSON</button>
                <input type="file" id="import-layout-input" accept=".json" style="display:none" onchange="handleLayoutImport(event)">
            </div>

            <div class="admin-section">
                <h3>Saved Layouts <span id="layouts-count" style="color:#888; font-weight:normal;"></span></h3>
                <p style="font-size: 10px; color: #666; margin-bottom: 10px;">Drag to reorder ‚Ä¢ Click to load</p>
                <div class="saved-config-list" id="saved-layouts-list">
                    <div style="color: #666; font-size: 12px; padding: 10px;">No layouts saved yet</div>
                </div>
            </div>
        </div>

        <div class="admin-content" id="admin-tab-views" style="display:none;">
            <div class="admin-section">
                <h3>Save Current View</h3>
                <div class="admin-input-group">
                    <label>View Name</label>
                    <input type="text" class="admin-input" id="view-name" placeholder="e.g., Window Corner">
                </div>
                <div class="admin-input-group">
                    <label>Description (optional)</label>
                    <input type="text" class="admin-input" id="view-description" placeholder="Brief description">
                </div>
                <button class="admin-btn admin-btn-primary" onclick="saveAdminView()">üìç Save Current View</button>
            </div>

            <div class="admin-section">
                <h3>Saved Views <span id="views-count" style="color:#888; font-weight:normal;"></span></h3>
                <p style="font-size: 10px; color: #666; margin-bottom: 10px;">Drag to reorder ‚Ä¢ Click to apply</p>
                <div class="saved-config-list" id="saved-views-list">
                    <div style="color: #666; font-size: 12px; padding: 10px;">No views saved yet</div>
                </div>
            </div>

            <div class="admin-section">
                <h3>Current Camera Position</h3>
                <div id="camera-position-display" style="font-family: monospace; font-size: 11px; color: #888; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 4px;">
                    Position: (0, 0, 0)<br>
                    Target: (0, 0, 0)
                </div>
                <button class="admin-btn admin-btn-secondary" style="margin-top:10px; width:100%;" onclick="updateCameraDisplay()">üîÑ Refresh Position</button>
            </div>
        </div>

        <div class="admin-content" id="admin-tab-moodboard" style="display:none;">
            <div class="admin-section">
                <h3>Add Mood Board Entry</h3>
                <div class="admin-input-group">
                    <label>Title</label>
                    <input type="text" class="admin-input" id="mood-title" placeholder="e.g., Color Inspiration">
                </div>
                <div class="admin-input-group">
                    <label>Image URL</label>
                    <input type="text" class="admin-input" id="mood-image-url" placeholder="https://...">
                </div>
                <div class="admin-input-group">
                    <label>Description</label>
                    <textarea class="admin-input admin-textarea" id="mood-description" placeholder="Describe this reference..."></textarea>
                </div>
                <div class="admin-input-group">
                    <label>Category</label>
                    <select class="admin-input" id="mood-category">
                        <option value="inspiration">Inspiration</option>
                        <option value="colors">Colors</option>
                        <option value="furniture">Furniture</option>
                        <option value="art">Artwork</option>
                        <option value="layout">Layout</option>
                    </select>
                </div>
                <button class="admin-btn admin-btn-primary" onclick="saveMoodEntry()">‚ûï Add to Mood Board</button>
            </div>

            <div class="admin-section">
                <h3>Saved Mood Board Entries</h3>
                <div class="saved-config-list" id="saved-mood-list">
                    <div style="color: #666; font-size: 12px; padding: 10px;">Loading...</div>
                </div>
            </div>
        </div>

        <div class="admin-content" id="admin-tab-renders" style="display:none;">
            <div class="admin-section">
                <h3>AI Render History</h3>
                <p style="font-size: 11px; color: #888; margin-bottom: 15px;">Generated photorealistic renders of your room designs</p>
                <div class="saved-config-list" id="saved-renders-list">
                    <div style="color: #666; font-size: 12px; padding: 10px;">No renders yet. Click "AI Render" to generate one.</div>
                </div>
            </div>

            <div class="admin-section">
                <h3>Render Settings</h3>
                <div class="admin-input-group">
                    <label>Default Style</label>
                    <select class="admin-input" id="default-render-style">
                        <option value="photorealistic">Photorealistic</option>
                        <option value="warm-cozy">Warm & Cozy</option>
                        <option value="editorial">Editorial Magazine</option>
                        <option value="sketch">Architectural Sketch</option>
                    </select>
                </div>
            </div>
        </div>

        <div style="padding: 20px; border-top: 1px solid rgba(255,255,255,0.1);">
            <button class="admin-btn admin-btn-secondary" onclick="logoutAdmin()" style="width: 100%;">üö™ Logout</button>
        </div>
    </div>

    <!-- Render Modal -->
    <div id="render-modal">
        <div class="render-box">
            <h2>‚ú® AI Photorealistic Render</h2>
            <p>Transform your 3D scene into a stunning photorealistic image using Nano Banana AI</p>

            <div class="render-preview">
                <div class="render-preview-box">
                    <h4>Current 3D View</h4>
                    <div class="render-preview-img" id="render-input-preview">
                        Capture will appear here
                    </div>
                </div>
                <div class="render-preview-box">
                    <h4>AI Generated Render</h4>
                    <div class="render-preview-img" id="render-output-preview">
                        Generated image will appear here
                    </div>
                </div>
            </div>

            <div class="render-options">
                <div>
                    <label style="font-size: 11px; color: #888; display: block; margin-bottom: 8px;">Render Style</label>
                    <div class="render-style-grid">
                        <button class="render-style-btn active" onclick="selectRenderStyle('photorealistic', this)">üì∏ Photo</button>
                        <button class="render-style-btn" onclick="selectRenderStyle('warm-cozy', this)">üåÖ Warm</button>
                        <button class="render-style-btn" onclick="selectRenderStyle('editorial', this)">üì∞ Editorial</button>
                        <button class="render-style-btn" onclick="selectRenderStyle('sketch', this)">‚úèÔ∏è Sketch</button>
                    </div>
                </div>
                <div>
                    <label style="font-size: 11px; color: #888; display: block; margin-bottom: 8px;">Custom Prompt (optional)</label>
                    <input type="text" class="admin-input" id="render-custom-prompt" placeholder="Add specific instructions...">
                </div>
            </div>

            <div id="render-status" class="render-status" style="display: none;">
                <span class="render-spinner"></span>
                <span id="render-status-text">Generating render...</span>
            </div>

            <div class="render-actions">
                <button class="render-btn-generate" id="generate-render-btn" onclick="generateRender()">
                    üé® Generate Photorealistic Render
                </button>
                <button class="render-btn-close" onclick="closeRenderModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Decorator Panel -->
    <div id="decorator-panel">
        <div class="decorator-header">
            <h2>üõãÔ∏è Room Decorator</h2>
            <button class="decorator-close" onclick="toggleDecorator()">‚úï</button>
        </div>

        <div id="selected-item-info">
            <h4>Selected: <span id="selected-name">None</span></h4>
            <div class="item-controls">
                <button class="item-control-btn" onclick="moveItem(-0.2, 0)">‚Üê X</button>
                <button class="item-control-btn" onclick="moveItem(0.2, 0)">X ‚Üí</button>
                <button class="item-control-btn" onclick="moveItem(0, -0.2)">‚Üë Z</button>
                <button class="item-control-btn" onclick="moveItem(0, 0.2)">Z ‚Üì</button>
                <button class="item-control-btn" onclick="rotateItem(15)">‚Üª 15¬∞</button>
                <button class="item-control-btn" onclick="rotateItem(-15)">‚Ü∫ 15¬∞</button>
                <button class="item-control-btn danger" onclick="deleteItem()">üóëÔ∏è</button>
            </div>
            <div style="font-size:9px; color:#888; margin-top:8px;">
                Keys: G=move, R=rotate, Del=delete, Esc=deselect
            </div>

            <!-- TEXTURE CUSTOMIZATION PANEL -->
            <div id="texture-panel" style="margin-top:12px; padding:10px; background:#1a1a1a; border-radius:6px; display:none;">
                <h5 style="margin:0 0 8px 0; font-size:11px; color:#ffd700;">üé® Apply Texture</h5>
                <div id="texture-surfaces" style="margin-bottom:8px;">
                    <label style="font-size:10px; color:#888;">Surface:</label>
                    <select id="surface-select" style="width:100%; padding:4px; font-size:10px; background:#2a2a2a; color:#fff; border:1px solid #444; border-radius:3px; margin-top:4px;">
                        <option value="all">All Surfaces</option>
                        <option value="cushions">Cushions Only</option>
                        <option value="top">Top Surface</option>
                        <option value="sides">Side Surfaces</option>
                    </select>
                </div>
                <div id="texture-patterns-mini" style="display:grid; grid-template-columns:repeat(5,1fr); gap:4px; max-height:120px; overflow-y:auto;">
                    <!-- Populated by JS -->
                </div>
                <div style="margin-top:8px; display:flex; gap:4px;">
                    <button class="item-control-btn" onclick="resetFurnitureTexture()" style="flex:1; font-size:9px;">Reset</button>
                    <button class="item-control-btn" onclick="randomizeFurnitureTexture()" style="flex:1; font-size:9px;">Random</button>
                </div>
            </div>
        </div>

        <!-- NEW PANAFRICAN LIBRARY FURNITURE -->
        <div class="decorator-category" id="cat-banquette">
            <h3 onclick="toggleCategory('cat-banquette')">üìö Banquette-Shelf Units</h3>
            <div class="item-grid">
                <div class="item-card" onclick="selectFurniture('banquette-shelf-short')">
                    <div class="item-preview">ü™ëüìñ</div>
                    <div class="item-name">Short (1.8m)</div>
                </div>
                <div class="item-card" onclick="selectFurniture('banquette-shelf-medium')">
                    <div class="item-preview">ü™ëüìö</div>
                    <div class="item-name">Medium (2.4m)</div>
                </div>
                <div class="item-card" onclick="selectFurniture('banquette-shelf-long')">
                    <div class="item-preview">ü™ëüìöüìö</div>
                    <div class="item-name">Long (3.2m)</div>
                </div>
            </div>
        </div>

        <div class="decorator-category" id="cat-record-tables">
            <h3 onclick="toggleCategory('cat-record-tables')">üíø Vinyl Record Tables</h3>
            <div class="item-grid">
                <div class="item-card" onclick="selectFurniture('record-table-ngoma')">
                    <div class="item-preview">üî¥</div>
                    <div class="item-name">Ngoma (Red)</div>
                </div>
                <div class="item-card" onclick="selectFurniture('record-table-bantou')">
                    <div class="item-preview">üîµ</div>
                    <div class="item-name">Ban Tou (Blue)</div>
                </div>
                <div class="item-card" onclick="selectFurniture('record-table-jazz')">
                    <div class="item-preview">üü°</div>
                    <div class="item-name">African Jazz</div>
                </div>
                <div class="item-card" onclick="selectFurniture('record-table-pathe')">
                    <div class="item-preview">üü¢</div>
                    <div class="item-name">Path√© (Green)</div>
                </div>
            </div>
        </div>

        <div class="decorator-category" id="cat-cube-stools">
            <h3 onclick="toggleCategory('cat-cube-stools')">üì¶ Cardboard Cube Stools</h3>
            <div class="item-grid">
                <div class="item-card" onclick="selectFurniture('cube-stool-branches')">
                    <div class="item-preview">üåø</div>
                    <div class="item-name">Branches Print</div>
                </div>
                <div class="item-card" onclick="selectFurniture('cube-stool-pattern')">
                    <div class="item-preview">‚óºÔ∏è</div>
                    <div class="item-name">African Pattern</div>
                </div>
                <div class="item-card" onclick="selectFurniture('cube-stool-text')">
                    <div class="item-preview">üî§</div>
                    <div class="item-name">Text Print</div>
                </div>
                <div class="item-card" onclick="selectFurniture('cube-stool-benin')">
                    <div class="item-preview">üóø</div>
                    <div class="item-name">Benin Art</div>
                </div>
            </div>
        </div>

        <div class="decorator-category" id="cat-poufs">
            <h3 onclick="toggleCategory('cat-poufs')">üß∂ African Print Poufs</h3>
            <div class="item-grid">
                <div class="item-card" onclick="selectFurniture('pouf-leopard')">
                    <div class="item-preview">üêÜ</div>
                    <div class="item-name">Leopard Print</div>
                </div>
                <div class="item-card" onclick="selectFurniture('pouf-wax-blue')">
                    <div class="item-preview">üíô</div>
                    <div class="item-name">Wax Blue</div>
                </div>
                <div class="item-card" onclick="selectFurniture('pouf-wax-pink')">
                    <div class="item-preview">üíó</div>
                    <div class="item-name">Wax Pink</div>
                </div>
                <div class="item-card" onclick="selectFurniture('pouf-kente')">
                    <div class="item-preview">üíõ</div>
                    <div class="item-name">Kente</div>
                </div>
                <div class="item-card" onclick="selectFurniture('pouf-mudcloth')">
                    <div class="item-preview">ü§é</div>
                    <div class="item-name">Mudcloth</div>
                </div>
            </div>
        </div>

        <div class="decorator-category" id="cat-sculptures">
            <h3 onclick="toggleCategory('cat-sculptures')">üóø African Sculptures</h3>
            <div class="item-grid">
                <div class="item-card" onclick="selectFurniture('sculpture-benin-head')">
                    <div class="item-preview">üëë</div>
                    <div class="item-name">Benin Head</div>
                </div>
                <div class="item-card" onclick="selectFurniture('sculpture-wood')">
                    <div class="item-preview">ü™µ</div>
                    <div class="item-name">Wood Figure</div>
                </div>
                <div class="item-card" onclick="selectFurniture('pottery-african')">
                    <div class="item-preview">üè∫</div>
                    <div class="item-name">African Pottery</div>
                </div>
            </div>
        </div>

        <div class="decorator-category" id="cat-seating">
            <h3 onclick="toggleCategory('cat-seating')">Seating - Bean Bags & Cushions</h3>
            <div class="item-grid">
                <div class="item-card" onclick="selectFurniture('beanbag-cream')">
                    <div class="item-preview">ü§ç</div>
                    <div class="item-name">Cream Bean Bag</div>
                </div>
                <div class="item-card" onclick="selectFurniture('beanbag-orange')">
                    <div class="item-preview">üß°</div>
                    <div class="item-name">Orange Bean Bag</div>
                </div>
                <div class="item-card" onclick="selectFurniture('beanbag-magenta')">
                    <div class="item-preview">üíó</div>
                    <div class="item-name">Magenta Bean Bag</div>
                </div>
                <div class="item-card" onclick="selectFurniture('beanbag-teal')">
                    <div class="item-preview">üíö</div>
                    <div class="item-name">Teal Bean Bag</div>
                </div>
                <div class="item-card" onclick="selectFurniture('cushion-ethnic-orange')">
                    <div class="item-preview">üü†</div>
                    <div class="item-name">Ethnic Orange</div>
                </div>
                <div class="item-card" onclick="selectFurniture('cushion-ethnic-burgundy')">
                    <div class="item-preview">üü§</div>
                    <div class="item-name">Ethnic Burgundy</div>
                </div>
                <div class="item-card" onclick="selectFurniture('cushion-velvet-teal')">
                    <div class="item-preview">ü©µ</div>
                    <div class="item-name">Velvet Teal</div>
                </div>
                <div class="item-card" onclick="selectFurniture('cushion-round-green')">
                    <div class="item-preview">üü¢</div>
                    <div class="item-name">Round Green</div>
                </div>
                <div class="item-card" onclick="selectFurniture('cushion-pebble-gray')">
                    <div class="item-preview">‚ö™</div>
                    <div class="item-name">Pebble Gray</div>
                </div>
                <div class="item-card" onclick="selectFurniture('mattress-ochre')">
                    <div class="item-preview">üü®</div>
                    <div class="item-name">Tufted Mattress</div>
                </div>
                <div class="item-card" onclick="selectFurniture('sofa-olive')">
                    <div class="item-preview">üõãÔ∏è</div>
                    <div class="item-name">Olive Velvet Sofa</div>
                </div>
                <div class="item-card" onclick="selectFurniture('armchair-pink')">
                    <div class="item-preview">ü™ë</div>
                    <div class="item-name">Pink Armchair</div>
                </div>
            </div>
        </div>

        <div class="decorator-category" id="cat-tables">
            <h3 onclick="toggleCategory('cat-tables')">Tables</h3>
            <div class="item-grid">
                <div class="item-card" onclick="selectFurniture('table-display')">
                    <div class="item-preview">ü™µ</div>
                    <div class="item-name">Display Table</div>
                </div>
                <div class="item-card" onclick="selectFurniture('table-coffee')">
                    <div class="item-preview">‚òï</div>
                    <div class="item-name">Coffee Table</div>
                </div>
                <div class="item-card" onclick="selectFurniture('table-side')">
                    <div class="item-preview">üü°</div>
                    <div class="item-name">Side Table</div>
                </div>
                <div class="item-card" onclick="selectFurniture('bench-wood')">
                    <div class="item-preview">ü™ë</div>
                    <div class="item-name">Wood Bench</div>
                </div>
            </div>
        </div>

        <div class="decorator-category" id="cat-storage">
            <h3 onclick="toggleCategory('cat-storage')">Book Displays & Storage</h3>
            <div class="item-grid">
                <div class="item-card" onclick="selectFurniture('bookcase-wall')">
                    <div class="item-preview">üìö</div>
                    <div class="item-name">Wall Bookcase</div>
                </div>
                <div class="item-card" onclick="selectFurniture('book-cubby')">
                    <div class="item-preview">üì¶</div>
                    <div class="item-name">Book Cubby</div>
                </div>
                <div class="item-card" onclick="selectFurniture('magazine-rack')">
                    <div class="item-preview">üì∞</div>
                    <div class="item-name">Magazine Rack</div>
                </div>
                <div class="item-card" onclick="selectFurniture('book-stack')">
                    <div class="item-preview">üìö</div>
                    <div class="item-name">Book Stack</div>
                </div>
                <div class="item-card" onclick="selectFurniture('display-pink')">
                    <div class="item-preview">üìï</div>
                    <div class="item-name">Pink Display</div>
                </div>
                <div class="item-card" onclick="selectFurniture('shelf-leaning')">
                    <div class="item-preview">üìñ</div>
                    <div class="item-name">Leaning Shelf</div>
                </div>
            </div>
        </div>

        <div class="decorator-category" id="cat-rugs">
            <h3 onclick="toggleCategory('cat-rugs')">Rugs & Textiles - Layered</h3>
            <div class="item-grid">
                <div class="item-card" onclick="selectFurniture('rug-persian-red')">
                    <div class="item-preview">üü•</div>
                    <div class="item-name">Persian Red</div>
                </div>
                <div class="item-card" onclick="selectFurniture('rug-persian-cream')">
                    <div class="item-preview">‚¨ú</div>
                    <div class="item-name">Persian Cream</div>
                </div>
                <div class="item-card" onclick="selectFurniture('rug-natte-african')">
                    <div class="item-preview">üá∏üá≥</div>
                    <div class="item-name">Natte Plastique</div>
                </div>
                <div class="item-card" onclick="selectFurniture('rug-checkered-pink')">
                    <div class="item-preview">ü©∑</div>
                    <div class="item-name">Checkered Pink</div>
                </div>
                <div class="item-card" onclick="selectFurniture('rug-checkered-teal')">
                    <div class="item-preview">ü©µ</div>
                    <div class="item-name">Checkered Teal</div>
                </div>
                <div class="item-card" onclick="selectFurniture('rug-wax-yellow')">
                    <div class="item-preview">üü°</div>
                    <div class="item-name">Wax Print Yellow</div>
                </div>
                <div class="item-card" onclick="selectFurniture('rug-geometric-bw')">
                    <div class="item-preview">‚¨õ</div>
                    <div class="item-name">Geometric B&W</div>
                </div>
                <div class="item-card" onclick="selectFurniture('tablecloth-tiedye')">
                    <div class="item-preview">üé®</div>
                    <div class="item-name">Tie-Dye Cloth</div>
                </div>
            </div>
        </div>

        <div class="decorator-category" id="cat-lighting">
            <h3 onclick="toggleCategory('cat-lighting')">Lighting & Hanging</h3>
            <div class="item-grid">
                <div class="item-card" onclick="selectFurniture('lamp-ethiopian')">
                    <div class="item-preview">üè∫</div>
                    <div class="item-name">Ethiopian Lamp</div>
                </div>
                <div class="item-card" onclick="selectFurniture('lamp-beaded')">
                    <div class="item-preview">‚ú®</div>
                    <div class="item-name">Beaded Lamp</div>
                </div>
                <div class="item-card" onclick="selectFurniture('disco-ball')">
                    <div class="item-preview">ü™©</div>
                    <div class="item-name">Disco Ball</div>
                </div>
                <div class="item-card" onclick="selectFurniture('disco-ball-cluster')">
                    <div class="item-preview">ü™©ü™©</div>
                    <div class="item-name">Disco Cluster</div>
                </div>
                <div class="item-card" onclick="selectFurniture('light-string')">
                    <div class="item-preview">üí°</div>
                    <div class="item-name">String Lights</div>
                </div>
                <div class="item-card" onclick="selectFurniture('lantern-paper')">
                    <div class="item-preview">üèÆ</div>
                    <div class="item-name">Paper Lantern</div>
                </div>
            </div>
        </div>

        <div class="decorator-category" id="cat-plants">
            <h3 onclick="toggleCategory('cat-plants')">Plants & African Decor</h3>
            <div class="item-grid">
                <div class="item-card" onclick="selectFurniture('plant-palm')">
                    <div class="item-preview">üå¥</div>
                    <div class="item-name">Palm Plant</div>
                </div>
                <div class="item-card" onclick="selectFurniture('plant-hanging')">
                    <div class="item-preview">üåø</div>
                    <div class="item-name">Hanging Plant</div>
                </div>
                <div class="item-card" onclick="selectFurniture('plant-pothos')">
                    <div class="item-preview">üçÉ</div>
                    <div class="item-name">Pothos Vine</div>
                </div>
                <div class="item-card" onclick="selectFurniture('basket-woven')">
                    <div class="item-preview">üß∫</div>
                    <div class="item-name">Woven Basket</div>
                </div>
                <div class="item-card" onclick="selectFurniture('pottery-african')">
                    <div class="item-preview">üè∫</div>
                    <div class="item-name">African Pottery</div>
                </div>
                <div class="item-card" onclick="selectFurniture('sculpture-wood')">
                    <div class="item-preview">üóø</div>
                    <div class="item-name">Wood Sculpture</div>
                </div>
            </div>
        </div>

        <div class="decorator-category" id="cat-wallart">
            <h3 onclick="toggleCategory('cat-wallart')">Wall Art - Afrikadaa</h3>
            <div class="item-grid">
                <div class="item-card art-item-card" onclick="selectFurniture('poster-afrikadaa-1')">
                    <div class="item-preview">üñºÔ∏è</div>
                    <div class="item-name">Afrikadaa Cover #1</div>
                </div>
                <div class="item-card art-item-card" onclick="selectFurniture('poster-afrikadaa-2')">
                    <div class="item-preview">üñºÔ∏è</div>
                    <div class="item-name">Afrikadaa Cover #2</div>
                </div>
                <div class="item-card art-item-card" onclick="selectFurniture('poster-afrikadaa-3')">
                    <div class="item-preview">üñºÔ∏è</div>
                    <div class="item-name">African Contemporary</div>
                </div>
            </div>
        </div>

        <div class="decorator-category" id="cat-wallart2">
            <h3 onclick="toggleCategory('cat-wallart2')">Wall Art - Coolhunt Paris</h3>
            <div class="item-grid">
                <div class="item-card art-item-card" onclick="selectFurniture('poster-coolhunt-1')">
                    <div class="item-preview">üì∑</div>
                    <div class="item-name">Fashion Photo</div>
                </div>
                <div class="item-card art-item-card" onclick="selectFurniture('poster-coolhunt-2')">
                    <div class="item-preview">üé®</div>
                    <div class="item-name">Street Art Print</div>
                </div>
                <div class="item-card art-item-card" onclick="selectFurniture('poster-coolhunt-3')">
                    <div class="item-preview">üñåÔ∏è</div>
                    <div class="item-name">Design Print</div>
                </div>
            </div>
        </div>

        <div class="decorator-category" id="cat-activist">
            <h3 onclick="toggleCategory('cat-activist')">Wall Art - Activist</h3>
            <div class="item-grid">
                <div class="item-card art-item-card" onclick="selectFurniture('poster-activist-1')">
                    <div class="item-preview">WE WANT TO LIVE FREE</div>
                    <div class="item-name">Live Free Banner</div>
                </div>
                <div class="item-card art-item-card" onclick="selectFurniture('poster-activist-2')">
                    <div class="item-preview">SOMOS PERSONAS</div>
                    <div class="item-name">Somos Personas</div>
                </div>
                <div class="item-card art-item-card" onclick="selectFurniture('poster-activist-3')">
                    <div class="item-preview">‚úä</div>
                    <div class="item-name">Resistance Art</div>
                </div>
            </div>
        </div>

        <div class="decorator-category" id="cat-custom3d">
            <h3 onclick="toggleCategory('cat-custom3d')">üì¶ Custom 3D Models</h3>
            <div class="upload-section">
                <div class="file-drop-zone" id="model-drop-zone" onclick="document.getElementById('model-file-input').click()">
                    <div class="drop-icon">üì¶</div>
                    <div class="drop-text">Drop 3D model file here or click to browse</div>
                    <div class="drop-formats">Supports: GLB, GLTF, OBJ</div>
                </div>
                <input type="file" id="model-file-input" accept=".glb,.gltf,.obj" style="display:none" onchange="handleModelUpload(event)">
                <input type="text" id="model-name-input" class="edit-inline-input" placeholder="Model name (optional)" style="margin-bottom: 8px;">
                <div class="uploaded-models-list" id="uploaded-models-list">
                    <!-- Uploaded models appear here -->
                </div>
            </div>
            <div class="item-grid" id="custom-models-grid">
                <!-- Custom model cards appear here -->
            </div>
        </div>

        <div class="decorator-actions">
            <button class="decorator-action-btn danger" onclick="resetLayout()">üîÑ Clear All</button>
        </div>

        <div class="decorator-help">
            <strong>How to use:</strong><br>
            ‚Ä¢ Drag items from library ‚Üí drop in 3D view<br>
            ‚Ä¢ Or click item, then click in room to place<br>
            ‚Ä¢ Drag 3D files (GLB/OBJ) from Finder ‚Üí drop on canvas<br>
            ‚Ä¢ Click placed items to select, then drag to move<br>
            ‚Ä¢ Use controls above for rotate/delete
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
    <script>
        // ============ INDEXEDDB FOR 3D MODEL STORAGE ============
        const DB_NAME = 'PanafricanLibrary3D';
        const DB_VERSION = 1;
        const MODELS_STORE = 'custom_models';
        const IMAGES_STORE = 'moodboard_images';

        let db = null;

        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    resolve(db);
                };

                request.onupgradeneeded = (event) => {
                    const database = event.target.result;

                    // Store for 3D models
                    if (!database.objectStoreNames.contains(MODELS_STORE)) {
                        const modelsStore = database.createObjectStore(MODELS_STORE, { keyPath: 'id', autoIncrement: true });
                        modelsStore.createIndex('name', 'name', { unique: false });
                        modelsStore.createIndex('type', 'type', { unique: false });
                    }

                    // Store for mood board images
                    if (!database.objectStoreNames.contains(IMAGES_STORE)) {
                        const imagesStore = database.createObjectStore(IMAGES_STORE, { keyPath: 'id', autoIncrement: true });
                        imagesStore.createIndex('category', 'category', { unique: false });
                    }
                };
            });
        }

        // Save 3D model to IndexedDB
        async function saveModelToDB(modelData) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([MODELS_STORE], 'readwrite');
                const store = transaction.objectStore(MODELS_STORE);
                const request = store.add(modelData);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        // Get all models from IndexedDB
        async function getAllModelsFromDB() {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([MODELS_STORE], 'readonly');
                const store = transaction.objectStore(MODELS_STORE);
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        // Delete model from IndexedDB
        async function deleteModelFromDB(id) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([MODELS_STORE], 'readwrite');
                const store = transaction.objectStore(MODELS_STORE);
                const request = store.delete(id);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        // Save image to IndexedDB
        async function saveImageToDB(imageData) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([IMAGES_STORE], 'readwrite');
                const store = transaction.objectStore(IMAGES_STORE);
                const request = store.add(imageData);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        // Get all images from IndexedDB
        async function getAllImagesFromDB() {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([IMAGES_STORE], 'readonly');
                const store = transaction.objectStore(IMAGES_STORE);
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        // Delete image from IndexedDB
        async function deleteImageFromDB(id) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([IMAGES_STORE], 'readwrite');
                const store = transaction.objectStore(IMAGES_STORE);
                const request = store.delete(id);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        // Initialize DB on load
        initDB().then(() => {
            console.log('IndexedDB initialized for 3D models and images');
            loadUploadedModels();
            loadUploadedImages();
        }).catch(err => {
            console.error('Failed to initialize IndexedDB:', err);
        });

        // ============ 3D MODEL UPLOAD HANDLING ============
        let uploadedModels = [];
        let gltfLoader = null;
        let objLoader = null;

        // Initialize loaders after Three.js is ready
        function initLoaders() {
            if (typeof THREE.GLTFLoader !== 'undefined') {
                gltfLoader = new THREE.GLTFLoader();
            }
            if (typeof THREE.OBJLoader !== 'undefined') {
                objLoader = new THREE.OBJLoader();
            }
        }

        // Handle 3D model file upload
        window.handleModelUpload = async function(event) {
            const file = event.target.files[0];
            if (!file) return;

            const dropZone = document.getElementById('model-drop-zone');
            const nameInput = document.getElementById('model-name-input');
            const customName = nameInput.value.trim() || file.name.replace(/\.[^/.]+$/, '');

            // Check file type
            const ext = file.name.split('.').pop().toLowerCase();
            if (!['glb', 'gltf', 'obj'].includes(ext)) {
                alert('Unsupported file format. Please use GLB, GLTF, or OBJ.');
                return;
            }

            dropZone.classList.add('has-file');
            dropZone.querySelector('.drop-text').textContent = 'Processing...';

            try {
                // Read file as ArrayBuffer
                const arrayBuffer = await file.arrayBuffer();

                const modelData = {
                    name: customName,
                    fileName: file.name,
                    type: ext,
                    size: file.size,
                    data: arrayBuffer,
                    createdAt: new Date().toISOString()
                };

                // Save to IndexedDB
                const id = await saveModelToDB(modelData);
                modelData.id = id;
                uploadedModels.push(modelData);

                // Update UI
                nameInput.value = '';
                dropZone.classList.remove('has-file');
                dropZone.querySelector('.drop-text').textContent = 'Drop 3D model file here or click to browse';

                renderUploadedModelsList();
                alert(`Model "${customName}" uploaded successfully!`);

            } catch (err) {
                console.error('Error uploading model:', err);
                alert('Failed to upload model: ' + err.message);
                dropZone.classList.remove('has-file');
                dropZone.querySelector('.drop-text').textContent = 'Drop 3D model file here or click to browse';
            }

            // Reset file input
            event.target.value = '';
        };

        // Load models from IndexedDB on startup
        async function loadUploadedModels() {
            if (!db) return;
            try {
                uploadedModels = await getAllModelsFromDB();
                renderUploadedModelsList();
            } catch (err) {
                console.error('Error loading models:', err);
            }
        }

        // Render the uploaded models list
        function renderUploadedModelsList() {
            const container = document.getElementById('uploaded-models-list');
            const grid = document.getElementById('custom-models-grid');

            if (!container) return;

            if (uploadedModels.length === 0) {
                container.innerHTML = '<div style="color:#666; font-size:11px; text-align:center; padding:10px;">No custom models yet</div>';
                if (grid) grid.innerHTML = '';
                return;
            }

            // List view
            container.innerHTML = uploadedModels.map(model => `
                <div class="uploaded-model-item" onclick="selectCustomModel(${model.id})">
                    <div class="uploaded-model-info">
                        <div class="uploaded-model-name">üì¶ ${model.name}</div>
                        <div class="uploaded-model-meta">${model.type.toUpperCase()} ‚Ä¢ ${formatFileSize(model.size)}</div>
                    </div>
                    <div class="uploaded-model-actions">
                        <button class="model-action-btn place" onclick="event.stopPropagation(); placeCustomModel(${model.id})" title="Place in scene">+</button>
                        <button class="model-action-btn delete" onclick="event.stopPropagation(); deleteCustomModel(${model.id})" title="Delete">‚úï</button>
                    </div>
                </div>
            `).join('');

            // Grid view (item cards)
            if (grid) {
                grid.innerHTML = uploadedModels.map(model => `
                    <div class="item-card" onclick="selectCustomModel(${model.id})">
                        <div class="item-preview">üì¶</div>
                        <div class="item-name">${model.name}</div>
                    </div>
                `).join('');
            }
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        // Select a custom model for placement
        window.selectCustomModel = function(id) {
            const model = uploadedModels.find(m => m.id === id);
            if (model) {
                selectedFurnitureType = `custom-model-${id}`;
                document.querySelectorAll('.item-card').forEach(c => c.classList.remove('selected'));
                document.querySelectorAll('.uploaded-model-item').forEach(c => c.classList.remove('selected'));
                event.target.closest('.item-card, .uploaded-model-item')?.classList.add('selected');
                updateSelectedInfo();
            }
        };

        // Place custom model in scene
        window.placeCustomModel = async function(id) {
            const model = uploadedModels.find(m => m.id === id);
            if (!model) return;

            initLoaders();

            try {
                const blob = new Blob([model.data]);
                const url = URL.createObjectURL(blob);

                let object = null;

                if (model.type === 'glb' || model.type === 'gltf') {
                    if (!gltfLoader) {
                        alert('GLTF Loader not available');
                        return;
                    }
                    object = await new Promise((resolve, reject) => {
                        gltfLoader.load(url, (gltf) => {
                            resolve(gltf.scene);
                        }, undefined, reject);
                    });
                } else if (model.type === 'obj') {
                    if (!objLoader) {
                        alert('OBJ Loader not available');
                        return;
                    }
                    object = await new Promise((resolve, reject) => {
                        objLoader.load(url, resolve, undefined, reject);
                    });
                }

                URL.revokeObjectURL(url);

                if (object) {
                    // Auto-scale to reasonable size
                    const box = new THREE.Box3().setFromObject(object);
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    if (maxDim > 2) {
                        const scale = 1.5 / maxDim;
                        object.scale.multiplyScalar(scale);
                    }

                    // Center on floor
                    const newBox = new THREE.Box3().setFromObject(object);
                    object.position.y = -newBox.min.y;

                    // Place at room center
                    object.position.x = 0;
                    object.position.z = 0;

                    // Mark as placed item
                    object.userData.isPlacedItem = true;
                    object.userData.itemType = `custom-model-${id}`;
                    object.userData.customModelId = id;
                    object.userData.customModelName = model.name;

                    scene.add(object);
                    placedItems.push(object);

                    alert(`Model "${model.name}" placed in scene!`);
                }

            } catch (err) {
                console.error('Error loading model:', err);
                alert('Failed to load model: ' + err.message);
            }
        };

        // Delete custom model
        window.deleteCustomModel = async function(id) {
            const model = uploadedModels.find(m => m.id === id);
            if (!model) return;

            if (!confirm(`Delete model "${model.name}"? This cannot be undone.`)) return;

            try {
                await deleteModelFromDB(id);
                uploadedModels = uploadedModels.filter(m => m.id !== id);
                renderUploadedModelsList();
            } catch (err) {
                console.error('Error deleting model:', err);
                alert('Failed to delete model: ' + err.message);
            }
        };

        // Setup drag-drop for model upload
        document.addEventListener('DOMContentLoaded', () => {
            const dropZone = document.getElementById('model-drop-zone');
            if (dropZone) {
                dropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    dropZone.classList.add('dragover');
                });
                dropZone.addEventListener('dragleave', () => {
                    dropZone.classList.remove('dragover');
                });
                dropZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    dropZone.classList.remove('dragover');
                    const file = e.dataTransfer.files[0];
                    if (file) {
                        // Trigger the file input handler
                        const input = document.getElementById('model-file-input');
                        const dt = new DataTransfer();
                        dt.items.add(file);
                        input.files = dt.files;
                        handleModelUpload({ target: input });
                    }
                });
            }
        });

        // ============ MOOD BOARD IMAGE UPLOAD TO INDEXEDDB ============
        let uploadedImages = [];

        async function loadUploadedImages() {
            if (!db) return;
            try {
                uploadedImages = await getAllImagesFromDB();
                // Merge with localStorage moodboard images
                mergeUploadedImagesWithMoodboard();
            } catch (err) {
                console.error('Error loading images:', err);
            }
        }

        function mergeUploadedImagesWithMoodboard() {
            // Add uploaded images to moodboard if they exist
            uploadedImages.forEach(img => {
                const exists = moodboardImages.find(m => m.dbId === img.id);
                if (!exists && img.dataUrl) {
                    moodboardImages.push({
                        src: img.dataUrl,
                        title: img.name,
                        category: img.category || 'inspiration',
                        dbId: img.id,
                        isUploaded: true
                    });
                }
            });
        }

        // Enhanced image upload with IndexedDB storage
        window.handleMoodboardImageUpload = async function(file) {
            if (!file || !file.type.startsWith('image/')) return null;

            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    const dataUrl = e.target.result;

                    // Save to IndexedDB for persistence
                    const imageData = {
                        name: file.name.replace(/\.[^/.]+$/, ''),
                        fileName: file.name,
                        dataUrl: dataUrl,
                        size: file.size,
                        category: document.getElementById('new-image-category')?.value || 'inspiration',
                        createdAt: new Date().toISOString()
                    };

                    try {
                        const id = await saveImageToDB(imageData);
                        imageData.id = id;
                        uploadedImages.push(imageData);
                        resolve(dataUrl);
                    } catch (err) {
                        console.error('Error saving image:', err);
                        // Still return dataUrl even if DB save fails
                        resolve(dataUrl);
                    }
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        };

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);

        const container = document.getElementById('canvas-container');
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);

        const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // Camera orbit blocking flag - declared early for TransformControls use
        let isCameraOrbitBlocked = false;

        // TransformControls for visual move/rotate gizmos
        let transformControls = null;
        function initTransformControls() {
            if (typeof THREE.TransformControls !== 'undefined') {
                transformControls = new THREE.TransformControls(camera, renderer.domElement);
                transformControls.setSize(0.75);
                scene.add(transformControls);

                // STRICT: Snap to floor and enforce room boundaries
                let lastValidPosition = null;
                transformControls.addEventListener('objectChange', () => {
                    if (selectedPlacedItem) {
                        // Snap to floor (unless wall art)
                        if (!selectedPlacedItem.userData.isWallArt) {
                            selectedPlacedItem.position.y = 0;
                        }

                        // STRICT: Check if new position is valid
                        const constrained = constrainToRoom(selectedPlacedItem.position);
                        if (constrained) {
                            // Valid position - update and save
                            selectedPlacedItem.position.x = constrained.x;
                            selectedPlacedItem.position.z = constrained.z;
                            lastValidPosition = selectedPlacedItem.position.clone();
                        } else if (lastValidPosition) {
                            // INVALID - snap back to last valid position
                            selectedPlacedItem.position.copy(lastValidPosition);
                        }
                    }
                });

                // Save valid position when starting drag
                transformControls.addEventListener('mouseDown', () => {
                    if (selectedPlacedItem) {
                        lastValidPosition = selectedPlacedItem.position.clone();
                    }
                });

                // Disable camera orbit while transforming with gizmo
                transformControls.addEventListener('dragging-changed', (event) => {
                    isCameraOrbitBlocked = event.value; // Block when dragging starts, unblock when ends
                    isMouseDown = false; // Also reset mouse state
                });
            }
        }

        // ============================================================
        // EXACT DIMENSIONS FROM FLOOR PLAN (converted to meters)
        // LAYOUT: Windows on NORTH (+Z), Entries on SOUTH (-Z)
        // Both rooms are labeled S202 on the floor plan
        // ============================================================
        // SPECIAL SPECIAL (East Room - Sound Library)
        const SPECIAL_SPECIAL_WIDTH = 3.496;  // 11'-5‚Öù" (X direction)
        const SPECIAL_SPECIAL_DEPTH = 4.61;   // 15'-1¬Ω" (Z direction) main room
        const SPECIAL_SPECIAL_CORRIDOR_WIDTH = 0.85;  // 2'-9‚Öù" entry corridor width
        const SPECIAL_SPECIAL_CORRIDOR_DEPTH = 0.65;  // 2'-1 5/16" entry corridor depth
        // THREE STAR (West Room - Pan-African Library)
        const THREE_STAR_WIDTH = 4.36;   // 14'-3 13/16" INTERIOR width (X direction)
        const THREE_STAR_DEPTH = 7.715;  // 25'-3¬æ" (Z direction)
        const THREE_STAR_ENTRY_WIDTH = 1.37;  // 4'-5 15/16" entry alcove width
        const THREE_STAR_WINDOW_WIDTH = 3.09; // 10'-1¬Ω" window section width
        // Shared constants
        const CEILING_HEIGHT = 3.66;   // 12' ceiling
        const WALL_THICKNESS = 0.152;  // 6"
        const DOOR_WIDTH = 1.044;      // 3'-5‚Öõ"
        const DOOR_HEIGHT = 2.134;     // 7'-0"

        // Entry vestibule for SPECIAL SPECIAL (small corridor at south)
        const VESTIBULE_WIDTH = SPECIAL_SPECIAL_CORRIDOR_WIDTH;
        const VESTIBULE_DEPTH = SPECIAL_SPECIAL_CORRIDOR_DEPTH;

        // ============================================================
        // LAYOUT VALIDATION SYSTEM
        // Prevents bad furniture placements from rendering
        // ============================================================

        // Asset Whitelist - Only these items can be placed
        const ASSET_WHITELIST = {
            // THREE STAR (West) - Pan-African Library - Publications, archives, video interviews
            'audio_station': {
                id: 'audio_station',
                name: 'DJ / Audio Station',
                footprint: { width: 1.2, depth: 0.6 },
                clearance: { front: 0.8, back: 0.1, left: 0.2, right: 0.2 },
                allowedRooms: ['THREE_STAR'],
                wallAnchor: 'west',
                maxCount: 1
            },
            'floor_speaker': {
                id: 'floor_speaker',
                name: 'Floor Speaker',
                footprint: { width: 0.35, depth: 0.35 },
                clearance: { front: 0.5, back: 0.1, left: 0.1, right: 0.1 },
                allowedRooms: ['THREE_STAR'],
                wallAnchor: null,
                maxCount: 4
            },
            'simple_pouf': {
                id: 'simple_pouf',
                name: 'Floor Pouf/Cushion',
                footprint: { width: 0.6, depth: 0.6 },
                clearance: { front: 0.3, back: 0.3, left: 0.3, right: 0.3 },
                allowedRooms: ['THREE_STAR'],
                wallAnchor: null,
                maxCount: 8
            },
            'headphone_station': {
                id: 'headphone_station',
                name: 'Headphone Listening Station',
                footprint: { width: 0.5, depth: 0.5 },
                clearance: { front: 0.6, back: 0.1, left: 0.3, right: 0.3 },
                allowedRooms: ['THREE_STAR'],
                wallAnchor: 'east',
                maxCount: 3
            },
            'african_natte': {
                id: 'african_natte',
                name: 'African Woven Mat',
                footprint: { width: 2.0, depth: 1.5 },
                clearance: { front: 0, back: 0, left: 0, right: 0 },
                allowedRooms: ['THREE_STAR'],
                wallAnchor: null,
                maxCount: 2
            },

            // SPECIAL SPECIAL (East) - Sound Library - Audio/radio, DJ, collective listening
            'reading_table': {
                id: 'reading_table',
                name: 'Reading Table',
                footprint: { width: 1.8, depth: 0.9 },
                clearance: { front: 0.8, back: 0.8, left: 0.6, right: 0.6 },
                allowedRooms: ['SPECIAL_SPECIAL'],
                wallAnchor: null,
                maxCount: 2
            },
            'stackable_chair': {
                id: 'stackable_chair',
                name: 'Stackable Chair',
                footprint: { width: 0.45, depth: 0.45 },
                clearance: { front: 0.5, back: 0.1, left: 0.1, right: 0.1 },
                allowedRooms: ['SPECIAL_SPECIAL'],
                wallAnchor: null,
                maxCount: 12
            },
            'wall_shelf': {
                id: 'wall_shelf',
                name: 'Wall-Mounted Archive Shelf',
                footprint: { width: 1.2, depth: 0.3 },
                clearance: { front: 0.6, back: 0, left: 0.1, right: 0.1 },
                allowedRooms: ['SPECIAL_SPECIAL'],
                wallAnchor: 'any',
                maxCount: 6
            },
            'archive_cabinet': {
                id: 'archive_cabinet',
                name: 'Low Archive Cabinet',
                footprint: { width: 1.0, depth: 0.45 },
                clearance: { front: 0.6, back: 0.1, left: 0.1, right: 0.1 },
                allowedRooms: ['SPECIAL_SPECIAL'],
                wallAnchor: 'any',
                maxCount: 4
            },
            'screen_stand': {
                id: 'screen_stand',
                name: 'Video Screen Stand',
                footprint: { width: 0.6, depth: 0.4 },
                clearance: { front: 1.5, back: 0.1, left: 0.3, right: 0.3 },
                allowedRooms: ['SPECIAL_SPECIAL'],
                wallAnchor: null,
                maxCount: 2
            },
            'simple_stool': {
                id: 'simple_stool',
                name: 'Simple Stool',
                footprint: { width: 0.35, depth: 0.35 },
                clearance: { front: 0.4, back: 0.2, left: 0.2, right: 0.2 },
                allowedRooms: ['SPECIAL_SPECIAL'],
                wallAnchor: null,
                maxCount: 6
            },
            'pendant_light': {
                id: 'pendant_light',
                name: 'Pendant Light',
                footprint: { width: 0.4, depth: 0.4 },
                clearance: { front: 0, back: 0, left: 0, right: 0 },
                allowedRooms: ['THREE_STAR', 'SPECIAL_SPECIAL'],
                wallAnchor: null,
                isCeilingMounted: true,
                maxCount: 4
            }
        };

        // Room Geometry - Defines boundaries and keep-out zones
        const ROOM_GEOMETRY = {
            'THREE_STAR': {
                id: 'THREE_STAR',
                name: 'Three Star - Pan-African Library',
                bounds: {
                    minX: -THREE_STAR_WIDTH / 2 - SPECIAL_SPECIAL_WIDTH / 2 - WALL_THICKNESS / 2,
                    maxX: -SPECIAL_SPECIAL_WIDTH / 2 - WALL_THICKNESS / 2,
                    minZ: -THREE_STAR_DEPTH / 2,
                    maxZ: THREE_STAR_DEPTH / 2
                },
                doorZone: {
                    minX: -THREE_STAR_WIDTH / 2 - SPECIAL_SPECIAL_WIDTH / 2 - WALL_THICKNESS / 2 + THREE_STAR_WIDTH / 2 - DOOR_WIDTH,
                    maxX: -THREE_STAR_WIDTH / 2 - SPECIAL_SPECIAL_WIDTH / 2 - WALL_THICKNESS / 2 + THREE_STAR_WIDTH / 2 + DOOR_WIDTH,
                    minZ: -THREE_STAR_DEPTH / 2,
                    maxZ: -THREE_STAR_DEPTH / 2 + 1.2
                },
                circulationZones: [
                    {
                        minX: -THREE_STAR_WIDTH / 2 - SPECIAL_SPECIAL_WIDTH / 2 - WALL_THICKNESS / 2 + 0.8,
                        maxX: -SPECIAL_SPECIAL_WIDTH / 2 - WALL_THICKNESS / 2 - 0.8,
                        minZ: -THREE_STAR_DEPTH / 2 + 1.2,
                        maxZ: THREE_STAR_DEPTH / 2 - 1.0
                    }
                ],
                usableArea: null
            },
            'SPECIAL_SPECIAL': {
                id: 'SPECIAL_SPECIAL',
                name: 'Special Special - Sound Library',
                bounds: {
                    minX: WALL_THICKNESS / 2,
                    maxX: SPECIAL_SPECIAL_WIDTH + WALL_THICKNESS / 2,
                    minZ: -SPECIAL_SPECIAL_DEPTH / 2,
                    maxZ: SPECIAL_SPECIAL_DEPTH / 2
                },
                doorZone: {
                    minX: WALL_THICKNESS / 2 + SPECIAL_SPECIAL_WIDTH / 2 - DOOR_WIDTH,
                    maxX: WALL_THICKNESS / 2 + SPECIAL_SPECIAL_WIDTH / 2 + DOOR_WIDTH,
                    minZ: -SPECIAL_SPECIAL_DEPTH / 2,
                    maxZ: -SPECIAL_SPECIAL_DEPTH / 2 + 1.2
                },
                circulationZones: [
                    {
                        minX: WALL_THICKNESS / 2 + 0.6,
                        maxX: SPECIAL_SPECIAL_WIDTH + WALL_THICKNESS / 2 - 0.6,
                        minZ: -SPECIAL_SPECIAL_DEPTH / 2 + 1.2,
                        maxZ: -SPECIAL_SPECIAL_DEPTH / 2 + 2.5
                    }
                ],
                usableArea: null
            }
        };

        // Calculate usable areas (bounds minus door and circulation zones)
        function calculateUsableAreas() {
            for (const roomId in ROOM_GEOMETRY) {
                const room = ROOM_GEOMETRY[roomId];
                const bounds = room.bounds;
                const door = room.doorZone;
                // Usable area is the bounds with margin
                room.usableArea = {
                    minX: bounds.minX + 0.3,
                    maxX: bounds.maxX - 0.3,
                    minZ: bounds.minZ + 0.3,
                    maxZ: bounds.maxZ - 0.3
                };
            }
        }
        calculateUsableAreas();

        // 2D AABB Collision Detection
        function getAABB(placement) {
            const asset = ASSET_WHITELIST[placement.assetId];
            if (!asset) return null;

            const halfW = asset.footprint.width / 2;
            const halfD = asset.footprint.depth / 2;

            // Account for rotation (simplified - assumes 90 degree increments)
            const rot = (placement.rotation || 0) % 360;
            const rotated = (rot === 90 || rot === 270);
            const w = rotated ? halfD : halfW;
            const d = rotated ? halfW : halfD;

            return {
                minX: placement.x - w,
                maxX: placement.x + w,
                minZ: placement.z - d,
                maxZ: placement.z + d
            };
        }

        function aabbsOverlap(a, b) {
            if (!a || !b) return false;
            return !(a.maxX < b.minX || a.minX > b.maxX ||
                     a.maxZ < b.minZ || a.minZ > b.maxZ);
        }

        function getAABBWithClearance(placement) {
            const asset = ASSET_WHITELIST[placement.assetId];
            if (!asset) return null;

            const base = getAABB(placement);
            if (!base) return null;

            const cl = asset.clearance;
            return {
                minX: base.minX - cl.left,
                maxX: base.maxX + cl.right,
                minZ: base.minZ - cl.back,
                maxZ: base.maxZ + cl.front
            };
        }

        // Layout Validation Function
        function validateLayout(placements) {
            const errors = [];
            const warnings = [];
            const assetCounts = {};

            for (let i = 0; i < placements.length; i++) {
                const p = placements[i];
                const asset = ASSET_WHITELIST[p.assetId];

                // 1. Check if asset is in whitelist
                if (!asset) {
                    errors.push(`Unknown asset: ${p.assetId}`);
                    continue;
                }

                // 2. Check room assignment
                if (!asset.allowedRooms.includes(p.roomId)) {
                    errors.push(`${asset.name} not allowed in room ${p.roomId}`);
                }

                // 3. Check max count
                assetCounts[p.assetId] = (assetCounts[p.assetId] || 0) + 1;
                if (assetCounts[p.assetId] > asset.maxCount) {
                    errors.push(`Too many ${asset.name} (max ${asset.maxCount})`);
                }

                // 4. Check room boundaries
                const room = ROOM_GEOMETRY[p.roomId];
                if (room) {
                    const aabb = getAABB(p);
                    if (aabb) {
                        const usable = room.usableArea;
                        if (aabb.minX < usable.minX || aabb.maxX > usable.maxX ||
                            aabb.minZ < usable.minZ || aabb.maxZ > usable.maxZ) {
                            errors.push(`${asset.name} outside room boundaries`);
                        }

                        // 5. Check door zone collision
                        if (aabbsOverlap(aabb, room.doorZone)) {
                            errors.push(`${asset.name} blocks door in ${p.roomId}`);
                        }
                    }
                }

                // 6. Check wall anchor requirements
                if (asset.wallAnchor && asset.wallAnchor !== 'any') {
                    const room = ROOM_GEOMETRY[p.roomId];
                    if (room) {
                        const bounds = room.bounds;
                        const wallMargin = 0.5;
                        let anchored = false;

                        if (asset.wallAnchor === 'west' && Math.abs(p.x - bounds.minX) < wallMargin) anchored = true;
                        if (asset.wallAnchor === 'east' && Math.abs(p.x - bounds.maxX) < wallMargin) anchored = true;
                        if (asset.wallAnchor === 'north' && Math.abs(p.z - bounds.minZ) < wallMargin) anchored = true;
                        if (asset.wallAnchor === 'south' && Math.abs(p.z - bounds.maxZ) < wallMargin) anchored = true;

                        if (!anchored) {
                            warnings.push(`${asset.name} should be against ${asset.wallAnchor} wall`);
                        }
                    }
                }

                // 7. Check collision with other placements
                for (let j = i + 1; j < placements.length; j++) {
                    const other = placements[j];
                    const aabb1 = getAABBWithClearance(p);
                    const aabb2 = getAABBWithClearance(other);

                    if (aabbsOverlap(aabb1, aabb2)) {
                        const otherAsset = ASSET_WHITELIST[other.assetId];
                        errors.push(`${asset.name} collides with ${otherAsset?.name || other.assetId}`);
                    }
                }
            }

            return {
                valid: errors.length === 0,
                errors: errors,
                warnings: warnings
            };
        }

        // Layout Scoring Function
        function scoreLayout(placements) {
            let score = 100;
            const validation = validateLayout(placements);

            // Hard failures
            if (!validation.valid) {
                return { score: 0, details: 'Invalid layout: ' + validation.errors.join(', ') };
            }

            // Deduct for warnings
            score -= validation.warnings.length * 5;

            // Check functional completeness
            const hasAudioStation = placements.some(p => p.assetId === 'audio_station' && p.roomId === 'THREE_STAR');
            const hasReadingTable = placements.some(p => p.assetId === 'reading_table' && p.roomId === 'SPECIAL_SPECIAL');
            const hasSeating = placements.some(p =>
                ['simple_pouf', 'stackable_chair', 'simple_stool'].includes(p.assetId)
            );

            if (!hasAudioStation) score -= 20;
            if (!hasReadingTable) score -= 20;
            if (!hasSeating) score -= 15;

            // Bonus for good distribution
            const threeStarCount = placements.filter(p => p.roomId === 'THREE_STAR').length;
            const specialSpecialCount = placements.filter(p => p.roomId === 'SPECIAL_SPECIAL').length;
            if (threeStarCount > 0 && specialSpecialCount > 0) score += 10;

            return {
                score: Math.max(0, Math.min(100, score)),
                details: validation.warnings.length > 0 ?
                    'Warnings: ' + validation.warnings.join(', ') : 'Good layout'
            };
        }

        // Convert Three.js position to placement format
        function objectToPlacement(obj, assetId, roomId) {
            return {
                assetId: assetId,
                roomId: roomId,
                x: obj.position.x,
                z: obj.position.z,
                rotation: (obj.rotation.y * 180 / Math.PI) % 360
            };
        }

        // Determine which room an object is in
        function getObjectRoom(obj) {
            const x = obj.position.x;
            const z = obj.position.z;

            for (const roomId in ROOM_GEOMETRY) {
                const room = ROOM_GEOMETRY[roomId];
                const b = room.bounds;
                if (x >= b.minX && x <= b.maxX && z >= b.minZ && z <= b.maxZ) {
                    return roomId;
                }
            }
            return null;
        }

        console.log('Layout validation system initialized');
        console.log('Asset whitelist:', Object.keys(ASSET_WHITELIST).length, 'items');
        console.log('Room geometries:', Object.keys(ROOM_GEOMETRY));

        // ============================================================
        // END LAYOUT VALIDATION SYSTEM
        // ============================================================

        // Window dimensions (from reference photos - MoMA PS1 industrial windows)
        // Tall rectangular windows with white frames, grid pattern
        const PS1_WINDOW_WIDTH = 1.3;      // ~4.25 feet
        const PS1_WINDOW_HEIGHT = 2.2;     // ~7.25 feet tall
        const PS1_WINDOW_SILL = 0.75;      // ~2.5 feet sill height
        const PS1_COLUMN_WIDTH = 0.25;     // White fluted columns between windows

        // Materials
        const wallMaterial = new THREE.MeshLambertMaterial({ color: 0xf8f8f5, side: THREE.DoubleSide });
        const ceilingMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff, side: THREE.DoubleSide }); // Pure white ceiling
        const brickMaterial = new THREE.MeshLambertMaterial({ color: 0xf0ebe5, side: THREE.DoubleSide });
        const floorMaterial = new THREE.MeshLambertMaterial({ color: 0xd4c8b8 });
        const darkBlueMaterial = new THREE.MeshLambertMaterial({ color: 0x2c3e5c });
        const windowFrameMaterial = new THREE.MeshLambertMaterial({ color: 0xe8e8e8 });
        const glassMaterial = new THREE.MeshLambertMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.25 });
        const woodMaterial = new THREE.MeshLambertMaterial({ color: 0xd4a76a });
        const ochreFloorMaterial = new THREE.MeshLambertMaterial({ color: 0xc9a227 });
        const redMaterial = new THREE.MeshLambertMaterial({ color: 0xc41e3a });

        // ============ AFRICAN TEXTILE PATTERN SYSTEM (must be before furniture) ============
        // Cache for textile textures
        const textileTextureCache = {};

        // Create canvas-based textures for African wax print patterns
        function createAfricanTextileTexture(patternType = 0) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            const patterns = [
                // Pattern 0: Red/Yellow floral
                () => {
                    ctx.fillStyle = '#d4382a';
                    ctx.fillRect(0, 0, 256, 256);
                    ctx.fillStyle = '#f4c430';
                    for (let x = 32; x < 256; x += 64) {
                        for (let y = 32; y < 256; y += 64) {
                            ctx.beginPath(); ctx.arc(x, y, 20, 0, Math.PI * 2); ctx.fill();
                            ctx.fillStyle = '#1a1a1a'; ctx.beginPath(); ctx.arc(x, y, 8, 0, Math.PI * 2); ctx.fill();
                            ctx.fillStyle = '#f4c430';
                        }
                    }
                },
                // Pattern 1: Blue diamond
                () => {
                    ctx.fillStyle = '#1e4d7b'; ctx.fillRect(0, 0, 256, 256);
                    ctx.fillStyle = '#87ceeb';
                    for (let y = 0; y < 256; y += 32) {
                        for (let x = (y % 64 === 0) ? 0 : 16; x < 256; x += 32) {
                            ctx.beginPath(); ctx.moveTo(x + 16, y); ctx.lineTo(x + 32, y + 16);
                            ctx.lineTo(x + 16, y + 32); ctx.lineTo(x, y + 16); ctx.closePath(); ctx.fill();
                        }
                    }
                },
                // Pattern 2: Orange/green medallions
                () => {
                    ctx.fillStyle = '#ff8c00'; ctx.fillRect(0, 0, 256, 256);
                    ctx.fillStyle = '#228b22';
                    for (let x = 64; x < 256; x += 128) {
                        for (let y = 64; y < 256; y += 128) {
                            ctx.beginPath(); ctx.arc(x, y, 40, 0, Math.PI * 2); ctx.fill();
                            ctx.fillStyle = '#ffd700'; ctx.beginPath(); ctx.arc(x, y, 25, 0, Math.PI * 2); ctx.fill();
                            ctx.fillStyle = '#ff6600'; ctx.beginPath(); ctx.arc(x, y, 12, 0, Math.PI * 2); ctx.fill();
                            ctx.fillStyle = '#228b22';
                        }
                    }
                },
                // Pattern 3: Pink/Cyan scallop
                () => {
                    ctx.fillStyle = '#ff69b4'; ctx.fillRect(0, 0, 256, 256);
                    ctx.fillStyle = '#00ced1';
                    for (let y = 0; y < 256; y += 48) {
                        for (let x = (y % 96 === 0) ? 0 : 24; x < 256; x += 48) {
                            ctx.beginPath(); ctx.arc(x + 24, y + 48, 24, Math.PI, 0); ctx.fill();
                        }
                    }
                },
                // Pattern 4: Teal/Yellow circles
                () => {
                    ctx.fillStyle = '#008b8b'; ctx.fillRect(0, 0, 256, 256);
                    ctx.fillStyle = '#ffd700';
                    for (let x = 40; x < 256; x += 80) {
                        for (let y = 40; y < 256; y += 80) {
                            ctx.beginPath(); ctx.arc(x, y, 30, 0, Math.PI * 2); ctx.fill();
                            ctx.fillStyle = '#1a1a1a'; ctx.beginPath(); ctx.arc(x, y, 15, 0, Math.PI * 2); ctx.fill();
                            ctx.fillStyle = '#ffd700';
                        }
                    }
                },
                // Pattern 5: Red/Gold lattice
                () => {
                    ctx.fillStyle = '#8b0000'; ctx.fillRect(0, 0, 256, 256);
                    ctx.strokeStyle = '#daa520'; ctx.lineWidth = 8;
                    for (let i = -256; i < 512; i += 32) {
                        ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i + 256, 256); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(i + 256, 0); ctx.lineTo(i, 256); ctx.stroke();
                    }
                },
                // Pattern 6: Purple/Pink florals
                () => {
                    ctx.fillStyle = '#4b0082'; ctx.fillRect(0, 0, 256, 256);
                    ctx.fillStyle = '#ff1493';
                    for (let y = 0; y < 256; y += 64) {
                        ctx.beginPath(); ctx.moveTo(0, y + 32);
                        for (let x = 0; x < 256; x += 32) ctx.quadraticCurveTo(x + 16, y + (x % 64 === 0 ? 0 : 64), x + 32, y + 32);
                        ctx.lineTo(256, y + 64); ctx.lineTo(0, y + 64); ctx.closePath(); ctx.fill();
                    }
                },
                // Pattern 7: Yellow/Red sunburst
                () => {
                    ctx.fillStyle = '#ffd700'; ctx.fillRect(0, 0, 256, 256);
                    ctx.fillStyle = '#dc143c';
                    for (let x = 64; x < 256; x += 128) {
                        for (let y = 64; y < 256; y += 128) {
                            for (let a = 0; a < Math.PI * 2; a += Math.PI / 8) {
                                ctx.beginPath(); ctx.moveTo(x, y);
                                ctx.lineTo(x + Math.cos(a) * 45, y + Math.sin(a) * 45);
                                ctx.lineTo(x + Math.cos(a + Math.PI / 16) * 45, y + Math.sin(a + Math.PI / 16) * 45);
                                ctx.closePath(); ctx.fill();
                            }
                        }
                    }
                },
                // Pattern 8: Orange/Teal abstract
                () => {
                    ctx.fillStyle = '#ff7f50'; ctx.fillRect(0, 0, 256, 256);
                    ctx.fillStyle = '#20b2aa';
                    for (let x = 0; x < 256; x += 64) {
                        for (let y = 0; y < 256; y += 64) {
                            ctx.beginPath(); ctx.ellipse(x + 32, y + 32, 25, 15, (x + y) * 0.02, 0, Math.PI * 2); ctx.fill();
                        }
                    }
                },
                // Pattern 9: Green/Blue kente
                () => {
                    ctx.fillStyle = '#006400'; ctx.fillRect(0, 0, 256, 256);
                    ctx.fillStyle = '#4169e1';
                    for (let i = 0; i < 256; i += 32) ctx.fillRect(i, 0, 16, 256);
                    ctx.fillStyle = '#ffd700';
                    for (let i = 0; i < 256; i += 64) ctx.fillRect(0, i, 256, 8);
                }
            ];

            patterns[patternType % patterns.length]();

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(2, 2);
            return texture;
        }

        function getTextileTexture(patternIndex) {
            if (!textileTextureCache[patternIndex]) {
                textileTextureCache[patternIndex] = createAfricanTextileTexture(patternIndex);
            }
            return textileTextureCache[patternIndex];
        }
        // ============ END TEXTILE PATTERN SYSTEM ============

        // Groups for visibility control
        const labelsGroup = new THREE.Group();
        const ceilingsGroup = new THREE.Group();
        const wallsGroup = new THREE.Group();
        const threeStarRoomWalls = { front: null, back: null, left: null, right: null, vestibuleLeft: null, vestibuleRight: null };
        const specialSpecialRoomWalls = { front: null, back: null, left: null, right: null };

        const gridHelper = new THREE.GridHelper(20, 40, 0x444444, 0x333333);
        scene.add(gridHelper);

        // Position rooms side by side (Three Star WEST/LEFT, Special Special EAST/RIGHT)
        const TOTAL_WIDTH = THREE_STAR_WIDTH + WALL_THICKNESS + SPECIAL_SPECIAL_WIDTH;
        const THREE_STAR_X = -TOTAL_WIDTH / 2 + THREE_STAR_WIDTH / 2;  // West (left)
        const SPECIAL_SPECIAL_X = TOTAL_WIDTH / 2 - SPECIAL_SPECIAL_WIDTH / 2;  // East (right)

        // ============ HELPER FUNCTIONS ============

        function createArchedWindow(width, height, archRadius, hasFabricFrame = true) {
            const group = new THREE.Group();
            const frameThickness = 0.08;

            // Glass
            const glassShape = new THREE.Shape();
            glassShape.moveTo(-width/2, 0);
            glassShape.lineTo(-width/2, height - archRadius);
            glassShape.quadraticCurveTo(-width/2, height, 0, height);
            glassShape.quadraticCurveTo(width/2, height, width/2, height - archRadius);
            glassShape.lineTo(width/2, 0);
            glassShape.lineTo(-width/2, 0);

            const glass = new THREE.Mesh(new THREE.ShapeGeometry(glassShape), glassMaterial);
            group.add(glass);

            // Frame bars
            const leftFrame = new THREE.Mesh(new THREE.BoxGeometry(frameThickness, height - archRadius, frameThickness), windowFrameMaterial);
            leftFrame.position.set(-width/2, (height - archRadius)/2, 0);
            group.add(leftFrame);

            const rightFrame = new THREE.Mesh(new THREE.BoxGeometry(frameThickness, height - archRadius, frameThickness), windowFrameMaterial);
            rightFrame.position.set(width/2, (height - archRadius)/2, 0);
            group.add(rightFrame);

            const bottomFrame = new THREE.Mesh(new THREE.BoxGeometry(width + frameThickness, frameThickness, frameThickness), windowFrameMaterial);
            bottomFrame.position.set(0, 0, 0);
            group.add(bottomFrame);

            const centerFrame = new THREE.Mesh(new THREE.BoxGeometry(frameThickness, height - archRadius, frameThickness), windowFrameMaterial);
            centerFrame.position.set(0, (height - archRadius)/2, 0);
            group.add(centerFrame);

            const middleFrame = new THREE.Mesh(new THREE.BoxGeometry(width, frameThickness, frameThickness), windowFrameMaterial);
            middleFrame.position.set(0, height * 0.4, 0);
            group.add(middleFrame);

            // Dark blue fabric frame
            if (hasFabricFrame) {
                const fabricWidth = width + 0.4;
                const fabricHeight = height + 0.3;
                const leftFabric = new THREE.Mesh(new THREE.BoxGeometry(0.15, fabricHeight, 0.02), darkBlueMaterial);
                leftFabric.position.set(-fabricWidth/2, fabricHeight/2, 0.02);
                group.add(leftFabric);
                const rightFabric = new THREE.Mesh(new THREE.BoxGeometry(0.15, fabricHeight, 0.02), darkBlueMaterial);
                rightFabric.position.set(fabricWidth/2, fabricHeight/2, 0.02);
                group.add(rightFabric);
                const topFabric = new THREE.Mesh(new THREE.BoxGeometry(fabricWidth, 0.15, 0.02), darkBlueMaterial);
                topFabric.position.set(0, fabricHeight - 0.1, 0.02);
                group.add(topFabric);
            }

            return group;
        }

        // MoMA PS1 style industrial window - tall rectangular with grid pattern
        function createPS1Window(width, height) {
            const group = new THREE.Group();

            // Glass pane
            const glass = new THREE.Mesh(
                new THREE.PlaneGeometry(width, height),
                glassMaterial
            );
            group.add(glass);

            // White window frame
            const frameThickness = 0.05;
            const frameMat = new THREE.MeshLambertMaterial({ color: 0xffffff });

            // Outer frame
            const topFrame = new THREE.Mesh(new THREE.BoxGeometry(width + 0.08, frameThickness, frameThickness), frameMat);
            topFrame.position.set(0, height/2, 0.02);
            group.add(topFrame);

            const bottomFrame = new THREE.Mesh(new THREE.BoxGeometry(width + 0.08, frameThickness, frameThickness), frameMat);
            bottomFrame.position.set(0, -height/2, 0.02);
            group.add(bottomFrame);

            const leftFrame = new THREE.Mesh(new THREE.BoxGeometry(frameThickness, height, frameThickness), frameMat);
            leftFrame.position.set(-width/2, 0, 0.02);
            group.add(leftFrame);

            const rightFrame = new THREE.Mesh(new THREE.BoxGeometry(frameThickness, height, frameThickness), frameMat);
            rightFrame.position.set(width/2, 0, 0.02);
            group.add(rightFrame);

            // Horizontal dividers (3 panes vertically = 2 dividers)
            const dividerH1 = new THREE.Mesh(new THREE.BoxGeometry(width, frameThickness * 0.7, frameThickness), frameMat);
            dividerH1.position.set(0, height * 0.2, 0.02);
            group.add(dividerH1);

            const dividerH2 = new THREE.Mesh(new THREE.BoxGeometry(width, frameThickness * 0.7, frameThickness), frameMat);
            dividerH2.position.set(0, -height * 0.2, 0.02);
            group.add(dividerH2);

            // Vertical center divider
            const centerV = new THREE.Mesh(new THREE.BoxGeometry(frameThickness * 0.7, height, frameThickness), frameMat);
            centerV.position.set(0, 0, 0.02);
            group.add(centerV);

            return group;
        }

        // Create white fluted column/pilaster (decorative element between windows)
        function createFlutedColumn(height) {
            const group = new THREE.Group();
            const columnMat = new THREE.MeshLambertMaterial({ color: 0xf5f5f0 });

            // Main column body
            const column = new THREE.Mesh(
                new THREE.BoxGeometry(PS1_COLUMN_WIDTH, height, 0.1),
                columnMat
            );
            column.position.set(0, height/2, 0);
            group.add(column);

            // Add fluting detail (vertical ridges)
            const fluteMat = new THREE.MeshLambertMaterial({ color: 0xe8e8e3 });
            for (let i = -2; i <= 2; i++) {
                const flute = new THREE.Mesh(
                    new THREE.BoxGeometry(0.02, height, 0.03),
                    fluteMat
                );
                flute.position.set(i * 0.05, height/2, 0.06);
                group.add(flute);
            }

            return group;
        }

        function createFloorCushion(color, size = 0.6) {
            const group = new THREE.Group();
            const cushion = new THREE.Mesh(new THREE.SphereGeometry(size / 2, 16, 12), new THREE.MeshLambertMaterial({ color }));
            cushion.scale.set(1, 0.5, 1);
            cushion.position.set(0, size * 0.25, 0);
            group.add(cushion);
            return group;
        }

        function createTuftedFloorMattress(width, depth) {
            const group = new THREE.Group();
            const mattress = new THREE.Mesh(new THREE.BoxGeometry(width, 0.2, depth), ochreFloorMaterial);
            mattress.position.set(0, 0.1, 0);
            group.add(mattress);
            const buttonMat = new THREE.MeshLambertMaterial({ color: 0xa88520 });
            for (let x = -width/2 + 0.3; x < width/2; x += 0.3) {
                for (let z = -depth/2 + 0.3; z < depth/2; z += 0.3) {
                    const button = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.05, 8), buttonMat);
                    button.position.set(x, 0.2, z);
                    group.add(button);
                }
            }
            return group;
        }

        function createLayeredRug(width, depth, color) {
            const group = new THREE.Group();
            const rug = new THREE.Mesh(new THREE.BoxGeometry(width, 0.02, depth), new THREE.MeshLambertMaterial({ color }));
            rug.position.set(0, 0.01, 0);
            group.add(rug);
            const borderMat = new THREE.MeshLambertMaterial({ color: 0x2d2d2d });
            const topBorder = new THREE.Mesh(new THREE.BoxGeometry(width, 0.025, 0.05), borderMat);
            topBorder.position.set(0, 0.02, -depth/2 + 0.025);
            group.add(topBorder);
            const bottomBorder = new THREE.Mesh(new THREE.BoxGeometry(width, 0.025, 0.05), borderMat);
            bottomBorder.position.set(0, 0.02, depth/2 - 0.025);
            group.add(bottomBorder);
            return group;
        }

        function createWoodenBookshelf(width, height, rows) {
            const group = new THREE.Group();
            const shelfWood = new THREE.MeshLambertMaterial({ color: 0xe8d4b8 });
            const backPanel = new THREE.Mesh(new THREE.BoxGeometry(width, height, 0.02), shelfWood);
            backPanel.position.set(0, height/2, 0);
            group.add(backPanel);

            const shelfSpacing = height / (rows + 1);
            for (let i = 1; i <= rows; i++) {
                const shelf = new THREE.Mesh(new THREE.BoxGeometry(width, 0.02, 0.15), shelfWood);
                shelf.position.set(0, i * shelfSpacing, 0.08);
                group.add(shelf);
                const bookCount = Math.floor(width / 0.2);
                const bookColors = [0x4ecdc4, 0xff6b6b, 0xffd93d, 0x45b7d1, 0x96ceb4, 0xa29bfe, 0xe17055, 0x00b894];
                for (let j = 0; j < bookCount; j++) {
                    const book = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, 0.02), new THREE.MeshLambertMaterial({ color: bookColors[j % bookColors.length] }));
                    book.position.set(-width/2 + 0.1 + j * 0.18, i * shelfSpacing + 0.12, 0.14);
                    group.add(book);
                }
            }
            return group;
        }

        function createPottedPlant() {
            const group = new THREE.Group();
            const pot = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.1, 0.2, 12), new THREE.MeshLambertMaterial({ color: 0xc4713d }));
            pot.position.set(0, 0.1, 0);
            group.add(pot);
            const soil = new THREE.Mesh(new THREE.CylinderGeometry(0.11, 0.11, 0.03, 12), new THREE.MeshLambertMaterial({ color: 0x4a3728 }));
            soil.position.set(0, 0.2, 0);
            group.add(soil);
            const leafMat = new THREE.MeshLambertMaterial({ color: 0x228b22 });
            for (let i = 0; i < 6; i++) {
                const leaf = new THREE.Mesh(new THREE.SphereGeometry(0.08 + Math.random() * 0.04, 8, 8), leafMat);
                leaf.position.set((Math.random() - 0.5) * 0.15, 0.35 + Math.random() * 0.15, (Math.random() - 0.5) * 0.15);
                leaf.scale.set(1, 0.6, 1);
                group.add(leaf);
            }
            return group;
        }

        function createPendantLight() {
            const group = new THREE.Group();
            const cord = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.8, 8), new THREE.MeshLambertMaterial({ color: 0x333333 }));
            cord.position.set(0, 0.4, 0);
            group.add(cord);
            const shade = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.25, 0.2, 16, 1, true), new THREE.MeshLambertMaterial({ color: 0xd4a76a, side: THREE.DoubleSide }));
            group.add(shade);
            const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), new THREE.MeshBasicMaterial({ color: 0xfffacd }));
            group.add(bulb);
            return group;
        }

        function createLowCoffeeTable() {
            const group = new THREE.Group();
            const tableMat = new THREE.MeshLambertMaterial({ color: 0xc4a77d });
            const top = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 0.04, 24), tableMat);
            top.position.set(0, 0.25, 0);
            group.add(top);
            for (let i = 0; i < 3; i++) {
                const angle = (i * 2 * Math.PI) / 3;
                const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.04, 0.23, 8), tableMat);
                leg.position.set(Math.cos(angle) * 0.25, 0.115, Math.sin(angle) * 0.25);
                group.add(leg);
            }
            return group;
        }

        function createRedBookDisplay() {
            const group = new THREE.Group();
            const bodyWidth = 0.7, bodyHeight = 0.9, bodyDepth = 0.5;
            const backPanel = new THREE.Mesh(new THREE.BoxGeometry(bodyWidth, bodyHeight, 0.03), redMaterial);
            backPanel.position.set(0, bodyHeight/2, -bodyDepth/2);
            group.add(backPanel);
            for (let i = 0; i < 4; i++) {
                const shelf = new THREE.Mesh(new THREE.BoxGeometry(bodyWidth - 0.05, 0.02, bodyDepth * 0.6), redMaterial);
                shelf.position.set(0, 0.15 + i * 0.2, -0.1);
                shelf.rotation.x = -0.2;
                group.add(shelf);
                const bookColors = [0xffffff, 0x4ecdc4, 0xff6b6b, 0xffd93d, 0x95e1d3];
                for (let j = 0; j < 5; j++) {
                    const book = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.15, 0.01), new THREE.MeshLambertMaterial({ color: bookColors[j] }));
                    book.position.set(-0.25 + j * 0.12, 0.25 + i * 0.2, 0);
                    book.rotation.x = -0.3;
                    group.add(book);
                }
            }
            const sideL = new THREE.Mesh(new THREE.BoxGeometry(0.03, bodyHeight, bodyDepth), redMaterial);
            sideL.position.set(-bodyWidth/2, bodyHeight/2, 0);
            group.add(sideL);
            const sideR = new THREE.Mesh(new THREE.BoxGeometry(0.03, bodyHeight, bodyDepth), redMaterial);
            sideR.position.set(bodyWidth/2, bodyHeight/2, 0);
            group.add(sideR);
            return group;
        }

        function createPosterWall(width, height) {
            const group = new THREE.Group();
            const baseWall = new THREE.Mesh(new THREE.PlaneGeometry(width, height), new THREE.MeshLambertMaterial({ color: 0xf5f0e8 }));
            group.add(baseWall);
            const posterColors = [0xff6b6b, 0xffd93d, 0x4ecdc4, 0x45b7d1, 0x96ceb4, 0xffeaa7, 0xdfe6e9, 0xfd79a8, 0x00b894, 0xe17055, 0x74b9ff, 0xa29bfe, 0x55efc4, 0xfdcb6e, 0xe84393];
            for (let i = 0; i < 60; i++) {
                const posterW = 0.15 + Math.random() * 0.3;
                const posterH = 0.2 + Math.random() * 0.35;
                const poster = new THREE.Mesh(new THREE.PlaneGeometry(posterW, posterH), new THREE.MeshLambertMaterial({ color: posterColors[Math.floor(Math.random() * posterColors.length)] }));
                poster.position.set((Math.random() - 0.5) * (width - posterW), (Math.random() - 0.5) * (height - posterH), 0.005 + i * 0.001);
                poster.rotation.z = (Math.random() - 0.5) * 0.1;
                group.add(poster);
            }
            return group;
        }

        // ============ PAN-AFRICAN LIBRARY (WEST) ============
        // LAYOUT: Windows on FRONT (+Z), Door to corridor on BACK (-Z) via VESTIBULE, Door to Sound Library on RIGHT (+X)
        // Has an entry vestibule/corridor - a narrow enclosed passage before the main room
        function createThreeStar() {
            const group = new THREE.Group();

            // Vestibule corridor dimensions - enclosed passage with side walls
            const CORRIDOR_WIDTH = 1.2;  // Narrow corridor width (~4 feet)
            const CORRIDOR_OFFSET_X = 0;  // Corridor centered on door

            // ========== FLOOR (entire room) ==========
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(THREE_STAR_WIDTH, THREE_STAR_DEPTH), floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(0, 0.01, 0);
            group.add(floor);

            // Dark blue carpet in main area (not in vestibule)
            const carpet = new THREE.Mesh(new THREE.PlaneGeometry(THREE_STAR_WIDTH - 0.5, THREE_STAR_DEPTH - VESTIBULE_DEPTH - 0.5), new THREE.MeshLambertMaterial({ color: 0x1a3a5c }));
            carpet.rotation.x = -Math.PI / 2;
            carpet.position.set(0, 0.02, VESTIBULE_DEPTH / 2);
            group.add(carpet);

            // ========== BACK WALL (-Z) - Door to corridor/STUDIO ==========
            const backWallGroup = new THREE.Group();
            const backWall1 = new THREE.Mesh(new THREE.BoxGeometry((THREE_STAR_WIDTH - DOOR_WIDTH) / 2, CEILING_HEIGHT, WALL_THICKNESS), wallMaterial);
            backWall1.position.set(-THREE_STAR_WIDTH / 4 - DOOR_WIDTH / 4, CEILING_HEIGHT / 2, -THREE_STAR_DEPTH / 2);
            backWallGroup.add(backWall1);
            const backWall2 = new THREE.Mesh(new THREE.BoxGeometry((THREE_STAR_WIDTH - DOOR_WIDTH) / 2, CEILING_HEIGHT, WALL_THICKNESS), wallMaterial);
            backWall2.position.set(THREE_STAR_WIDTH / 4 + DOOR_WIDTH / 4, CEILING_HEIGHT / 2, -THREE_STAR_DEPTH / 2);
            backWallGroup.add(backWall2);
            const backDoorHeader = new THREE.Mesh(new THREE.BoxGeometry(DOOR_WIDTH, CEILING_HEIGHT - DOOR_HEIGHT, WALL_THICKNESS), wallMaterial);
            backDoorHeader.position.set(0, DOOR_HEIGHT + (CEILING_HEIGHT - DOOR_HEIGHT) / 2, -THREE_STAR_DEPTH / 2);
            backWallGroup.add(backDoorHeader);
            group.add(backWallGroup);
            threeStarRoomWalls.back = backWallGroup;

            // ========== VESTIBULE CORRIDOR WALLS ==========
            // The vestibule is an enclosed corridor with:
            // - Two SIDE walls running from back wall (-Z) toward the room (+Z)
            // - One FRONT wall (partition) with a door opening to main room
            const vestibuleGroup = new THREE.Group();

            // LEFT side wall of vestibule (runs along Z axis)
            const vestibuleLeftSide = new THREE.Mesh(
                new THREE.BoxGeometry(WALL_THICKNESS, CEILING_HEIGHT, VESTIBULE_DEPTH),
                wallMaterial
            );
            vestibuleLeftSide.position.set(
                CORRIDOR_OFFSET_X - CORRIDOR_WIDTH / 2,
                CEILING_HEIGHT / 2,
                -THREE_STAR_DEPTH / 2 + VESTIBULE_DEPTH / 2
            );
            vestibuleGroup.add(vestibuleLeftSide);

            // RIGHT side wall of vestibule (runs along Z axis)
            const vestibuleRightSide = new THREE.Mesh(
                new THREE.BoxGeometry(WALL_THICKNESS, CEILING_HEIGHT, VESTIBULE_DEPTH),
                wallMaterial
            );
            vestibuleRightSide.position.set(
                CORRIDOR_OFFSET_X + CORRIDOR_WIDTH / 2,
                CEILING_HEIGHT / 2,
                -THREE_STAR_DEPTH / 2 + VESTIBULE_DEPTH / 2
            );
            vestibuleGroup.add(vestibuleRightSide);

            // FRONT partition wall of vestibule (with door opening to main room)
            // Left section of front partition
            const partitionLeftWidth = (THREE_STAR_WIDTH / 2) - (CORRIDOR_WIDTH / 2) - CORRIDOR_OFFSET_X;
            if (partitionLeftWidth > 0) {
                const partitionLeft = new THREE.Mesh(
                    new THREE.BoxGeometry(partitionLeftWidth, CEILING_HEIGHT, WALL_THICKNESS),
                    wallMaterial
                );
                partitionLeft.position.set(
                    -THREE_STAR_WIDTH / 2 + partitionLeftWidth / 2,
                    CEILING_HEIGHT / 2,
                    -THREE_STAR_DEPTH / 2 + VESTIBULE_DEPTH
                );
                vestibuleGroup.add(partitionLeft);
            }

            // Right section of front partition
            const partitionRightWidth = (THREE_STAR_WIDTH / 2) - (CORRIDOR_WIDTH / 2) + CORRIDOR_OFFSET_X;
            if (partitionRightWidth > 0) {
                const partitionRight = new THREE.Mesh(
                    new THREE.BoxGeometry(partitionRightWidth, CEILING_HEIGHT, WALL_THICKNESS),
                    wallMaterial
                );
                partitionRight.position.set(
                    THREE_STAR_WIDTH / 2 - partitionRightWidth / 2,
                    CEILING_HEIGHT / 2,
                    -THREE_STAR_DEPTH / 2 + VESTIBULE_DEPTH
                );
                vestibuleGroup.add(partitionRight);
            }

            // Header above vestibule door opening
            const vestibuleDoorHeader = new THREE.Mesh(
                new THREE.BoxGeometry(CORRIDOR_WIDTH, CEILING_HEIGHT - DOOR_HEIGHT, WALL_THICKNESS),
                wallMaterial
            );
            vestibuleDoorHeader.position.set(
                CORRIDOR_OFFSET_X,
                DOOR_HEIGHT + (CEILING_HEIGHT - DOOR_HEIGHT) / 2,
                -THREE_STAR_DEPTH / 2 + VESTIBULE_DEPTH
            );
            vestibuleGroup.add(vestibuleDoorHeader);

            group.add(vestibuleGroup);
            threeStarRoomWalls.vestibuleLeft = vestibuleLeftSide;
            threeStarRoomWalls.vestibuleRight = vestibuleRightSide;
            threeStarRoomWalls.vestibuleGroup = vestibuleGroup;  // Store entire vestibule for hiding

            // ========== FRONT WALL (+Z) - PS1 Industrial Windows ==========
            const frontWallGroup = new THREE.Group();

            // Wall below windows (sill area)
            const frontWallBase = new THREE.Mesh(
                new THREE.BoxGeometry(THREE_STAR_WIDTH, PS1_WINDOW_SILL, WALL_THICKNESS),
                wallMaterial
            );
            frontWallBase.position.set(0, PS1_WINDOW_SILL / 2, THREE_STAR_DEPTH / 2);
            frontWallGroup.add(frontWallBase);

            // Wall above windows
            const topWallHeight = CEILING_HEIGHT - PS1_WINDOW_SILL - PS1_WINDOW_HEIGHT;
            const frontWallTop = new THREE.Mesh(
                new THREE.BoxGeometry(THREE_STAR_WIDTH, topWallHeight, WALL_THICKNESS),
                wallMaterial
            );
            frontWallTop.position.set(0, PS1_WINDOW_SILL + PS1_WINDOW_HEIGHT + topWallHeight / 2, THREE_STAR_DEPTH / 2);
            frontWallGroup.add(frontWallTop);

            // Two windows with fluted column between them
            const windowSpacing = (THREE_STAR_WIDTH - PS1_COLUMN_WIDTH) / 2;
            const windowCenterY = PS1_WINDOW_SILL + PS1_WINDOW_HEIGHT / 2;

            // Left window
            const win1 = createPS1Window(PS1_WINDOW_WIDTH, PS1_WINDOW_HEIGHT);
            win1.position.set(-windowSpacing / 2, windowCenterY, THREE_STAR_DEPTH / 2 - 0.02);
            frontWallGroup.add(win1);

            // Right window
            const win2 = createPS1Window(PS1_WINDOW_WIDTH, PS1_WINDOW_HEIGHT);
            win2.position.set(windowSpacing / 2, windowCenterY, THREE_STAR_DEPTH / 2 - 0.02);
            frontWallGroup.add(win2);

            // Fluted column between windows
            const columnS202 = createFlutedColumn(PS1_WINDOW_HEIGHT);
            columnS202.position.set(0, PS1_WINDOW_SILL, THREE_STAR_DEPTH / 2 - 0.02);
            frontWallGroup.add(columnS202);

            // Wall sections on either side of windows
            const sideWallWidth = (THREE_STAR_WIDTH - windowSpacing * 2 - PS1_WINDOW_WIDTH * 2) / 2 + 0.3;
            if (sideWallWidth > 0.1) {
                const leftSide = new THREE.Mesh(
                    new THREE.BoxGeometry(sideWallWidth, PS1_WINDOW_HEIGHT, WALL_THICKNESS),
                    wallMaterial
                );
                leftSide.position.set(-THREE_STAR_WIDTH / 2 + sideWallWidth / 2, windowCenterY, THREE_STAR_DEPTH / 2);
                frontWallGroup.add(leftSide);

                const rightSide = new THREE.Mesh(
                    new THREE.BoxGeometry(sideWallWidth, PS1_WINDOW_HEIGHT, WALL_THICKNESS),
                    wallMaterial
                );
                rightSide.position.set(THREE_STAR_WIDTH / 2 - sideWallWidth / 2, windowCenterY, THREE_STAR_DEPTH / 2);
                frontWallGroup.add(rightSide);
            }

            group.add(frontWallGroup);
            threeStarRoomWalls.front = frontWallGroup;

            // ========== LEFT WALL (-X) - Wall with CLOSED DOOR to Pan-African Library ==========
            // From floor plan: Pan-African Library door is near the SOUTH (window) end of the west wall
            // The west wall runs the full depth of the room from north to south
            const leftWallGroup = new THREE.Group();

            // Wall X position (west wall of room) - flush with room boundary
            const leftWallX = -THREE_STAR_WIDTH / 2;

            // Room Z boundaries
            const roomSouthZ = THREE_STAR_DEPTH / 2;    // South - windows (+Z)
            const roomNorthZ = -THREE_STAR_DEPTH / 2;   // North - corridor entry (-Z)

            // Pan-African Library door position - near the SOUTH (window) end
            // From floor plan, door appears about 1.5m from the south wall
            const threeStarDoorCenterZ = roomSouthZ - 1.5;  // 1.5m from south wall
            const doorHalfWidth = DOOR_WIDTH / 2;

            // SOUTH segment: short wall between door and south wall (window wall)
            const southSegmentLength = roomSouthZ - (threeStarDoorCenterZ + doorHalfWidth);
            if (southSegmentLength > 0.05) {
                const leftWallSouth = new THREE.Mesh(
                    new THREE.BoxGeometry(WALL_THICKNESS, CEILING_HEIGHT, southSegmentLength),
                    wallMaterial
                );
                leftWallSouth.position.set(leftWallX, CEILING_HEIGHT / 2, roomSouthZ - southSegmentLength / 2);
                leftWallGroup.add(leftWallSouth);
            }

            // NORTH segment: long wall from door to north wall (runs past vestibule area)
            const northSegmentLength = (threeStarDoorCenterZ - doorHalfWidth) - roomNorthZ;
            if (northSegmentLength > 0.05) {
                const leftWallNorth = new THREE.Mesh(
                    new THREE.BoxGeometry(WALL_THICKNESS, CEILING_HEIGHT, northSegmentLength),
                    wallMaterial
                );
                leftWallNorth.position.set(leftWallX, CEILING_HEIGHT / 2, roomNorthZ + northSegmentLength / 2);
                leftWallGroup.add(leftWallNorth);
            }

            // Door header above the Pan-African Library door
            const leftDoorHeader = new THREE.Mesh(
                new THREE.BoxGeometry(WALL_THICKNESS, CEILING_HEIGHT - DOOR_HEIGHT, DOOR_WIDTH),
                wallMaterial
            );
            leftDoorHeader.position.set(leftWallX, DOOR_HEIGHT + (CEILING_HEIGHT - DOOR_HEIGHT) / 2, threeStarDoorCenterZ);
            leftWallGroup.add(leftDoorHeader);

            // Door opening to Pan-African Library - NO DOOR, just the opening
            // (Door and handle removed - just leaving the doorway)

            group.add(leftWallGroup);
            threeStarRoomWalls.left = leftWallGroup;

            // ========== RIGHT WALL (+X) - SHARED with Special Special ==========
            // REMOVED: This wall is created ONLY by Special Special as its left wall
            // to prevent duplicate walls and z-fighting/jumping issues
            // The shared wall is positioned at the exact boundary between rooms
            threeStarRoomWalls.right = null;  // No wall here - Special Special's left wall serves both rooms

            // ========== CEILING ==========
            const ceilingS202 = new THREE.Mesh(new THREE.PlaneGeometry(THREE_STAR_WIDTH, THREE_STAR_DEPTH), ceilingMaterial);
            ceilingS202.rotation.x = Math.PI / 2;
            ceilingS202.position.set(0, CEILING_HEIGHT, 0);
            ceilingS202.userData.isCeiling = true;
            group.add(ceilingS202);

            // ========== PAN-AFRICAN LIBRARY - Publications, Archives, Video ==========
            // CURATORIAL BRIEF: Collective listening space for sound library, radio,
            // DJ sets, readings, performances, poetry, round tables
            //
            // SPATIAL RULES:
            // - Primary function = LISTENING
            // - Clear central area for gatherings/performances
            // - Low seating that doesn't block circulation
            // - Speakers face inward, not blocked
            // - Minimum 1.1m circulation paths

            const mainRoomZ = VESTIBULE_DEPTH / 2 + 0.8;  // Center after vestibule
            const windowZ = THREE_STAR_DEPTH / 2 - 1.2;    // Near window wall (inside boundary)

            // Helper to add furniture with proper marking
            function addFurniture(item, name) {
                item.userData.isFurniture = true;
                item.userData.itemType = name;
                item.name = name;
                group.add(item);
            }

            // === BANQUETTE-SHELF UNITS along walls ===
            // Long banquette against left wall (west)
            const banquetteLeft = createBanquetteShelfUnit(4.0);
            banquetteLeft.position.set(-THREE_STAR_WIDTH / 2 + 0.3, 0, mainRoomZ);
            banquetteLeft.rotation.y = Math.PI / 2;
            addFurniture(banquetteLeft, 'banquette-left');

            // Banquette against right wall (east) - shorter to avoid door
            const banquetteRight = createBanquetteShelfUnit(3.2);
            banquetteRight.position.set(THREE_STAR_WIDTH / 2 - 0.3, 0, mainRoomZ + 0.5);
            banquetteRight.rotation.y = -Math.PI / 2;
            addFurniture(banquetteRight, 'banquette-right');

            // Banquette along back wall (near windows)
            const banquetteBack = createBanquetteShelfUnit(3.5);
            banquetteBack.position.set(0, 0, windowZ - 0.3);
            banquetteBack.rotation.y = Math.PI;
            addFurniture(banquetteBack, 'banquette-back');

            // === VINYL RECORD TABLES in center area ===
            const recordTable1 = createVinylRecordTable('ngoma');
            recordTable1.position.set(-1.2, 0, mainRoomZ);
            addFurniture(recordTable1, 'table-ngoma');

            const recordTable2 = createVinylRecordTable('bantou');
            recordTable2.position.set(0, 0, mainRoomZ - 1.0);
            addFurniture(recordTable2, 'table-bantou');

            const recordTable3 = createVinylRecordTable('african-jazz');
            recordTable3.position.set(1.2, 0, mainRoomZ);
            addFurniture(recordTable3, 'table-jazz');

            const recordTable4 = createVinylRecordTable('pathe');
            recordTable4.position.set(0, 0, mainRoomZ + 1.0);
            addFurniture(recordTable4, 'table-pathe');

            // === CARDBOARD CUBE STOOLS scattered around tables ===
            const cubeStool1 = createCardboardCubeStool('branches');
            cubeStool1.position.set(-1.6, 0, mainRoomZ - 0.5);
            addFurniture(cubeStool1, 'stool-branches-1');

            const cubeStool2 = createCardboardCubeStool('african-pattern');
            cubeStool2.position.set(-0.6, 0, mainRoomZ - 1.5);
            addFurniture(cubeStool2, 'stool-pattern-1');

            const cubeStool3 = createCardboardCubeStool('benin');
            cubeStool3.position.set(0.6, 0, mainRoomZ - 1.5);
            addFurniture(cubeStool3, 'stool-benin-1');

            const cubeStool4 = createCardboardCubeStool('text');
            cubeStool4.position.set(1.6, 0, mainRoomZ - 0.5);
            addFurniture(cubeStool4, 'stool-text-1');

            const cubeStool5 = createCardboardCubeStool('branches');
            cubeStool5.position.set(-0.8, 0, mainRoomZ + 0.5);
            addFurniture(cubeStool5, 'stool-branches-2');

            const cubeStool6 = createCardboardCubeStool('african-pattern');
            cubeStool6.position.set(0.8, 0, mainRoomZ + 0.5);
            addFurniture(cubeStool6, 'stool-pattern-2');

            // === WOVEN MATS on floor ===
            const listeningMat = createAfricanNatte();
            listeningMat.position.set(0, 0.01, mainRoomZ);
            addFurniture(listeningMat, 'natte-mat');

            // === AFRIKADAA WALL ART (on walls not covered by banquettes) ===
            const posterWallX = -THREE_STAR_WIDTH / 2 + 0.16;

            const afrikadaaPoster1 = createAfrikadaaPoster('AFRIKADAA', 0xc41e3a, 0.5, 0.7);
            afrikadaaPoster1.position.set(posterWallX, 2.2, mainRoomZ - 2.5);
            afrikadaaPoster1.rotation.y = Math.PI / 2;
            afrikadaaPoster1.userData.isWallArt = true;
            addFurniture(afrikadaaPoster1, 'poster-afrikadaa-1');

            const afrikadaaPoster2 = createAfrikadaaPoster('PANAFRICAN', 0xfdd835, 0.4, 0.5);
            afrikadaaPoster2.position.set(posterWallX, 2.0, mainRoomZ + 2.0);
            afrikadaaPoster2.rotation.y = Math.PI / 2;
            afrikadaaPoster2.userData.isWallArt = true;
            addFurniture(afrikadaaPoster2, 'poster-afrikadaa-2');

            return group;
        }

        // ============ SPECIAL SPECIAL / SOUND LIBRARY (EAST) ============
        // LAYOUT: Windows on FRONT (+Z), Entry CORRIDOR on BACK (-Z), Door to Pan-African Library on LEFT (-X)
        // The room has an L-shaped corridor entry from the main hallway
        function createSpecialSpecial() {
            const group = new THREE.Group();

            // Total depth including corridor
            const TOTAL_DEPTH = SPECIAL_SPECIAL_DEPTH + SPECIAL_SPECIAL_CORRIDOR_DEPTH;

            // Main room floor
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(SPECIAL_SPECIAL_WIDTH, SPECIAL_SPECIAL_DEPTH), floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(0, 0.01, SPECIAL_SPECIAL_CORRIDOR_DEPTH / 2);  // Offset forward to make room for corridor
            group.add(floor);

            // Corridor floor (entry corridor at back)
            const corridorFloor = new THREE.Mesh(new THREE.PlaneGeometry(SPECIAL_SPECIAL_WIDTH, SPECIAL_SPECIAL_CORRIDOR_DEPTH), floorMaterial);
            corridorFloor.rotation.x = -Math.PI / 2;
            corridorFloor.position.set(0, 0.01, -SPECIAL_SPECIAL_DEPTH / 2);
            group.add(corridorFloor);

            // ========== CORRIDOR WALLS ==========
            // Back wall of corridor (-Z) with entry door from main hallway
            const corridorBackGroup = new THREE.Group();
            const corridorBackZ = -SPECIAL_SPECIAL_DEPTH / 2 - SPECIAL_SPECIAL_CORRIDOR_DEPTH / 2;

            // Door is on the right side of the corridor back wall
            const corridorDoorOffsetX = SPECIAL_SPECIAL_WIDTH / 4;

            // Left section of corridor back wall
            const corridorBackLeftWidth = SPECIAL_SPECIAL_WIDTH / 2 + corridorDoorOffsetX - DOOR_WIDTH / 2;
            const corridorBackLeft = new THREE.Mesh(
                new THREE.BoxGeometry(corridorBackLeftWidth, CEILING_HEIGHT, WALL_THICKNESS),
                brickMaterial
            );
            corridorBackLeft.position.set(-SPECIAL_SPECIAL_WIDTH / 2 + corridorBackLeftWidth / 2, CEILING_HEIGHT / 2, corridorBackZ);
            corridorBackGroup.add(corridorBackLeft);

            // Right section (small, door side)
            const corridorBackRightWidth = SPECIAL_SPECIAL_WIDTH / 2 - corridorDoorOffsetX - DOOR_WIDTH / 2;
            if (corridorBackRightWidth > 0.1) {
                const corridorBackRight = new THREE.Mesh(
                    new THREE.BoxGeometry(corridorBackRightWidth, CEILING_HEIGHT, WALL_THICKNESS),
                    brickMaterial
                );
                corridorBackRight.position.set(SPECIAL_SPECIAL_WIDTH / 2 - corridorBackRightWidth / 2, CEILING_HEIGHT / 2, corridorBackZ);
                corridorBackGroup.add(corridorBackRight);
            }

            // Door header above corridor entry
            const corridorDoorHeader = new THREE.Mesh(
                new THREE.BoxGeometry(DOOR_WIDTH, CEILING_HEIGHT - DOOR_HEIGHT, WALL_THICKNESS),
                brickMaterial
            );
            corridorDoorHeader.position.set(corridorDoorOffsetX, DOOR_HEIGHT + (CEILING_HEIGHT - DOOR_HEIGHT) / 2, corridorBackZ);
            corridorBackGroup.add(corridorDoorHeader);

            group.add(corridorBackGroup);
            specialSpecialRoomWalls.back = corridorBackGroup;

            // Corridor side walls (short walls extending from main room to back)
            // Left corridor wall (shared with Three Star room)
            const corridorLeftWall = new THREE.Mesh(
                new THREE.BoxGeometry(WALL_THICKNESS, CEILING_HEIGHT, SPECIAL_SPECIAL_CORRIDOR_DEPTH),
                brickMaterial
            );
            corridorLeftWall.position.set(-SPECIAL_SPECIAL_WIDTH / 2, CEILING_HEIGHT / 2, -SPECIAL_SPECIAL_DEPTH / 2);
            group.add(corridorLeftWall);

            // Right corridor wall
            const corridorRightWall = new THREE.Mesh(
                new THREE.BoxGeometry(WALL_THICKNESS, CEILING_HEIGHT, SPECIAL_SPECIAL_CORRIDOR_DEPTH),
                brickMaterial
            );
            corridorRightWall.position.set(SPECIAL_SPECIAL_WIDTH / 2, CEILING_HEIGHT / 2, -SPECIAL_SPECIAL_DEPTH / 2);
            group.add(corridorRightWall);

            // ========== MAIN ROOM WALLS ==========
            // Transition wall between corridor and main room (partial wall with opening)
            // This creates the L-shape entrance feel
            const transitionZ = SPECIAL_SPECIAL_CORRIDOR_DEPTH / 2 - SPECIAL_SPECIAL_DEPTH / 2 + SPECIAL_SPECIAL_CORRIDOR_DEPTH / 2;
            // (No physical wall here - open transition from corridor to main room)

            // FRONT WALL (+Z) - PS1 Industrial Windows (same style as S202)
            const frontWallGroup = new THREE.Group();

            // Wall below windows
            const frontWallBase = new THREE.Mesh(
                new THREE.BoxGeometry(SPECIAL_SPECIAL_WIDTH, PS1_WINDOW_SILL, WALL_THICKNESS),
                brickMaterial
            );
            frontWallBase.position.set(0, PS1_WINDOW_SILL / 2, SPECIAL_SPECIAL_DEPTH / 2);
            frontWallGroup.add(frontWallBase);

            // Wall above windows
            const topWallHeightS203 = CEILING_HEIGHT - PS1_WINDOW_SILL - PS1_WINDOW_HEIGHT;
            const frontWallTop = new THREE.Mesh(
                new THREE.BoxGeometry(SPECIAL_SPECIAL_WIDTH, topWallHeightS203, WALL_THICKNESS),
                brickMaterial
            );
            frontWallTop.position.set(0, PS1_WINDOW_SILL + PS1_WINDOW_HEIGHT + topWallHeightS203 / 2, SPECIAL_SPECIAL_DEPTH / 2);
            frontWallGroup.add(frontWallTop);

            // Room S203 is wider, so it can have 3 windows with 2 columns
            const windowCenterYS203 = PS1_WINDOW_SILL + PS1_WINDOW_HEIGHT / 2;
            const totalWindowArea = SPECIAL_SPECIAL_WIDTH - 0.4;  // Leave some wall on sides
            const numWindows = 3;
            const numColumns = 2;
            const windowWidthS203 = (totalWindowArea - numColumns * PS1_COLUMN_WIDTH) / numWindows;
            const windowSpacingS203 = windowWidthS203 + PS1_COLUMN_WIDTH;

            // Create 3 windows with columns between
            for (let i = 0; i < numWindows; i++) {
                const xPos = -totalWindowArea / 2 + windowWidthS203 / 2 + i * windowSpacingS203;
                const win = createPS1Window(windowWidthS203 * 0.9, PS1_WINDOW_HEIGHT);
                win.position.set(xPos, windowCenterYS203, SPECIAL_SPECIAL_DEPTH / 2 - 0.02);
                frontWallGroup.add(win);

                // Add column after each window except the last
                if (i < numWindows - 1) {
                    const col = createFlutedColumn(PS1_WINDOW_HEIGHT);
                    col.position.set(xPos + windowSpacingS203 / 2, PS1_WINDOW_SILL, SPECIAL_SPECIAL_DEPTH / 2 - 0.02);
                    frontWallGroup.add(col);
                }
            }

            // Side wall sections
            const sideWidthS203 = 0.2;
            const leftSideS203 = new THREE.Mesh(
                new THREE.BoxGeometry(sideWidthS203, PS1_WINDOW_HEIGHT, WALL_THICKNESS),
                brickMaterial
            );
            leftSideS203.position.set(-SPECIAL_SPECIAL_WIDTH / 2 + sideWidthS203 / 2, windowCenterYS203, SPECIAL_SPECIAL_DEPTH / 2);
            frontWallGroup.add(leftSideS203);

            const rightSideS203 = new THREE.Mesh(
                new THREE.BoxGeometry(sideWidthS203, PS1_WINDOW_HEIGHT, WALL_THICKNESS),
                brickMaterial
            );
            rightSideS203.position.set(SPECIAL_SPECIAL_WIDTH / 2 - sideWidthS203 / 2, windowCenterYS203, SPECIAL_SPECIAL_DEPTH / 2);
            frontWallGroup.add(rightSideS203);

            group.add(frontWallGroup);
            specialSpecialRoomWalls.front = frontWallGroup;

            // LEFT WALL (-X) - SHARED WALL with Room S202
            // This is the ONLY dividing wall between rooms (S202 does not create a right wall)
            // Position it at the left edge of S203, centered on the wall thickness
            const leftWall = new THREE.Mesh(
                new THREE.BoxGeometry(WALL_THICKNESS, CEILING_HEIGHT, SPECIAL_SPECIAL_DEPTH),
                brickMaterial
            );
            // Position exactly at room edge minus half wall thickness so it's centered between rooms
            leftWall.position.set(-SPECIAL_SPECIAL_WIDTH / 2 - WALL_THICKNESS / 2, CEILING_HEIGHT / 2, 0);
            group.add(leftWall);
            specialSpecialRoomWalls.left = leftWall;

            // RIGHT WALL (+X) - Solid exterior wall
            const rightWall = new THREE.Mesh(new THREE.BoxGeometry(WALL_THICKNESS, CEILING_HEIGHT, SPECIAL_SPECIAL_DEPTH), brickMaterial);
            rightWall.position.set(SPECIAL_SPECIAL_WIDTH / 2, CEILING_HEIGHT / 2, 0);
            group.add(rightWall);
            specialSpecialRoomWalls.right = rightWall;

            // Ceiling
            const ceilingS203 = new THREE.Mesh(new THREE.PlaneGeometry(SPECIAL_SPECIAL_WIDTH, SPECIAL_SPECIAL_DEPTH), ceilingMaterial);
            ceilingS203.rotation.x = Math.PI / 2;
            ceilingS203.position.set(0, CEILING_HEIGHT, 0);
            ceilingS203.userData.isCeiling = true;
            group.add(ceilingS203);

            // ========== SOUND LIBRARY - Audio/Radio/DJ/Collective Listening ==========
            // CURATORIAL BRIEF: Reading room for ~50 publications, AABF archives,
            // video interviews, publishing network mapping
            //
            // FUNCTIONS: Read, browse, watch, listen, move quietly
            //
            // SPATIAL RULES:
            // - Reading/browsing are PRIMARY
            // - Books visible, legible, face-up or face-out
            // - Clear viewing direction for screens
            // - Minimum 1.1m circulation paths
            // - 1.2m clearance from door
            // - NO domestic furniture (sofas, armchairs, coffee tables)

            // Helper to add furniture with proper marking
            function addFurniture(item, name, isWall = false) {
                item.userData.isFurniture = true;
                item.userData.itemType = name;
                item.userData.isWallArt = isWall;
                item.name = name;
                group.add(item);
            }

            // === SOUND LIBRARY MAIN ROOM ===
            // Offset for main room (corridor is at back)
            const mainRoomOffsetZ = SPECIAL_SPECIAL_CORRIDOR_DEPTH / 2;

            // === BANQUETTE-SHELF along right wall ===
            const banquetteSound = createBanquetteShelfUnit(2.8);
            banquetteSound.position.set(SPECIAL_SPECIAL_WIDTH / 2 - 0.3, 0, mainRoomOffsetZ + 0.5);
            banquetteSound.rotation.y = -Math.PI / 2;
            addFurniture(banquetteSound, 'banquette-sound');

            // === DJ / AUDIO STATION ===
            const audioStation = createAudioStation();
            audioStation.position.set(-SPECIAL_SPECIAL_WIDTH / 2 + 0.5, 0, mainRoomOffsetZ);
            audioStation.rotation.y = Math.PI / 2;
            addFurniture(audioStation, 'dj-station');

            // === VINYL RECORD TABLES ===
            const recordTable1 = createVinylRecordTable('ngoma');
            recordTable1.position.set(0, 0, mainRoomOffsetZ);
            addFurniture(recordTable1, 'sound-table-1');

            const recordTable2 = createVinylRecordTable('bantou');
            recordTable2.position.set(-0.8, 0, mainRoomOffsetZ + 1.2);
            addFurniture(recordTable2, 'sound-table-2');

            // === CARDBOARD CUBE STOOLS ===
            const cubeStool1 = createCardboardCubeStool('branches');
            cubeStool1.position.set(0.5, 0, mainRoomOffsetZ - 0.6);
            addFurniture(cubeStool1, 'sound-stool-1');

            const cubeStool2 = createCardboardCubeStool('african-pattern');
            cubeStool2.position.set(-0.5, 0, mainRoomOffsetZ + 0.6);
            addFurniture(cubeStool2, 'sound-stool-2');

            const cubeStool3 = createCardboardCubeStool('benin');
            cubeStool3.position.set(0.8, 0, mainRoomOffsetZ + 1.5);
            addFurniture(cubeStool3, 'sound-stool-3');

            // === FLOOR SEATING (poufs and mats) ===
            const pouf1 = createSimplePouf(0xc41e3a);
            pouf1.position.set(-0.3, 0, mainRoomOffsetZ + 1.8);
            addFurniture(pouf1, 'pouf-sound-1');

            const pouf2 = createSimplePouf(0x8b4513);
            pouf2.position.set(0.6, 0, mainRoomOffsetZ + 2.0);
            addFurniture(pouf2, 'pouf-sound-2');

            const natteSound = createAfricanNatte();
            natteSound.position.set(0, 0.01, mainRoomOffsetZ + 1.5);
            addFurniture(natteSound, 'natte-sound');

            // === SPEAKERS ===
            const speaker1 = createFloorSpeaker();
            speaker1.position.set(-SPECIAL_SPECIAL_WIDTH / 2 + 0.25, 0, mainRoomOffsetZ + SPECIAL_SPECIAL_DEPTH / 2 - 0.3);
            speaker1.rotation.y = Math.PI * 0.75;
            addFurniture(speaker1, 'speaker-left');

            const speaker2 = createFloorSpeaker();
            speaker2.position.set(SPECIAL_SPECIAL_WIDTH / 2 - 0.25, 0, mainRoomOffsetZ + SPECIAL_SPECIAL_DEPTH / 2 - 0.3);
            speaker2.rotation.y = Math.PI * 1.25;
            addFurniture(speaker2, 'speaker-right');

            // === HEADPHONE STATIONS ===
            const headphones1 = createHeadphoneStation();
            headphones1.position.set(-SPECIAL_SPECIAL_WIDTH / 2 + 0.35, 0, mainRoomOffsetZ + 1.0);
            addFurniture(headphones1, 'headphone-station-1');

            const headphones2 = createHeadphoneStation();
            headphones2.position.set(-SPECIAL_SPECIAL_WIDTH / 2 + 0.35, 0, mainRoomOffsetZ - 0.5);
            addFurniture(headphones2, 'headphone-station-2');

            const viewStool1 = createSimpleStool();
            viewStool1.position.set(-0.8, 0, 1.8);
            addFurniture(viewStool1, 'stool-1');

            const viewStool2 = createSimpleStool();
            viewStool2.position.set(0.8, 0, 1.8);
            addFurniture(viewStool2, 'stool-2');

            // === AFRIKADAA POSTER WALL ===
            const posterA1 = createAfrikadaaPoster('AFRIKADAA', 0xd32f2f, 0.55, 0.75);
            posterA1.position.set(-SPECIAL_SPECIAL_WIDTH / 2 + 0.02, 1.7, -1.8);
            posterA1.rotation.y = Math.PI / 2;
            addFurniture(posterA1, 'poster-s203-1', true);

            const posterA2 = createAfrikadaaPoster('AFRICA', 0xfbc02d, 0.45, 0.6);
            posterA2.position.set(-SPECIAL_SPECIAL_WIDTH / 2 + 0.02, 1.5, -0.8);
            posterA2.rotation.y = Math.PI / 2;
            addFurniture(posterA2, 'poster-s203-2', true);

            const posterA3 = createAfrikadaaPoster('DIASPORA', 0x1976d2, 0.5, 0.65);
            posterA3.position.set(-SPECIAL_SPECIAL_WIDTH / 2 + 0.02, 1.75, 0.3);
            posterA3.rotation.y = Math.PI / 2;
            addFurniture(posterA3, 'poster-s203-3', true);

            const posterA4 = createAfrikadaaPoster('PANAFRICAN', 0x388e3c, 0.4, 0.55);
            posterA4.position.set(-SPECIAL_SPECIAL_WIDTH / 2 + 0.02, 1.45, 1.4);
            posterA4.rotation.y = Math.PI / 2;
            addFurniture(posterA4, 'poster-s203-4', true);

            const posterA5 = createAfrikadaaPoster('LIBRARY', 0x7b1fa2, 0.48, 0.68);
            posterA5.position.set(-SPECIAL_SPECIAL_WIDTH / 2 + 0.02, 1.65, 2.5);
            posterA5.rotation.y = Math.PI / 2;
            addFurniture(posterA5, 'poster-s203-5', true);

            // === MINIMAL LIGHTING ===
            const pendant1 = createSimplePendant();
            pendant1.position.set(0, CEILING_HEIGHT - 0.4, -0.5);
            addFurniture(pendant1, 'pendant-s203-1');

            const pendant2 = createSimplePendant();
            pendant2.position.set(0, CEILING_HEIGHT - 0.4, 2.0);
            addFurniture(pendant2, 'pendant-s203-2');

            return group;
        }

        // Create and position rooms
        const threeStarRoom = createThreeStar();
        threeStarRoom.position.set(THREE_STAR_X, 0, 0);
        scene.add(threeStarRoom);

        const specialSpecialRoom = createSpecialSpecial();
        specialSpecialRoom.position.set(SPECIAL_SPECIAL_X, 0, 0);
        scene.add(specialSpecialRoom);

        // ============================================================
        // MAKE ALL DEFAULT FURNITURE EDITABLE
        // Items marked with userData.isFurniture are moved to scene root
        // and added to placedItems array for selection/editing
        // ============================================================
        function registerEditableFurniture() {
            function processRoom(roomGroup) {
                const furnitureToMove = [];

                // Find all direct children marked as furniture
                roomGroup.children.forEach(child => {
                    if (child.userData.isFurniture) {
                        furnitureToMove.push(child);
                    }
                });

                // Move furniture from room group to scene directly
                furnitureToMove.forEach(item => {
                    // Calculate world position
                    const worldPos = new THREE.Vector3();
                    item.getWorldPosition(worldPos);
                    const worldRot = item.rotation.clone();

                    // Remove from room group
                    roomGroup.remove(item);

                    // Add to scene directly with world position
                    item.position.copy(worldPos);
                    item.rotation.copy(worldRot);
                    item.userData.isPlacedItem = true;

                    scene.add(item);
                    placedItems.push(item);
                });
            }

            processRoom(threeStarRoom);
            processRoom(specialSpecialRoom);

            console.log('Registered', placedItems.length, 'editable furniture items');
        }

        // Register furniture after a short delay to ensure scene is ready
        setTimeout(registerEditableFurniture, 100);

        // Room labels
        function createLabel(text, position) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 128;
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 32px Helvetica';
            ctx.textAlign = 'center';
            ctx.fillText(text, canvas.width / 2, canvas.height / 2 + 10);
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(2.5, 0.6, 1);
            sprite.position.copy(position);
            return sprite;
        }

        labelsGroup.add(createLabel('THREE STAR (WEST)', new THREE.Vector3(THREE_STAR_X, CEILING_HEIGHT + 0.5, 0)));
        labelsGroup.add(createLabel('SPECIAL SPECIAL (EAST)', new THREE.Vector3(SPECIAL_SPECIAL_X, CEILING_HEIGHT + 0.5, 0)));
        scene.add(labelsGroup);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
        directionalLight.position.set(10, 15, 10);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
        fillLight.position.set(-10, 10, -10);
        scene.add(fillLight);
        const threeStarRoomLight = new THREE.PointLight(0xffffee, 0.4, 12);
        threeStarRoomLight.position.set(THREE_STAR_X, CEILING_HEIGHT - 0.5, 0);
        scene.add(threeStarRoomLight);
        const specialSpecialRoomLight = new THREE.PointLight(0xffffee, 0.4, 12);
        specialSpecialRoomLight.position.set(SPECIAL_SPECIAL_X, CEILING_HEIGHT - 0.5, 0);
        scene.add(specialSpecialRoomLight);

        // Camera controls
        let isMouseDown = false;
        let mouseX = 0, mouseY = 0;
        // Default view: Overview (bird's eye) - matching the 'overview' preset
        let targetRotationX = 0, targetRotationY = 0.5;
        let currentRotationX = 0, currentRotationY = 0.5;
        let cameraDistance = 18;
        let cameraTarget = new THREE.Vector3(0, 2, 0);

        // Set initial camera position for overview
        camera.position.set(0, 18 * Math.sin(0.5), -18 * Math.cos(0.5));
        camera.lookAt(cameraTarget);

        container.addEventListener('mousedown', (e) => {
            if (!isCameraOrbitBlocked) {
                isMouseDown = true;
                mouseX = e.clientX;
                mouseY = e.clientY;
            }
        });
        container.addEventListener('mouseup', () => isMouseDown = false);
        container.addEventListener('mouseleave', () => isMouseDown = false);

        container.addEventListener('mousemove', (e) => {
            if (!isMouseDown || isCameraOrbitBlocked) return;
            targetRotationX += (e.clientX - mouseX) * 0.005;
            targetRotationY += (e.clientY - mouseY) * 0.005;
            targetRotationY = Math.max(-0.5, Math.min(1.2, targetRotationY));
            mouseX = e.clientX; mouseY = e.clientY;
        });

        container.addEventListener('wheel', (e) => {
            cameraDistance += e.deltaY * 0.01;
            cameraDistance = Math.max(3, Math.min(35, cameraDistance));
        });

        const keys = {};
        document.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
        document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

        // Touch controls
        container.addEventListener('touchstart', (e) => { isMouseDown = true; mouseX = e.touches[0].clientX; mouseY = e.touches[0].clientY; });
        container.addEventListener('touchend', () => isMouseDown = false);
        container.addEventListener('touchmove', (e) => {
            if (!isMouseDown) return;
            targetRotationX += (e.touches[0].clientX - mouseX) * 0.005;
            targetRotationY += (e.touches[0].clientY - mouseY) * 0.005;
            targetRotationY = Math.max(-0.5, Math.min(1.2, targetRotationY));
            mouseX = e.touches[0].clientX; mouseY = e.touches[0].clientY;
        });

        // View presets - CORRECTED FOR DOOR ENTRY PERSPECTIVE
        // Entry views: Camera at BACK (door, -Z) looking FORWARD toward windows (+Z)
        // rotX=0 means camera is at front looking back, rotX=Math.PI means camera at back looking forward
        const views = {
            overview: { rotX: 0, rotY: 0.5, dist: 18, target: new THREE.Vector3(0, 2, 0) },
            floorPlan: { rotX: 0, rotY: 1.5, dist: 14, target: new THREE.Vector3(0, 0, 0) },
            // Room S202 views - Entry through vestibule door, looking toward windows
            // rotX=Math.PI puts camera at -Z (door) looking toward +Z (windows)
            threeStarRoomEntry: { rotX: Math.PI, rotY: 0.15, dist: 3, target: new THREE.Vector3(THREE_STAR_X, 1.5, -THREE_STAR_DEPTH / 2 + 1) },
            threeStarRoomInside: { rotX: Math.PI, rotY: 0.2, dist: 5, target: new THREE.Vector3(THREE_STAR_X, 1.5, 0) },
            threeStarRoomWindows: { rotX: Math.PI, rotY: 0.15, dist: 4, target: new THREE.Vector3(THREE_STAR_X, 1.5, THREE_STAR_DEPTH / 4) },
            threeStarRoomTable: { rotX: Math.PI * 0.8, rotY: 0.25, dist: 4, target: new THREE.Vector3(THREE_STAR_X, 0.8, 0) },
            // Room S203 views - Entry through corridor door, looking toward arched windows
            specialSpecialRoomEntry: { rotX: Math.PI, rotY: 0.15, dist: 3, target: new THREE.Vector3(SPECIAL_SPECIAL_X, 1.5, -SPECIAL_SPECIAL_DEPTH / 2 + 1) },
            specialSpecialRoomInside: { rotX: Math.PI, rotY: 0.2, dist: 6, target: new THREE.Vector3(SPECIAL_SPECIAL_X, 1.5, 0) },
            specialSpecialRoomWindows: { rotX: Math.PI, rotY: 0.15, dist: 4, target: new THREE.Vector3(SPECIAL_SPECIAL_X, 1.5, SPECIAL_SPECIAL_DEPTH / 4) },
            specialSpecialRoomSeating: { rotX: Math.PI * 0.7, rotY: 0.2, dist: 4, target: new THREE.Vector3(SPECIAL_SPECIAL_X, 0.5, 0.5) },
            specialSpecialRoomShelves: { rotX: Math.PI * 1.2, rotY: 0.2, dist: 5, target: new THREE.Vector3(SPECIAL_SPECIAL_X, 1.2, -SPECIAL_SPECIAL_DEPTH / 3) }
        };

        function animateToView(view, duration = 1500) {
            const startRotX = currentRotationX, startRotY = currentRotationY;
            const startDist = cameraDistance;
            const startTarget = cameraTarget.clone();
            const startTime = Date.now();

            function update() {
                const elapsed = Date.now() - startTime;
                const t = Math.min(elapsed / duration, 1);
                const eased = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;

                targetRotationX = startRotX + (view.rotX - startRotX) * eased;
                targetRotationY = startRotY + (view.rotY - startRotY) * eased;
                cameraDistance = startDist + (view.dist - startDist) * eased;
                cameraTarget.lerpVectors(startTarget, view.target, eased);

                if (t < 1) requestAnimationFrame(update);
            }
            update();
        }

        window.setView = function(viewName) { const view = views[viewName]; if (view) animateToView(view); };
        window.focusRoom = function(room) {
            if (room === 'threeStarRoom') setView('threeStarRoomInside');
            else if (room === 'specialSpecialRoom') setView('specialSpecialRoomInside');
        };

        let tourRunning = false;
        window.startTour = function() {
            if (tourRunning) return;
            tourRunning = true;
            // Tour starts from entry doors, walking through each room
            const stops = ['overview', 'threeStarRoomEntry', 'threeStarRoomInside', 'threeStarRoomWindows', 'threeStarRoomTable', 'specialSpecialRoomEntry', 'specialSpecialRoomInside', 'specialSpecialRoomWindows', 'specialSpecialRoomSeating', 'specialSpecialRoomShelves', 'overview'];
            let i = 0;
            function next() {
                if (i >= stops.length) { tourRunning = false; return; }
                animateToView(views[stops[i++]], 2000);
                setTimeout(next, 3500);
            }
            next();
        };

        // Toggle functions
        let showGrid = true, showLabels = true, showCeiling = true, hideNearWall = false, showWireframe = false;

        window.toggleGrid = function() {
            showGrid = !showGrid;
            gridHelper.visible = showGrid;
            document.getElementById('gridBtn').classList.toggle('active', showGrid);
        };

        window.toggleLabels = function() {
            showLabels = !showLabels;
            labelsGroup.visible = showLabels;
            document.getElementById('labelsBtn').classList.toggle('active', showLabels);
        };

        window.toggleCeiling = function() {
            showCeiling = !showCeiling;
            // Find all ceilings in the scene
            scene.traverse((obj) => {
                if (obj.userData.isCeiling) obj.visible = showCeiling;
            });
            document.getElementById('ceilingBtn').classList.toggle('active', showCeiling);
        };

        window.toggleNearWall = function() {
            hideNearWall = !hideNearWall;
            document.getElementById('nearWallBtn').classList.toggle('active', hideNearWall);
        };

        window.toggleWireframe = function() {
            showWireframe = !showWireframe;
            document.getElementById('wireframeBtn').classList.toggle('active', showWireframe);
            scene.traverse((obj) => { if (obj.isMesh && obj.material) obj.material.wireframe = showWireframe; });
        };

        window.captureScreenshot = function() {
            const link = document.createElement('a');
            link.download = 'PanafricanLibrary_ReadingRoom.png';
            link.href = renderer.domElement.toDataURL('image/png');
            link.click();
        };

        window.toggleMoodboard = function() {
            const modal = document.getElementById('moodboard-modal');
            modal.classList.toggle('modal-hidden');
            if (!modal.classList.contains('modal-hidden')) {
                renderMoodboardGallery();
            }
        };

        // ============ MOOD BOARD MANAGEMENT ============
        let moodboardEditMode = false;
        let currentSlideIndex = 0;
        let currentFilter = 'all';
        let draggedImageIndex = null;

        // Default mood board images
        let moodboardImages = JSON.parse(localStorage.getItem('moodboardImages')) || [
            { src: 'photos refs reading room/Style mobilier/569a10d902522e95d504c7964c67310e.jpg', title: 'Ochre floor mattress with cushions', category: 'furniture' },
            { src: 'photos refs reading room/ambiance/352102ea74fd486ae6c0906204724e6d.jpg', title: 'Layered rugs, disco balls, wooden chairs', category: 'ambiance' },
            { src: 'photos refs reading room/Style mobilier/-natte-plastique-thies.jpg', title: 'Senegalese plastic woven mats (nattes)', category: 'furniture' },
            { src: 'photos refs reading room/inspiration afrique/The-Library-of-Muyinga-by-BC-architects_dezeen_8.jpg', title: 'Library of Muyinga - wooden platforms', category: 'inspiration' },
            { src: 'photos refs reading room/ambiance/_M5C0020.jpg', title: 'Colorful bean bags and poufs', category: 'ambiance' },
            { src: 'photos refs reading room/Style mobilier/tissu-wax.webp', title: 'African wax print fabric', category: 'pattern' }
        ];

        // Default categories
        const defaultCategories = [
            { value: 'furniture', label: 'Furniture Style' },
            { value: 'ambiance', label: 'Ambiance' },
            { value: 'inspiration', label: 'Inspiration' },
            { value: 'pattern', label: 'Patterns & Textiles' },
            { value: 'film', label: 'Films' },
            { value: 'media', label: 'Media' }
        ];
        let imageCategories = JSON.parse(localStorage.getItem('panafricanCategories')) || [...defaultCategories];

        function saveCategories() {
            localStorage.setItem('panafricanCategories', JSON.stringify(imageCategories));
        }

        // Render category filter buttons
        function renderCategoryFilters() {
            const container = document.getElementById('category-filter-buttons');
            if (!container) return;
            container.innerHTML = `
                <button class="moodboard-toolbar-btn ${currentFilter === 'all' ? 'active' : ''}" onclick="filterMoodboard('all')" data-filter="all">All</button>
                ${imageCategories.map(c => `
                    <button class="moodboard-toolbar-btn ${currentFilter === c.value ? 'active' : ''}" onclick="filterMoodboard('${c.value}')" data-filter="${c.value}">${c.label}</button>
                `).join('')}
            `;
        }

        // Render category dropdown options
        function renderCategoryOptions() {
            const addSelect = document.getElementById('new-image-category');
            const editSelect = document.getElementById('edit-image-category');
            const options = imageCategories.map(c => `<option value="${c.value}">${c.label}</option>`).join('');
            if (addSelect) addSelect.innerHTML = options;
            if (editSelect) editSelect.innerHTML = options;
        }

        // Category manager
        window.toggleCategoryManager = function() {
            const manager = document.getElementById('category-manager');
            manager.style.display = manager.style.display === 'none' ? 'block' : 'none';
            document.getElementById('manage-categories-btn').classList.toggle('active', manager.style.display !== 'none');
            renderCategoryList();
        };

        function renderCategoryList() {
            const container = document.getElementById('category-list');
            container.innerHTML = imageCategories.map((c, idx) => `
                <div style="display: flex; align-items: center; gap: 8px; padding: 4px 0; border-bottom: 1px solid #333;">
                    <span style="color: #888; font-size: 10px; width: 80px;">${c.value}</span>
                    <span style="color: #fff; font-size: 12px; flex: 1;">${c.label}</span>
                    <button onclick="removeCategory(${idx})" style="background: #c41e3a; border: none; color: #fff; width: 18px; height: 18px; border-radius: 50%; cursor: pointer; font-size: 10px;">‚úï</button>
                </div>
            `).join('');
        }

        window.addCategory = function() {
            const value = document.getElementById('new-category-value').value.trim().toLowerCase().replace(/\s+/g, '-');
            const label = document.getElementById('new-category-label').value.trim();
            if (value && label) {
                if (imageCategories.some(c => c.value === value)) {
                    alert('Category key already exists');
                    return;
                }
                imageCategories.push({ value, label });
                saveCategories();
                document.getElementById('new-category-value').value = '';
                document.getElementById('new-category-label').value = '';
                renderCategoryList();
                renderCategoryFilters();
                renderCategoryOptions();
            }
        };

        window.removeCategory = function(index) {
            if (imageCategories.length <= 1) {
                alert('You must keep at least one category');
                return;
            }
            const cat = imageCategories[index];
            // Move images in this category to first available category
            const newCat = imageCategories[0].value !== cat.value ? imageCategories[0].value : imageCategories[1].value;
            moodboardImages.forEach(img => {
                if (img.category === cat.value) img.category = newCat;
            });
            saveMoodboardImages();
            imageCategories.splice(index, 1);
            saveCategories();
            renderCategoryList();
            renderCategoryFilters();
            renderCategoryOptions();
            renderMoodboardGallery();
        };

        // Edit image details
        window.editImageDetails = function(index) {
            const img = moodboardImages[index];
            document.getElementById('edit-image-index').value = index;
            document.getElementById('edit-image-title').value = img.title;
            renderCategoryOptions();
            document.getElementById('edit-image-category').value = img.category;
            document.getElementById('edit-image-modal').style.display = 'flex';
        };

        window.saveImageEdit = function() {
            const index = parseInt(document.getElementById('edit-image-index').value);
            moodboardImages[index].title = document.getElementById('edit-image-title').value.trim();
            moodboardImages[index].category = document.getElementById('edit-image-category').value;
            saveMoodboardImages();
            closeImageEdit();
            renderMoodboardGallery();
        };

        window.closeImageEdit = function() {
            document.getElementById('edit-image-modal').style.display = 'none';
        };

        // Initialize categories on load
        document.addEventListener('DOMContentLoaded', () => {
            renderCategoryFilters();
            renderCategoryOptions();
        });

        function saveMoodboardImages() {
            localStorage.setItem('moodboardImages', JSON.stringify(moodboardImages));
        }

        function getFilteredImages() {
            if (currentFilter === 'all') return moodboardImages;
            return moodboardImages.filter(img => img.category === currentFilter);
        }

        function renderMoodboardGallery() {
            const gallery = document.getElementById('moodboard-gallery');
            const countEl = document.getElementById('image-count');
            const filtered = getFilteredImages();

            countEl.textContent = `(${filtered.length} images)`;

            gallery.innerHTML = filtered.map((img, idx) => {
                const realIdx = moodboardImages.indexOf(img);
                const categoryLabel = imageCategories.find(c => c.value === img.category)?.label || img.category;
                return `
                <div class="moodboard-image-item ${moodboardEditMode ? 'editing' : ''}"
                     data-index="${realIdx}"
                     onclick="openSlideshow(${realIdx})"
                     draggable="${moodboardEditMode}">
                    <img src="${img.src}" alt="${img.title}" onerror="this.parentElement.style.display='none'">
                    <div class="image-overlay">
                        <div class="image-title">${img.title}</div>
                        <div class="image-category" style="font-size:9px; opacity:0.7; margin-top:2px;">${categoryLabel}</div>
                    </div>
                    <div class="image-actions">
                        <button class="image-action-btn move" title="Drag to reorder" onclick="event.stopPropagation()">‚ãÆ‚ãÆ</button>
                        <button class="image-action-btn edit" title="Edit" onclick="event.stopPropagation(); editImageDetails(${realIdx})" style="background:rgba(32,201,151,0.8);">‚úèÔ∏è</button>
                        <button class="image-action-btn delete" title="Remove" onclick="event.stopPropagation(); removeMoodboardImage(${realIdx})">‚úï</button>
                    </div>
                </div>
                `;
            }).join('');

            // Add drag-drop for reordering
            if (moodboardEditMode) {
                setupDragDrop();
            }
        }

        function setupDragDrop() {
            const items = document.querySelectorAll('.moodboard-image-item');
            items.forEach(item => {
                item.addEventListener('dragstart', (e) => {
                    draggedImageIndex = parseInt(item.dataset.index);
                    e.dataTransfer.effectAllowed = 'move';
                    item.style.opacity = '0.5';
                });
                item.addEventListener('dragend', () => {
                    item.style.opacity = '1';
                    draggedImageIndex = null;
                });
                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                });
                item.addEventListener('drop', (e) => {
                    e.preventDefault();
                    const targetIndex = parseInt(item.dataset.index);
                    if (draggedImageIndex !== null && draggedImageIndex !== targetIndex) {
                        reorderMoodboardImage(draggedImageIndex, targetIndex);
                    }
                });
            });
        }

        window.toggleMoodboardEdit = function() {
            moodboardEditMode = !moodboardEditMode;
            document.getElementById('edit-mode-btn').classList.toggle('active', moodboardEditMode);
            renderMoodboardGallery();
        };

        window.toggleAddImageForm = function() {
            const form = document.getElementById('add-image-form');
            form.classList.toggle('active');
            document.getElementById('add-image-btn').classList.toggle('active', form.classList.contains('active'));
        };

        window.filterMoodboard = function(filter) {
            currentFilter = filter;
            document.querySelectorAll('[data-filter]').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.filter === filter);
            });
            renderMoodboardGallery();
        };

        window.addMoodboardImage = function() {
            const urlInput = document.getElementById('new-image-url');
            const titleInput = document.getElementById('new-image-title');
            const categorySelect = document.getElementById('new-image-category');
            const dropZone = document.getElementById('drop-zone');

            const src = urlInput.value.trim() || dropZone.dataset.imageSrc;
            const title = titleInput.value.trim() || 'Untitled';
            const category = categorySelect.value;

            if (!src) {
                alert('Please provide an image URL or upload a file');
                return;
            }

            moodboardImages.push({ src, title, category });
            saveMoodboardImages();

            // Reset form
            urlInput.value = '';
            titleInput.value = '';
            dropZone.classList.remove('has-file');
            dropZone.innerHTML = 'üì∑ Drag & drop image here or click to browse';
            delete dropZone.dataset.imageSrc;
            toggleAddImageForm();

            renderMoodboardGallery();
        };

        window.removeMoodboardImage = function(index) {
            if (confirm('Remove this image from the mood board?')) {
                moodboardImages.splice(index, 1);
                saveMoodboardImages();
                renderMoodboardGallery();
            }
        };

        // ===============================
        // EDITABLE SECTIONS DATA & STATE
        // ===============================
        let colorPaletteEditMode = false;
        let patternEditMode = false;
        let furnitureEditMode = false;
        let functionsEditMode = false;

        // Default data
        const defaultColorPalette = [
            { color: '#f5f0e8', name: 'Cream/Off-White (Bean Bags, Walls)' },
            { color: '#fd7e14', name: 'Burnt Orange (Bean Bags, Accents)' },
            { color: '#c41e3a', name: 'Deep Red (Natte, Posters)' },
            { color: '#fdd835', name: 'Bright Yellow (Wax Print, Highlights)' },
            { color: '#c2185b', name: 'Magenta/Pink (Cushions, Rugs)' },
            { color: '#6b8e23', name: 'Olive Green (Velvet Sofa)' },
            { color: '#00897b', name: 'Teal (Cushions, Accents)' },
            { color: '#1a3a5c', name: 'Deep Blue (Tie-Dye, Books)' },
            { color: '#d4a76a', name: 'Natural Wood/Rattan' },
            { color: '#8b4513', name: 'Terracotta/Brown' },
            { color: '#c9a227', name: 'Ochre/Gold' },
            { color: '#1a1a1a', name: 'Black (Frames, Contrast)' }
        ];

        const defaultPatterns = [
            { name: 'Ankara Circles', css: 'repeating-conic-gradient(from 0deg, #fdd835 0deg 30deg, #c41e3a 30deg 60deg)' },
            { name: 'Kente Stripes', css: 'repeating-linear-gradient(45deg, #fd7e14 0px, #fd7e14 10px, #fdd835 10px, #fdd835 20px)' },
            { name: 'Target Circles', css: 'radial-gradient(circle at 50% 50%, #c41e3a 30%, #1a1a1a 30%, #1a1a1a 40%, #fdd835 40%)' },
            { name: 'Horizontal Bars', css: 'repeating-linear-gradient(0deg, #00897b 0px, #00897b 8px, #f5f0e8 8px, #f5f0e8 16px)' },
            { name: 'Color Wheel', css: 'conic-gradient(#c2185b, #fdd835, #00897b, #c41e3a, #c2185b)' },
            { name: 'B&W Geometric', css: 'repeating-conic-gradient(#1a1a1a 0deg 10deg, #f5f0e8 10deg 20deg)' }
        ];

        const defaultFurniture = [
            { emoji: 'üìö', text: 'Reading area (tables, chairs, display stands) ‚Äî Pan-African Library' },
            { emoji: 'üìñ', text: 'Books on table: zines, fanzines, essays, archives, catalogues, experimental editions' },
            { emoji: 'üñºÔ∏è', text: 'Printed posters on walls ‚Äî Afrikadaa posters, AABF archives' },
            { emoji: 'üó∫Ô∏è', text: 'Mapping African publishing (wall-based or digital display)' },
            { emoji: 'üì∫', text: 'Video screens for publisher interviews (10 filmed interviews)' },
            { emoji: 'üéß', text: 'Audio/radio listening station with speakers & headphones ‚Äî Sound Library' },
            { emoji: 'üéµ', text: 'DJ table with vinyl collection' },
            { emoji: 'üì±', text: '2-3 screens with media players or 4 iPads with headphones' },
            { emoji: 'üßò', text: 'Floor cushions (poufs) for seating' },
            { emoji: 'ü™¥', text: 'Woven mats on the floor' }
        ];

        const defaultFunctions = [
            { title: 'Three Star ‚Äî The Pan-African Library', text: 'Curatorial selection of ~50 independent publications (zines, fanzines, essays, archives, catalogues, experimental editions). AABF 10-year archives with posters, visuals, documents, photographs, catalogues, and manifestos. Video space with filmed interviews with publishers, artists, and publishing activists. Mapping African publishing: wall-based or digital installation mapping editorial scenes, networks, and emerging practices.' },
            { title: 'Special Special ‚Äî Sound Library', text: 'Audio/radio listening station with speakers, headphones, and listening terminal. DJ table with vinyl. 2-3 screens with media players and headphones (or 4 iPads). Floor cushions (poufs) and woven mats. Sound works from Afrikadaa collective and Station of Commons radio. Collective listening sessions with DJ-led music focused on repair of bodies and narratives. Collective reading space for group readings, performances, and poetry. Public program with roundtables and conversations between AABF √ó Printed Matter.' },
            { title: 'The Reading Room Concept', text: 'A space of extended time within the fair: a place to read, listen, watch, exchange, and rest. The project favors a sensory and collective experience, inviting visitors to slow down, immerse themselves in the archives, and activate publications as living objects of transmission and dialogue.' },
            { title: 'Expected Impact', text: 'Creates a unique space for the circulation of transnational knowledge among African, diasporic, and North American publishers, connecting New York, Dakar, and the African continent. Amplifies editorial voices often relegated to the margins. Proposes a critical and active engagement with archives. Affirms the necessity of a decolonial, collective, and self-affirmed ecology of knowledge.' }
        ];

        // Load from localStorage or use defaults
        let colorPalette = JSON.parse(localStorage.getItem('panafricanColorPalette')) || [...defaultColorPalette];
        let patterns = JSON.parse(localStorage.getItem('panafricanPatterns')) || [...defaultPatterns];
        let furnitureItems = JSON.parse(localStorage.getItem('panafricanFurniture')) || [...defaultFurniture];
        let roomFunctions = JSON.parse(localStorage.getItem('panafricanFunctions')) || [...defaultFunctions];

        // Save functions
        function saveColorPalette() { localStorage.setItem('panafricanColorPalette', JSON.stringify(colorPalette)); }
        function savePatterns() { localStorage.setItem('panafricanPatterns', JSON.stringify(patterns)); }
        function saveFurniture() { localStorage.setItem('panafricanFurniture', JSON.stringify(furnitureItems)); }
        function saveFunctions() { localStorage.setItem('panafricanFunctions', JSON.stringify(roomFunctions)); }

        // ===============================
        // COLOR PALETTE EDITING
        // ===============================
        window.toggleColorPaletteEdit = function() {
            colorPaletteEditMode = !colorPaletteEditMode;
            document.getElementById('color-edit-btn').classList.toggle('active', colorPaletteEditMode);
            document.getElementById('color-add-form').style.display = colorPaletteEditMode ? 'flex' : 'none';
            renderColorPalette();
        };

        function renderColorPalette() {
            const container = document.getElementById('color-palette-container');
            container.innerHTML = colorPalette.map((c, idx) => `
                <div class="color-swatch ${colorPaletteEditMode ? 'editing' : ''}"
                     style="background: ${c.color}; position: relative;"
                     title="${c.name}"
                     onclick="${colorPaletteEditMode ? `removeColorSwatch(${idx})` : ''}">
                </div>
            `).join('');
        }

        window.addColorSwatch = function() {
            const colorValue = document.getElementById('new-color-value').value;
            const colorName = document.getElementById('new-color-name').value.trim() || 'New Color';
            colorPalette.push({ color: colorValue, name: colorName });
            saveColorPalette();
            document.getElementById('new-color-name').value = '';
            renderColorPalette();
        };

        window.removeColorSwatch = function(index) {
            colorPalette.splice(index, 1);
            saveColorPalette();
            renderColorPalette();
        };

        // ===============================
        // PATTERN EDITING WITH INDEXEDDB & DRAG-DROP
        // ===============================

        // IndexedDB for storing pattern images
        let patternDB = null;
        const PATTERN_DB_NAME = 'PanafricanPatternDB';
        const PATTERN_STORE_NAME = 'patterns';

        function initPatternDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(PATTERN_DB_NAME, 1);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => { patternDB = request.result; resolve(patternDB); };
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains(PATTERN_STORE_NAME)) {
                        db.createObjectStore(PATTERN_STORE_NAME, { keyPath: 'id', autoIncrement: true });
                    }
                };
            });
        }

        async function savePatternToDB(name, imageDataUrl) {
            if (!patternDB) await initPatternDB();
            return new Promise((resolve, reject) => {
                const tx = patternDB.transaction(PATTERN_STORE_NAME, 'readwrite');
                const store = tx.objectStore(PATTERN_STORE_NAME);
                const id = 'pattern_' + Date.now();
                const request = store.add({ id, name, imageData: imageDataUrl, timestamp: Date.now() });
                request.onsuccess = () => resolve(id);
                request.onerror = () => reject(request.error);
            });
        }

        async function getPatternFromDB(id) {
            if (!patternDB) await initPatternDB();
            return new Promise((resolve, reject) => {
                const tx = patternDB.transaction(PATTERN_STORE_NAME, 'readonly');
                const store = tx.objectStore(PATTERN_STORE_NAME);
                const request = store.get(id);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async function getAllPatternsFromDB() {
            if (!patternDB) await initPatternDB();
            return new Promise((resolve, reject) => {
                const tx = patternDB.transaction(PATTERN_STORE_NAME, 'readonly');
                const store = tx.objectStore(PATTERN_STORE_NAME);
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result || []);
                request.onerror = () => reject(request.error);
            });
        }

        async function deletePatternFromDB(id) {
            if (!patternDB) await initPatternDB();
            return new Promise((resolve, reject) => {
                const tx = patternDB.transaction(PATTERN_STORE_NAME, 'readwrite');
                const store = tx.objectStore(PATTERN_STORE_NAME);
                const request = store.delete(id);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        // Currently dragged pattern for furniture application
        let draggedPattern = null;

        window.togglePatternEdit = function() {
            patternEditMode = !patternEditMode;
            document.getElementById('pattern-edit-btn').classList.toggle('active', patternEditMode);
            document.getElementById('pattern-add-form').style.display = patternEditMode ? 'block' : 'none';
            renderPatterns();
        };

        async function renderPatterns() {
            const container = document.getElementById('pattern-grid-container');
            if (!container) return; // Safety check

            // Get patterns from both localStorage (CSS) and IndexedDB (images)
            let dbPatterns = [];
            try {
                dbPatterns = await getAllPatternsFromDB();
            } catch (err) {
                console.warn('Could not load patterns from IndexedDB:', err);
            }

            let html = '';

            // Render CSS-based patterns from localStorage
            patterns.forEach((p, idx) => {
                const bgStyle = p.imageUrl ? `url(${p.imageUrl})` : p.css;
                const bgSize = p.imageUrl ? 'background-size: cover; background-position: center;' : '';
                html += `
                    <div class="pattern-swatch ${patternEditMode ? 'editing' : ''}"
                         draggable="true"
                         data-pattern-type="css"
                         data-pattern-idx="${idx}"
                         style="background: ${bgStyle}; width: 50px; height: 50px; border-radius: 4px; cursor: grab; ${bgSize}"
                         title="${p.name} (drag to furniture)"
                         ondragstart="handlePatternDragStart(event, 'css', ${idx})"
                         onclick="${patternEditMode ? `removePattern(${idx})` : `selectPatternForTexture('css', ${idx})`}">
                    </div>
                `;
            });

            // Render image-based patterns from IndexedDB
            dbPatterns.forEach((p, idx) => {
                html += `
                    <div class="pattern-swatch ${patternEditMode ? 'editing' : ''}"
                         draggable="true"
                         data-pattern-type="db"
                         data-pattern-id="${p.id}"
                         style="background: url(${p.imageData}); background-size: cover; background-position: center; width: 50px; height: 50px; border-radius: 4px; cursor: grab;"
                         title="${p.name} (drag to furniture)"
                         ondragstart="handlePatternDragStart(event, 'db', '${p.id}')"
                         onclick="${patternEditMode ? `removePatternFromDB('${p.id}')` : `selectPatternForTexture('db', '${p.id}')`}">
                    </div>
                `;
            });

            container.innerHTML = html;

            // Also update the mini texture panel in Room Decorator
            try {
                await updateTexturePanelPatterns();
            } catch (err) {
                console.warn('Could not update texture panel:', err);
            }
        }

        // Pattern drag start handler
        window.handlePatternDragStart = function(event, type, idOrIdx) {
            draggedPattern = { type, id: idOrIdx };
            event.dataTransfer.setData('text/plain', JSON.stringify(draggedPattern));
            event.dataTransfer.effectAllowed = 'copy';
        };

        // Select pattern for applying to selected furniture
        window.selectPatternForTexture = async function(type, idOrIdx) {
            if (!selectedPlacedItem) {
                alert('Please select a piece of furniture first in the Room Decorator');
                return;
            }
            await applyPatternToFurniture(type, idOrIdx);
        };

        // Apply pattern texture to selected furniture
        async function applyPatternToFurniture(type, idOrIdx, surfaceType = 'all') {
            if (!selectedPlacedItem) return;

            let textureUrl;
            if (type === 'css') {
                // For CSS patterns, we create a canvas-based texture
                const pattern = patterns[idOrIdx];
                if (pattern.imageUrl) {
                    textureUrl = pattern.imageUrl;
                } else {
                    // Generate texture from CSS pattern (use existing canvas generator)
                    const patternIdx = idOrIdx % 10;
                    const texture = getTextileTexture(patternIdx);
                    applyTextureToObject(selectedPlacedItem, texture, surfaceType);
                    return;
                }
            } else if (type === 'db') {
                const pattern = await getPatternFromDB(idOrIdx);
                if (pattern) {
                    textureUrl = pattern.imageData;
                }
            }

            if (textureUrl) {
                const loader = new THREE.TextureLoader();
                loader.load(textureUrl, (texture) => {
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    texture.repeat.set(2, 2);
                    applyTextureToObject(selectedPlacedItem, texture, surfaceType);
                }, undefined, (err) => {
                    console.error('Error loading texture:', err);
                });
            }
        }

        // Apply texture to 3D object based on surface type
        function applyTextureToObject(object, texture, surfaceType) {
            if (!object) return;

            object.traverse((child) => {
                if (child.isMesh) {
                    const mat = child.material;
                    const isTexturable = shouldApplyToSurface(child, surfaceType);

                    if (isTexturable) {
                        // Clone material to avoid affecting other objects
                        const newMat = mat.clone();
                        newMat.map = texture;
                        newMat.needsUpdate = true;
                        child.material = newMat;
                    }
                }
            });
        }

        // Determine if texture should be applied to this surface
        function shouldApplyToSurface(mesh, surfaceType) {
            if (surfaceType === 'all') return true;

            const mat = mesh.material;
            const color = mat.color ? mat.color.getHex() : 0;

            // Heuristics based on color and position
            if (surfaceType === 'cushions') {
                // Cushions are typically colored (olive, etc) and at seat height
                return mesh.position.y < 1.0 && color !== 0xf5f5f5 && color !== 0xffffff;
            } else if (surfaceType === 'top') {
                return mesh.position.y === Math.max(...mesh.parent.children.filter(c => c.isMesh).map(c => c.position.y));
            } else if (surfaceType === 'sides') {
                return mesh.position.y !== Math.max(...mesh.parent.children.filter(c => c.isMesh).map(c => c.position.y));
            }
            return true;
        }

        // Update texture panel in Room Decorator
        async function updateTexturePanelPatterns() {
            const container = document.getElementById('texture-patterns-mini');
            if (!container) return;

            let dbPatterns = [];
            try {
                dbPatterns = await getAllPatternsFromDB();
            } catch (err) {
                console.warn('Could not load patterns for texture panel:', err);
            }

            let html = '';

            // First 5 CSS patterns
            patterns.slice(0, 5).forEach((p, idx) => {
                const bgStyle = p.imageUrl ? `url(${p.imageUrl})` : p.css;
                const bgSize = p.imageUrl ? 'background-size: cover;' : '';
                html += `<div class="mini-pattern" style="background:${bgStyle}; width:32px; height:32px; border-radius:3px; cursor:pointer; ${bgSize}" onclick="applyPatternToFurniture('css', ${idx}, document.getElementById('surface-select').value)" title="${p.name}"></div>`;
            });

            // IndexedDB patterns
            dbPatterns.slice(0, 10).forEach((p) => {
                html += `<div class="mini-pattern" style="background:url(${p.imageData}); background-size:cover; width:32px; height:32px; border-radius:3px; cursor:pointer;" onclick="applyPatternToFurniture('db', '${p.id}', document.getElementById('surface-select').value)" title="${p.name}"></div>`;
            });

            container.innerHTML = html || '<p style="font-size:9px; color:#666;">No patterns - add in Mood Board</p>';
        }

        // Add pattern from file upload
        window.addPatternFromFile = async function() {
            const fileInput = document.getElementById('new-pattern-file');
            const nameInput = document.getElementById('new-pattern-name');

            if (!fileInput.files || fileInput.files.length === 0) {
                alert('Please select an image file');
                return;
            }

            const file = fileInput.files[0];
            const name = nameInput.value.trim() || file.name.replace(/\.[^/.]+$/, '');

            try {
                const dataUrl = await fileToDataUrl(file);
                await savePatternToDB(name, dataUrl);
                fileInput.value = '';
                nameInput.value = '';
                await renderPatterns();
                console.log('Pattern added:', name);
            } catch (err) {
                console.error('Error adding pattern:', err);
                alert('Error adding pattern: ' + err.message);
            }
        };

        // Load multiple patterns from folder
        window.loadPatternsFromFolder = function() {
            const input = document.createElement('input');
            input.type = 'file';
            input.multiple = true;
            input.accept = 'image/*';
            input.webkitdirectory = true;

            input.onchange = async (e) => {
                const files = Array.from(e.target.files).filter(f => f.type.startsWith('image/'));
                let added = 0;

                for (const file of files) {
                    try {
                        const name = file.name.replace(/\.[^/.]+$/, '');
                        const dataUrl = await fileToDataUrl(file);
                        await savePatternToDB(name, dataUrl);
                        added++;
                    } catch (err) {
                        console.warn('Skipped file:', file.name, err);
                    }
                }

                await renderPatterns();
                alert(`Added ${added} patterns from folder`);
            };

            input.click();
        };

        // Helper: Convert file to data URL
        function fileToDataUrl(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => reject(reader.error);
                reader.readAsDataURL(file);
            });
        }

        window.addPatternSwatch = function() {
            const patternName = document.getElementById('new-pattern-name').value.trim() || 'New Pattern';
            const patternUrl = document.getElementById('new-pattern-url').value.trim();
            if (patternUrl) {
                patterns.push({ name: patternName, imageUrl: patternUrl });
                savePatterns();
                document.getElementById('new-pattern-name').value = '';
                document.getElementById('new-pattern-url').value = '';
                renderPatterns();
            } else {
                alert('Please provide a pattern image URL');
            }
        };

        window.removePattern = function(index) {
            patterns.splice(index, 1);
            savePatterns();
            renderPatterns();
        };

        window.removePatternFromDB = async function(id) {
            if (confirm('Remove this pattern?')) {
                await deletePatternFromDB(id);
                await renderPatterns();
            }
        };

        // Reset furniture texture to default
        window.resetFurnitureTexture = function() {
            if (!selectedPlacedItem) return;
            selectedPlacedItem.traverse((child) => {
                if (child.isMesh && child.material) {
                    const newMat = child.material.clone();
                    newMat.map = null;
                    newMat.needsUpdate = true;
                    child.material = newMat;
                }
            });
        };

        // Randomize furniture textures
        window.randomizeFurnitureTexture = function() {
            if (!selectedPlacedItem) return;
            const randomIdx = Math.floor(Math.random() * 10);
            const texture = getTextileTexture(randomIdx);
            applyTextureToObject(selectedPlacedItem, texture, 'cushions');
        };

        // ===============================
        // FURNITURE EDITING
        // ===============================
        window.toggleFurnitureEdit = function() {
            furnitureEditMode = !furnitureEditMode;
            document.getElementById('furniture-edit-btn').classList.toggle('active', furnitureEditMode);
            document.getElementById('furniture-add-form').style.display = furnitureEditMode ? 'flex' : 'none';
            renderFurniture();
        };

        function renderFurniture() {
            const container = document.getElementById('furniture-list-container');
            container.innerHTML = `<ul class="design-list" style="font-size: 12px;">` +
                furnitureItems.map((f, idx) => `
                    <li class="editable-item ${furnitureEditMode ? 'editing' : ''}">
                        <button class="remove-btn" onclick="removeFurniture(${idx})">‚úï</button>
                        <span>${f.emoji} ${f.text}</span>
                    </li>
                `).join('') +
            `</ul>`;
        }

        window.addFurnitureItem = function() {
            const emoji = document.getElementById('new-furniture-emoji').value.trim() || '‚Ä¢';
            const text = document.getElementById('new-furniture-text').value.trim();
            if (text) {
                furnitureItems.push({ emoji, text });
                saveFurniture();
                document.getElementById('new-furniture-emoji').value = '';
                document.getElementById('new-furniture-text').value = '';
                renderFurniture();
            }
        };

        window.removeFurniture = function(index) {
            furnitureItems.splice(index, 1);
            saveFurniture();
            renderFurniture();
        };

        // ===============================
        // ROOM FUNCTIONS EDITING
        // ===============================
        window.toggleFunctionsEdit = function() {
            functionsEditMode = !functionsEditMode;
            document.getElementById('functions-edit-btn').classList.toggle('active', functionsEditMode);
            document.getElementById('functions-add-form').style.display = functionsEditMode ? 'block' : 'none';
            renderFunctions();
        };

        function renderFunctions() {
            const container = document.getElementById('functions-container');
            container.innerHTML = roomFunctions.map((f, idx) => `
                <div class="editable-item ${functionsEditMode ? 'editing' : ''}" style="display: block; margin-bottom: 8px;">
                    <button class="remove-btn" onclick="removeFunction(${idx})" style="float: right; margin-left: 8px;">‚úï</button>
                    <p><strong>${f.title}:</strong> ${f.text}</p>
                </div>
            `).join('');
        }

        window.addFunctionItem = function() {
            const title = document.getElementById('new-function-title').value.trim();
            const text = document.getElementById('new-function-text').value.trim();
            if (title && text) {
                roomFunctions.push({ title, text });
                saveFunctions();
                document.getElementById('new-function-title').value = '';
                document.getElementById('new-function-text').value = '';
                renderFunctions();
            }
        };

        window.removeFunction = function(index) {
            roomFunctions.splice(index, 1);
            saveFunctions();
            renderFunctions();
        };

        // Initialize editable sections on load
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                renderColorPalette();
                await renderPatterns();
                renderFurniture();
                renderFunctions();
            } catch (err) {
                console.error('Error initializing mood board:', err);
            }
        });

        function reorderMoodboardImage(fromIndex, toIndex) {
            const item = moodboardImages.splice(fromIndex, 1)[0];
            moodboardImages.splice(toIndex, 0, item);
            saveMoodboardImages();
            renderMoodboardGallery();
        }

        // ============ MULTI-FILE UPLOAD QUEUE ============
        let uploadQueue = [];

        // Process a single file and return its data URL
        async function processImageFile(file) {
            return new Promise((resolve, reject) => {
                try {
                    if (typeof handleMoodboardImageUpload === 'function') {
                        handleMoodboardImageUpload(file).then(resolve).catch(() => {
                            // Fallback to FileReader
                            const reader = new FileReader();
                            reader.onload = (e) => resolve(e.target.result);
                            reader.onerror = reject;
                            reader.readAsDataURL(file);
                        });
                    } else {
                        const reader = new FileReader();
                        reader.onload = (e) => resolve(e.target.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(file);
                    }
                } catch (err) {
                    reject(err);
                }
            });
        }

        // Update the upload queue UI
        function updateUploadQueueUI() {
            const queueEl = document.getElementById('upload-queue');
            const queueCountEl = document.getElementById('queue-count');
            const addAllBtn = document.getElementById('add-all-btn');
            const addSingleBtn = document.getElementById('add-single-btn');

            if (uploadQueue.length > 0) {
                queueEl.style.display = 'block';
                addAllBtn.style.display = 'block';
                addSingleBtn.style.display = 'none';
                queueCountEl.textContent = uploadQueue.length;

                queueEl.innerHTML = uploadQueue.map((item, i) => `
                    <div style="display:flex; align-items:center; gap:8px; padding:4px; background:rgba(255,255,255,0.05); border-radius:3px; margin-bottom:4px;">
                        <img src="${item.src}" style="width:40px; height:40px; object-fit:cover; border-radius:3px;">
                        <span style="flex:1; font-size:11px; color:#ccc; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${item.name}</span>
                        <button onclick="removeFromQueue(${i})" style="background:none; border:none; color:#f55; cursor:pointer; font-size:14px;">‚úï</button>
                    </div>
                `).join('');
            } else {
                queueEl.style.display = 'none';
                addAllBtn.style.display = 'none';
                addSingleBtn.style.display = 'block';
            }
        }

        // Remove item from queue
        window.removeFromQueue = function(index) {
            uploadQueue.splice(index, 1);
            updateUploadQueueUI();
            if (uploadQueue.length === 0) {
                const dropZone = document.getElementById('drop-zone');
                dropZone.innerHTML = 'üì∑ Drag & drop images here or click to browse<br><span style="font-size: 10px; color: #888;">Select multiple files at once!</span>';
                dropZone.classList.remove('has-file');
            }
        };

        // Add all queued images to moodboard
        window.addAllQueuedImages = function() {
            const categorySelect = document.getElementById('new-image-category');
            const category = categorySelect.value;

            uploadQueue.forEach(item => {
                moodboardImages.push({
                    src: item.src,
                    title: item.name.replace(/\.[^/.]+$/, ''), // Remove file extension
                    category: category
                });
            });

            saveMoodboardImages();
            renderMoodboardGallery();

            // Clear queue and reset form
            uploadQueue = [];
            updateUploadQueueUI();
            const dropZone = document.getElementById('drop-zone');
            dropZone.innerHTML = 'üì∑ Drag & drop images here or click to browse<br><span style="font-size: 10px; color: #888;">Select multiple files at once!</span>';
            dropZone.classList.remove('has-file');
            toggleAddImageForm();
        };

        // Multi-file upload handler
        window.handleMultiImageSelect = async function(event) {
            const files = Array.from(event.target.files);
            if (files.length === 0) return;

            const dropZone = document.getElementById('drop-zone');
            dropZone.innerHTML = `‚è≥ Processing ${files.length} images...`;

            let processed = 0;
            for (const file of files) {
                if (!file.type.startsWith('image/')) continue;

                try {
                    const dataUrl = await processImageFile(file);
                    uploadQueue.push({
                        src: dataUrl,
                        name: file.name
                    });
                    processed++;
                    dropZone.innerHTML = `‚è≥ Processing ${processed}/${files.length}...`;
                } catch (err) {
                    console.error('Error processing', file.name, err);
                }
            }

            dropZone.innerHTML = `‚úì ${uploadQueue.length} images ready`;
            dropZone.classList.add('has-file');
            updateUploadQueueUI();

            // Reset file input
            event.target.value = '';
        };

        // Legacy single file handler (kept for compatibility)
        window.handleImageSelect = async function(event) {
            const file = event.target.files[0];
            if (file) {
                const dropZone = document.getElementById('drop-zone');
                dropZone.innerHTML = '‚è≥ Processing...';

                try {
                    const dataUrl = await processImageFile(file);
                    dropZone.dataset.imageSrc = dataUrl;
                    dropZone.dataset.fileName = file.name;
                    dropZone.classList.add('has-file');
                    dropZone.innerHTML = `‚úì ${file.name}`;
                } catch (err) {
                    console.error('Image upload error:', err);
                }
            }
        };

        // Drop zone setup - supports multiple files
        document.addEventListener('DOMContentLoaded', () => {
            const dropZone = document.getElementById('drop-zone');
            if (dropZone) {
                dropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    dropZone.classList.add('dragover');
                });
                dropZone.addEventListener('dragleave', () => {
                    dropZone.classList.remove('dragover');
                });
                dropZone.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    dropZone.classList.remove('dragover');

                    const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
                    if (files.length === 0) return;

                    dropZone.innerHTML = `‚è≥ Processing ${files.length} images...`;

                    let processed = 0;
                    for (const file of files) {
                        try {
                            const dataUrl = await processImageFile(file);
                            uploadQueue.push({
                                src: dataUrl,
                                name: file.name
                            });
                            processed++;
                            dropZone.innerHTML = `‚è≥ Processing ${processed}/${files.length}...`;
                        } catch (err) {
                            console.error('Error processing', file.name, err);
                        }
                    }

                    dropZone.innerHTML = `‚úì ${uploadQueue.length} images ready`;
                    dropZone.classList.add('has-file');
                    updateUploadQueueUI();
                });
            }
        });

        // ============ SLIDESHOW ============
        window.openSlideshow = function(index) {
            if (moodboardEditMode) return; // Don't open slideshow in edit mode
            currentSlideIndex = index;
            updateSlideshow();
            document.getElementById('slideshow-modal').classList.add('active');
        };

        window.closeSlideshow = function() {
            document.getElementById('slideshow-modal').classList.remove('active');
        };

        window.slideshowNav = function(direction) {
            currentSlideIndex += direction;
            if (currentSlideIndex < 0) currentSlideIndex = moodboardImages.length - 1;
            if (currentSlideIndex >= moodboardImages.length) currentSlideIndex = 0;
            updateSlideshow();
        };

        function updateSlideshow() {
            const img = moodboardImages[currentSlideIndex];
            document.getElementById('slideshow-image').src = img.src;
            document.getElementById('slideshow-caption').textContent = img.title;
            document.getElementById('slideshow-info').textContent = `${currentSlideIndex + 1} / ${moodboardImages.length}`;
        }

        // Keyboard navigation for slideshow
        document.addEventListener('keydown', (e) => {
            if (document.getElementById('slideshow-modal').classList.contains('active')) {
                if (e.key === 'ArrowLeft') slideshowNav(-1);
                if (e.key === 'ArrowRight') slideshowNav(1);
                if (e.key === 'Escape') closeSlideshow();
            }
        });

        // ============ DECORATOR MODE ============
        let decoratorMode = false;
        let selectedFurnitureType = null;
        let selectedPlacedItem = null;
        let placedItems = [];
        let isDraggingItem = false;
        let draggedLibraryItem = null;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.toggleDecorator = function() {
            const panel = document.getElementById('decorator-panel');
            panel.classList.toggle('open');
            decoratorMode = panel.classList.contains('open');
            if (!decoratorMode) {
                deselectAll();
            } else {
                // Setup drag-drop for library items when decorator opens
                setupLibraryDragDrop();
            }
        };

        // Setup drag-drop for all library item cards
        function setupLibraryDragDrop() {
            document.querySelectorAll('.item-card').forEach(card => {
                if (card.dataset.dragSetup) return; // Already setup
                card.dataset.dragSetup = 'true';
                card.draggable = true;

                card.addEventListener('dragstart', (e) => {
                    const type = card.onclick?.toString().match(/selectFurniture\('([^']+)'\)/)?.[1];
                    if (type) {
                        draggedLibraryItem = type;
                        e.dataTransfer.setData('text/plain', type);
                        e.dataTransfer.effectAllowed = 'copy';
                        card.classList.add('dragging');
                    }
                });

                card.addEventListener('dragend', () => {
                    card.classList.remove('dragging');
                    draggedLibraryItem = null;
                });
            });
        }

        // Canvas drop zone for library items and 3D files from Finder
        function setupCanvasDragDrop() {
            const canvas = document.getElementById('canvas-container');

            canvas.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
                canvas.classList.add('drag-over');
            });

            canvas.addEventListener('dragleave', (e) => {
                // Only remove if leaving the container entirely
                if (!canvas.contains(e.relatedTarget)) {
                    canvas.classList.remove('drag-over');
                }
            });

            canvas.addEventListener('drop', async (e) => {
                e.preventDefault();
                canvas.classList.remove('drag-over');

                const rect = canvas.getBoundingClientRect();
                const dropX = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                const dropY = -((e.clientY - rect.top) / rect.height) * 2 + 1;

                // Check for 3D file from Finder
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    const file = files[0];
                    const ext = file.name.split('.').pop().toLowerCase();
                    if (['glb', 'gltf', 'obj'].includes(ext)) {
                        await handleDropped3DFile(file, dropX, dropY);
                        return;
                    }
                }

                // Check for library item
                const furnitureType = e.dataTransfer.getData('text/plain');
                if (furnitureType) {
                    placeItemAtScreenPos(furnitureType, dropX, dropY);
                }
            });
        }

        // Handle 3D file dropped from Finder
        async function handleDropped3DFile(file, screenX, screenY) {
            const ext = file.name.split('.').pop().toLowerCase();
            const name = file.name.replace(/\.[^.]+$/, '');

            initLoaders();

            try {
                const arrayBuffer = await file.arrayBuffer();
                const blob = new Blob([arrayBuffer]);
                const url = URL.createObjectURL(blob);

                let object = null;

                if (ext === 'glb' || ext === 'gltf') {
                    if (!gltfLoader) {
                        alert('GLTF loader not available');
                        return;
                    }
                    object = await new Promise((resolve, reject) => {
                        gltfLoader.load(url, (gltf) => resolve(gltf.scene), undefined, reject);
                    });
                } else if (ext === 'obj') {
                    if (!objLoader) {
                        alert('OBJ loader not available');
                        return;
                    }
                    object = await new Promise((resolve, reject) => {
                        objLoader.load(url, resolve, undefined, reject);
                    });
                }

                URL.revokeObjectURL(url);

                if (object) {
                    // Auto-scale to reasonable size
                    const box = new THREE.Box3().setFromObject(object);
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    if (maxDim > 2) {
                        object.scale.multiplyScalar(1.5 / maxDim);
                    } else if (maxDim < 0.1) {
                        object.scale.multiplyScalar(0.5 / maxDim);
                    }

                    // Recalculate bounds after scaling
                    const newBox = new THREE.Box3().setFromObject(object);
                    object.position.y = -newBox.min.y; // Sit on floor

                    // Wrap in group for consistent handling
                    const group = new THREE.Group();
                    group.add(object);
                    group.userData.itemType = 'custom-' + name;
                    group.userData.isPlacedItem = true;

                    // Place at drop position
                    placeObjectAtScreenPos(group, screenX, screenY);
                }
            } catch (err) {
                console.error('Error loading dropped 3D file:', err);
                alert('Failed to load 3D file: ' + err.message);
            }
        }

        // Place furniture item at screen position
        function placeItemAtScreenPos(type, screenX, screenY) {
            const item = createFurnitureItem(type);
            placeObjectAtScreenPos(item, screenX, screenY);
        }

        // Place any object at screen position
        function placeObjectAtScreenPos(item, screenX, screenY) {
            mouse.x = screenX;
            mouse.y = screenY;
            raycaster.setFromCamera(mouse, camera);

            const floorPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const intersectPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(floorPlane, intersectPoint);

            if (intersectPoint) {
                intersectPoint.y = 0;
                const constrainedPos = constrainToRoom(intersectPoint);
                if (constrainedPos) {
                    item.position.copy(constrainedPos);
                    if (item.userData.isWallArt) {
                        item.position.y = 1.5;
                    }
                    scene.add(item);
                    placedItems.push(item);

                    // Select the newly placed item
                    selectedPlacedItem = item;
                    selectedFurnitureType = null;
                    document.querySelectorAll('.item-card').forEach(c => c.classList.remove('selected'));
                    updateSelectedInfo();
                } else {
                    console.log('Cannot place item outside room boundaries');
                }
            }
        }

        window.toggleCategory = function(catId) {
            document.getElementById(catId).classList.toggle('collapsed');
        };

        window.selectFurniture = function(type) {
            // Deselect previous
            document.querySelectorAll('.item-card').forEach(c => c.classList.remove('selected'));
            // Select new
            event.currentTarget.classList.add('selected');
            selectedFurnitureType = type;
            selectedPlacedItem = null;
            updateSelectedInfo();
        };

        function deselectAll() {
            document.querySelectorAll('.item-card').forEach(c => c.classList.remove('selected'));
            selectedFurnitureType = null;
            selectedPlacedItem = null;
            updateSelectedInfo();
        }

        function updateSelectedInfo() {
            const info = document.getElementById('selected-item-info');
            const nameSpan = document.getElementById('selected-name');
            const texturePanel = document.getElementById('texture-panel');

            if (selectedPlacedItem) {
                info.classList.add('visible');
                nameSpan.textContent = selectedPlacedItem.userData.itemType || 'Item';
                // Show texture panel for customization
                if (texturePanel) {
                    texturePanel.style.display = 'block';
                    updateTexturePanelPatterns();
                }
                // Attach transform controls gizmo
                if (transformControls) {
                    transformControls.attach(selectedPlacedItem);
                }
            } else if (selectedFurnitureType) {
                info.classList.add('visible');
                nameSpan.textContent = selectedFurnitureType + ' (click to place)';
                // Hide texture panel when no placed item selected
                if (texturePanel) texturePanel.style.display = 'none';
                // Detach transform controls
                if (transformControls) {
                    transformControls.detach();
                }
            } else {
                info.classList.remove('visible');
                // Hide texture panel
                if (texturePanel) texturePanel.style.display = 'none';
                // Detach transform controls
                if (transformControls) {
                    transformControls.detach();
                }
            }
        }

        // Create furniture based on type
        function createFurnitureItem(type) {
            let item;
            switch(type) {
                // Bean Bags - large triangular
                case 'beanbag-cream': item = createTriangleBeanbag(0xf5f0e8); break;
                case 'beanbag-orange': item = createTriangleBeanbag(0xfd7e14); break;
                case 'beanbag-magenta': item = createTriangleBeanbag(0xc2185b); break;
                case 'beanbag-teal': item = createTriangleBeanbag(0x26a69a); break;
                // Ethnic cushions
                case 'cushion-ethnic-orange': item = createEthnicCushion(0xfd7e14, 0xc96000); break;
                case 'cushion-ethnic-burgundy': item = createEthnicCushion(0x8b2942, 0x5a1a2a); break;
                case 'cushion-velvet-teal': item = createFloorCushion(0x00897b, 0.55); break;
                case 'cushion-round-green': item = createFloorCushion(0x7cb342, 0.45); break;
                case 'cushion-pebble-gray': item = createPebbleCushion(0x90a4ae); break;
                // Mattress & Seating
                case 'mattress-ochre': item = createTuftedFloorMattress(2.2, 1.4); break;
                case 'sofa-olive': item = createVelvetSofa(0x827717); break;
                case 'armchair-pink': item = createVintageArmchair(0xe91e63); break;
                // Tables
                case 'table-display': item = createDisplayTable(); break;
                case 'table-coffee': item = createLowCoffeeTable(); break;
                case 'table-side': item = createSideTable(); break;
                case 'bench-wood': item = createWoodenBench(); break;
                // Book Displays & Storage
                case 'bookcase-wall': item = createWallBookcase(); break;
                case 'book-cubby': item = createBookCubby(); break;
                case 'magazine-rack': item = createMagazineRack(); break;
                case 'book-stack': item = createBookStack(); break;
                case 'display-pink': item = createColorDisplay(0xf8bbd0); break;
                case 'shelf-leaning': item = createLeaningShelf(); break;
                // Rugs - Layered Persian & African
                case 'rug-persian-red': item = createLayeredRug(3.5, 2.5, 0xb71c1c); break;
                case 'rug-persian-cream': item = createLayeredRug(3.0, 2.2, 0xefebe9); break;
                case 'rug-natte-african': item = createAfricanNatte(); break;
                case 'rug-checkered-pink': item = createCheckeredRug(0xe91e63, 0xf8bbd0); break;
                case 'rug-checkered-teal': item = createCheckeredRug(0x00897b, 0xb2dfdb); break;
                case 'rug-wax-yellow': item = createWaxPrintRug(0xfdd835, 0xc41e3a); break;
                case 'rug-geometric-bw': item = createGeometricRug(); break;
                case 'tablecloth-tiedye': item = createTieDyeCloth(); break;
                // Lighting - Ethiopian & Disco
                case 'lamp-ethiopian': item = createEthiopianLamp(); break;
                case 'lamp-beaded': item = createBeadedLamp(); break;
                case 'disco-ball': item = createDiscoBall(); break;
                case 'disco-ball-cluster': item = createDiscoBallCluster(); break;
                case 'light-string': item = createStringLights(); break;
                case 'lantern-paper': item = createPaperLantern(); break;
                // Plants & African Decor
                case 'plant-palm': item = createPalmPlant(); break;
                case 'plant-hanging': item = createHangingPlant(); break;
                case 'plant-pothos': item = createPothosVine(); break;
                case 'basket-woven': item = createWovenBasket(); break;
                case 'pottery-african': item = createAfricanPottery(); break;
                case 'sculpture-wood': item = createWoodSculpture(); break;
                // Wall art
                case 'poster-afrikadaa-1': item = createWallPoster(0xff6b6b, 0.6, 0.8, 'Afrikadaa #1'); break;
                case 'poster-afrikadaa-2': item = createWallPoster(0x45b7d1, 0.5, 0.7, 'Afrikadaa #2'); break;
                case 'poster-afrikadaa-3': item = createWallPoster(0xe17055, 0.5, 0.65, 'African Art'); break;
                case 'poster-coolhunt-1': item = createWallPoster(0x1a1a1a, 0.5, 0.7, 'Fashion'); break;
                case 'poster-coolhunt-2': item = createWallPoster(0xc41e3a, 0.6, 0.8, 'Street Art'); break;
                case 'poster-coolhunt-3': item = createWallPoster(0x74b9ff, 0.4, 0.5, 'Design'); break;
                case 'poster-activist-1': item = createTextBanner('WE WANT TO LIVE FREE', 0x1a3a5c); break;
                case 'poster-activist-2': item = createTextBanner('SOMOS PERSONAS', 0xf5f0e8, 0x1a1a1a); break;
                case 'poster-activist-3': item = createWallPoster(0xc41e3a, 0.7, 0.9, 'Resistance'); break;
                // NEW PANAFRICAN LIBRARY FURNITURE
                // Banquette-shelf units (integrated seating + book display)
                case 'banquette-shelf-short': item = createBanquetteShelfUnit(1.8); break;
                case 'banquette-shelf-medium': item = createBanquetteShelfUnit(2.4); break;
                case 'banquette-shelf-long': item = createBanquetteShelfUnit(3.2); break;
                // Cardboard cube stools
                case 'cube-stool-branches': item = createCardboardCubeStool('branches'); break;
                case 'cube-stool-pattern': item = createCardboardCubeStool('african-pattern'); break;
                case 'cube-stool-text': item = createCardboardCubeStool('text'); break;
                case 'cube-stool-benin': item = createCardboardCubeStool('benin'); break;
                // Vinyl record tables
                case 'record-table-ngoma': item = createVinylRecordTable('ngoma'); break;
                case 'record-table-bantou': item = createVinylRecordTable('bantou'); break;
                case 'record-table-jazz': item = createVinylRecordTable('african-jazz'); break;
                case 'record-table-pathe': item = createVinylRecordTable('pathe'); break;
                // African print poufs
                case 'pouf-leopard': item = createAfricanPrintPouf('leopard'); break;
                case 'pouf-wax-blue': item = createAfricanPrintPouf('wax-blue'); break;
                case 'pouf-wax-pink': item = createAfricanPrintPouf('wax-pink'); break;
                case 'pouf-kente': item = createAfricanPrintPouf('kente'); break;
                case 'pouf-mudcloth': item = createAfricanPrintPouf('mudcloth'); break;
                // Sculptural elements
                case 'sculpture-benin-head': item = createBeninHead(); break;
                default:
                    // Check if it's a custom model
                    if (type && type.startsWith('custom-model-')) {
                        const modelId = parseInt(type.replace('custom-model-', ''));
                        // Return a placeholder - actual model loading happens async
                        item = createCustomModelPlaceholder(modelId);
                    } else {
                        item = createFloorCushion(0x888888, 0.5);
                    }
            }
            item.userData.itemType = type;
            item.userData.isPlacedItem = true;
            return item;
        }

        // Placeholder for custom models while loading
        function createCustomModelPlaceholder(modelId) {
            const group = new THREE.Group();
            const geo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const mat = new THREE.MeshLambertMaterial({
                color: 0x4a90d9,
                transparent: true,
                opacity: 0.5
            });
            const box = new THREE.Mesh(geo, mat);
            box.position.y = 0.25;
            group.add(box);

            // Add loading indicator
            const edges = new THREE.EdgesGeometry(geo);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xffffff }));
            line.position.y = 0.25;
            group.add(line);

            group.userData.isPlaceholder = true;
            group.userData.customModelId = modelId;

            // Async load the actual model and replace placeholder
            loadAndReplaceCustomModel(group, modelId);

            return group;
        }

        // Load custom model and replace placeholder
        async function loadAndReplaceCustomModel(placeholder, modelId) {
            const model = uploadedModels.find(m => m.id === modelId);
            if (!model) return;

            initLoaders();

            try {
                const blob = new Blob([model.data]);
                const url = URL.createObjectURL(blob);

                let object = null;

                if (model.type === 'glb' || model.type === 'gltf') {
                    if (!gltfLoader) return;
                    object = await new Promise((resolve, reject) => {
                        gltfLoader.load(url, (gltf) => resolve(gltf.scene), undefined, reject);
                    });
                } else if (model.type === 'obj') {
                    if (!objLoader) return;
                    object = await new Promise((resolve, reject) => {
                        objLoader.load(url, resolve, undefined, reject);
                    });
                }

                URL.revokeObjectURL(url);

                if (object) {
                    // Auto-scale
                    const box = new THREE.Box3().setFromObject(object);
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    if (maxDim > 2) {
                        object.scale.multiplyScalar(1.5 / maxDim);
                    }

                    // Center
                    const newBox = new THREE.Box3().setFromObject(object);
                    object.position.y = -newBox.min.y;

                    // Clear placeholder contents
                    while (placeholder.children.length > 0) {
                        placeholder.remove(placeholder.children[0]);
                    }

                    // Add loaded model to placeholder group
                    placeholder.add(object);
                    placeholder.userData.isPlaceholder = false;
                    placeholder.userData.customModelName = model.name;
                }
            } catch (err) {
                console.error('Error loading custom model:', err);
            }
        }

        // Additional furniture creation functions
        function createBeanbag(color) {
            const group = new THREE.Group();
            const bean = new THREE.Mesh(
                new THREE.SphereGeometry(0.45, 16, 16),
                new THREE.MeshLambertMaterial({ color })
            );
            bean.scale.set(1.2, 0.7, 1);
            bean.position.set(0, 0.3, 0);
            group.add(bean);
            return group;
        }

        function createLowSofa() {
            const group = new THREE.Group();
            const mat = new THREE.MeshLambertMaterial({ color: 0x6c757d });
            const seat = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.3, 0.8), mat);
            seat.position.set(0, 0.25, 0);
            group.add(seat);
            const back = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.4, 0.15), mat);
            back.position.set(0, 0.5, -0.35);
            group.add(back);
            const armL = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.35, 0.8), mat);
            armL.position.set(-0.85, 0.35, 0);
            group.add(armL);
            const armR = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.35, 0.8), mat);
            armR.position.set(0.85, 0.35, 0);
            group.add(armR);
            return group;
        }

        function createDisplayTable() {
            const group = new THREE.Group();
            const tableMat = new THREE.MeshLambertMaterial({ color: 0xd4a76a });
            const top = new THREE.Mesh(new THREE.BoxGeometry(2, 0.04, 0.8), tableMat);
            top.position.set(0, 0.72, 0);
            group.add(top);
            const legs = [[0.9, 0.3], [0.9, -0.3], [-0.9, 0.3], [-0.9, -0.3]];
            legs.forEach(([x, z]) => {
                const leg = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.7, 0.05), tableMat);
                leg.position.set(x, 0.35, z);
                group.add(leg);
            });
            return group;
        }

        function createSideTable() {
            const group = new THREE.Group();
            const mat = new THREE.MeshLambertMaterial({ color: 0xffd93d });
            const top = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.25, 0.03, 16), mat);
            top.position.set(0, 0.45, 0);
            group.add(top);
            const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.04, 0.43, 8), mat);
            leg.position.set(0, 0.22, 0);
            group.add(leg);
            return group;
        }

        function createWoodenBench() {
            const group = new THREE.Group();
            const mat = new THREE.MeshLambertMaterial({ color: 0xd4a76a });
            const seat = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.05, 0.4), mat);
            seat.position.set(0, 0.45, 0);
            group.add(seat);
            const legs = [[0.65, 0.1], [0.65, -0.1], [-0.65, 0.1], [-0.65, -0.1]];
            legs.forEach(([x, z]) => {
                const leg = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.43, 0.05), mat);
                leg.position.set(x, 0.22, z);
                group.add(leg);
            });
            return group;
        }

        function createFoldingScreen() {
            const group = new THREE.Group();
            const mat = new THREE.MeshLambertMaterial({ color: 0xd4a76a, side: THREE.DoubleSide });
            for (let i = -1; i <= 1; i++) {
                const panel = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.8, 0.02), mat);
                panel.position.set(i * 0.5, 0.9, i * 0.1);
                panel.rotation.y = i * 0.3;
                group.add(panel);
            }
            return group;
        }

        function createWireRack() {
            const group = new THREE.Group();
            const mat = new THREE.MeshLambertMaterial({ color: 0x888888 });
            for (let y = 0; y < 4; y++) {
                const shelf = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.02, 0.3), mat);
                shelf.position.set(0, 0.3 + y * 0.3, 0);
                group.add(shelf);
            }
            const legs = [[0.18, 0.13], [0.18, -0.13], [-0.18, 0.13], [-0.18, -0.13]];
            legs.forEach(([x, z]) => {
                const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 1.2, 8), mat);
                leg.position.set(x, 0.6, z);
                group.add(leg);
            });
            return group;
        }

        function createStripedRug() {
            const group = new THREE.Group();
            const colors = [0xc9a227, 0x8b6914, 0xc9a227, 0x8b6914, 0xc9a227];
            const stripeWidth = 0.6;
            colors.forEach((color, i) => {
                const stripe = new THREE.Mesh(
                    new THREE.BoxGeometry(stripeWidth, 0.02, 2.5),
                    new THREE.MeshLambertMaterial({ color })
                );
                stripe.position.set((i - 2) * stripeWidth, 0.01, 0);
                group.add(stripe);
            });
            return group;
        }

        function createTablecloth(color) {
            const group = new THREE.Group();
            const cloth = new THREE.Mesh(
                new THREE.BoxGeometry(2.1, 0.02, 0.9),
                new THREE.MeshLambertMaterial({ color })
            );
            cloth.position.set(0, 0.74, 0);
            group.add(cloth);
            return group;
        }

        function createFloorLamp() {
            const group = new THREE.Group();
            const mat = new THREE.MeshLambertMaterial({ color: 0xf5f5f5 });
            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.18, 0.03, 16), mat);
            base.position.set(0, 0.015, 0);
            group.add(base);
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 1.5, 8), mat);
            pole.position.set(0, 0.78, 0);
            group.add(pole);
            const shade = new THREE.Mesh(
                new THREE.ConeGeometry(0.2, 0.25, 16, 1, true),
                new THREE.MeshLambertMaterial({ color: 0xf5f5dc, side: THREE.DoubleSide })
            );
            shade.position.set(0, 1.6, 0);
            shade.rotation.x = Math.PI;
            group.add(shade);
            return group;
        }

        function createDiscoBall() {
            const group = new THREE.Group();
            const ball = new THREE.Mesh(
                new THREE.SphereGeometry(0.15, 16, 16),
                new THREE.MeshLambertMaterial({ color: 0xc0c0c0 })
            );
            ball.position.set(0, 0, 0);
            group.add(ball);
            const cord = new THREE.Mesh(
                new THREE.CylinderGeometry(0.01, 0.01, 0.5, 8),
                new THREE.MeshLambertMaterial({ color: 0x333333 })
            );
            cord.position.set(0, 0.25, 0);
            group.add(cord);
            return group;
        }

        function createSmallPlant() {
            const group = new THREE.Group();
            const pot = new THREE.Mesh(
                new THREE.CylinderGeometry(0.08, 0.06, 0.12, 12),
                new THREE.MeshLambertMaterial({ color: 0x8b4513 })
            );
            pot.position.set(0, 0.06, 0);
            group.add(pot);
            const plant = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 8, 8),
                new THREE.MeshLambertMaterial({ color: 0x32cd32 })
            );
            plant.position.set(0, 0.18, 0);
            group.add(plant);
            return group;
        }

        function createVase() {
            const group = new THREE.Group();
            const vase = new THREE.Mesh(
                new THREE.CylinderGeometry(0.08, 0.12, 0.25, 12),
                new THREE.MeshLambertMaterial({ color: 0x4169e1 })
            );
            vase.position.set(0, 0.125, 0);
            group.add(vase);
            const flowers = new THREE.Mesh(
                new THREE.SphereGeometry(0.12, 8, 8),
                new THREE.MeshLambertMaterial({ color: 0xff69b4 })
            );
            flowers.position.set(0, 0.35, 0);
            group.add(flowers);
            return group;
        }

        function createWallPoster(color, width, height, text) {
            const group = new THREE.Group();
            const poster = new THREE.Mesh(
                new THREE.BoxGeometry(width, height, 0.02),
                new THREE.MeshLambertMaterial({ color })
            );
            poster.position.set(0, height/2, 0);
            group.add(poster);
            // Frame
            const frameMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
            const frameT = new THREE.Mesh(new THREE.BoxGeometry(width + 0.04, 0.02, 0.03), frameMat);
            frameT.position.set(0, height + 0.01, 0.01);
            group.add(frameT);
            const frameB = new THREE.Mesh(new THREE.BoxGeometry(width + 0.04, 0.02, 0.03), frameMat);
            frameB.position.set(0, -0.01, 0.01);
            group.add(frameB);
            const frameL = new THREE.Mesh(new THREE.BoxGeometry(0.02, height + 0.04, 0.03), frameMat);
            frameL.position.set(-width/2 - 0.01, height/2, 0.01);
            group.add(frameL);
            const frameR = new THREE.Mesh(new THREE.BoxGeometry(0.02, height + 0.04, 0.03), frameMat);
            frameR.position.set(width/2 + 0.01, height/2, 0.01);
            group.add(frameR);
            group.userData.isWallArt = true;
            return group;
        }

        function createTextBanner(text, bgColor, textColor = 0xffffff) {
            const group = new THREE.Group();
            const banner = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 1.0, 0.02),
                new THREE.MeshLambertMaterial({ color: bgColor })
            );
            banner.position.set(0, 0.5, 0);
            group.add(banner);
            group.userData.isWallArt = true;
            group.userData.bannerText = text;
            return group;
        }

        // ==========================================
        // PANAFRICAN-INSPIRED FURNITURE FUNCTIONS
        // Based on reference images from the mood board
        // ==========================================

        // TRIANGLE BEAN BAGS - Large triangular floor cushions
        function createTriangleBeanbag(color) {
            const group = new THREE.Group();
            // Large triangular floor cushion/beanbag - FLAT on the floor
            // Using a flattened cylinder (like a thick triangular cushion)
            const height = 0.2;  // Low to the ground
            const radius = 0.55;
            const geometry = new THREE.CylinderGeometry(radius * 0.3, radius, height, 3);
            const material = new THREE.MeshLambertMaterial({ color });
            const bean = new THREE.Mesh(geometry, material);
            bean.rotation.y = Math.PI / 6;  // Rotate for visual interest
            bean.position.set(0, height / 2, 0);  // Sits flat on floor (y=0)
            group.add(bean);
            return group;
        }

        // ETHNIC/VELVET CUSHIONS - Colorful floor cushions
        function createEthnicCushion(colors) {
            const group = new THREE.Group();
            const cushion = new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 0.15, 0.5),
                new THREE.MeshLambertMaterial({ color: colors[0] })
            );
            cushion.position.set(0, 0.08, 0);
            group.add(cushion);
            // Add pattern stripe
            const stripe = new THREE.Mesh(
                new THREE.BoxGeometry(0.52, 0.02, 0.1),
                new THREE.MeshLambertMaterial({ color: colors[1] || 0xffd700 })
            );
            stripe.position.set(0, 0.16, 0);
            group.add(stripe);
            return group;
        }

        function createVelvetCushion(color) {
            const group = new THREE.Group();
            const cushion = new THREE.Mesh(
                new THREE.BoxGeometry(0.45, 0.12, 0.45),
                new THREE.MeshLambertMaterial({ color })
            );
            cushion.position.set(0, 0.06, 0);
            group.add(cushion);
            // Tufted center button
            const button = new THREE.Mesh(
                new THREE.CylinderGeometry(0.03, 0.03, 0.02, 8),
                new THREE.MeshLambertMaterial({ color: 0x333333 })
            );
            button.position.set(0, 0.13, 0);
            group.add(button);
            return group;
        }

        function createPebbleCushion(color) {
            const group = new THREE.Group();
            const cushion = new THREE.Mesh(
                new THREE.SphereGeometry(0.25, 12, 12),
                new THREE.MeshLambertMaterial({ color })
            );
            cushion.scale.set(1, 0.4, 1);
            cushion.position.set(0, 0.1, 0);
            group.add(cushion);
            return group;
        }

        // ========== EXHIBITION FURNITURE (Curatorial) ==========
        // These are appropriate for a 3-day public exhibition context
        // NOT domestic/lounge furniture

        // SIMPLE POUF - Low, robust seating for collective use
        function createSimplePouf(color) {
            const group = new THREE.Group();
            const mat = new THREE.MeshLambertMaterial({ color });
            const pouf = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.28, 0.35, 16), mat);
            pouf.position.set(0, 0.175, 0);
            group.add(pouf);
            return group;
        }

        // AUDIO STATION - DJ/Radio terminal
        function createAudioStation() {
            const group = new THREE.Group();
            const woodMat = new THREE.MeshLambertMaterial({ color: 0x8b7355 });
            const metalMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
            // Table
            const table = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.05, 0.6), woodMat);
            table.position.set(0, 0.75, 0);
            group.add(table);
            // Legs
            for (let x of [-0.55, 0.55]) {
                for (let z of [-0.25, 0.25]) {
                    const leg = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.75, 0.04), metalMat);
                    leg.position.set(x, 0.375, z);
                    group.add(leg);
                }
            }
            // Equipment (mixer/laptop placeholder)
            const equipment = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.08, 0.3), metalMat);
            equipment.position.set(0, 0.82, 0);
            group.add(equipment);
            return group;
        }

        // FLOOR SPEAKER - Exhibition audio
        function createFloorSpeaker() {
            // Speaker on stand - cabinet sits DIRECTLY on stand top plate
            const group = new THREE.Group();
            const mat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
            const metalMat = new THREE.MeshLambertMaterial({ color: 0x333333 });

            // Speaker Stand
            const standHeight = 0.75;  // Stand pole height
            const topPlateY = standHeight + 0.02;  // Top of stand
            const cabinetHeight = 0.4;  // Speaker cabinet height
            const cabinetY = topPlateY + cabinetHeight / 2 + 0.01;  // Cabinet center (sits on top plate)

            // Base plate (on floor)
            const basePlate = new THREE.Mesh(new THREE.BoxGeometry(0.32, 0.02, 0.32), metalMat);
            basePlate.position.set(0, 0.01, 0);
            group.add(basePlate);

            // Center pole
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.022, 0.022, standHeight, 8), metalMat);
            pole.position.set(0, standHeight / 2 + 0.02, 0);
            group.add(pole);

            // Top plate (speaker sits here)
            const topPlate = new THREE.Mesh(new THREE.BoxGeometry(0.26, 0.02, 0.22), metalMat);
            topPlate.position.set(0, topPlateY, 0);
            group.add(topPlate);

            // Speaker Cabinet - sits directly on top plate, NO gap
            const cabinet = new THREE.Mesh(new THREE.BoxGeometry(0.24, cabinetHeight, 0.20), mat);
            cabinet.position.set(0, cabinetY, 0);
            group.add(cabinet);

            // Woofer (driver faces +Z, when rotated 180deg faces into room)
            const woofer = new THREE.Mesh(
                new THREE.CylinderGeometry(0.07, 0.07, 0.03, 16),
                new THREE.MeshLambertMaterial({ color: 0x444444 })
            );
            woofer.rotation.x = Math.PI / 2;
            woofer.position.set(0, cabinetY - 0.06, 0.11);
            group.add(woofer);

            // Tweeter
            const tweeter = new THREE.Mesh(
                new THREE.CylinderGeometry(0.025, 0.025, 0.02, 12),
                new THREE.MeshLambertMaterial({ color: 0x666666 })
            );
            tweeter.rotation.x = Math.PI / 2;
            tweeter.position.set(0, cabinetY + 0.10, 0.11);
            group.add(tweeter);

            // LED indicator
            const led = new THREE.Mesh(
                new THREE.SphereGeometry(0.008, 8, 8),
                new THREE.MeshLambertMaterial({ color: 0x00ff00, emissive: 0x00ff00 })
            );
            led.position.set(0, cabinetY + 0.17, 0.11);
            group.add(led);

            return group;
        }

        // AFRIKADAA WALL POSTER - Magazine cover style artwork
        // Creates a framed poster with text overlay for wall decoration
        function createAfrikadaaPoster(text, color, width, height) {
            const group = new THREE.Group();

            // Frame
            const frameThickness = 0.025;
            const frameDepth = 0.02;
            const frameMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });

            // Frame sides
            const topFrame = new THREE.Mesh(new THREE.BoxGeometry(width + frameThickness * 2, frameThickness, frameDepth), frameMat);
            topFrame.position.set(0, height / 2 + frameThickness / 2, 0);
            group.add(topFrame);

            const bottomFrame = new THREE.Mesh(new THREE.BoxGeometry(width + frameThickness * 2, frameThickness, frameDepth), frameMat);
            bottomFrame.position.set(0, -height / 2 - frameThickness / 2, 0);
            group.add(bottomFrame);

            const leftFrame = new THREE.Mesh(new THREE.BoxGeometry(frameThickness, height, frameDepth), frameMat);
            leftFrame.position.set(-width / 2 - frameThickness / 2, 0, 0);
            group.add(leftFrame);

            const rightFrame = new THREE.Mesh(new THREE.BoxGeometry(frameThickness, height, frameDepth), frameMat);
            rightFrame.position.set(width / 2 + frameThickness / 2, 0, 0);
            group.add(rightFrame);

            // Poster background (colored)
            const posterMat = new THREE.MeshLambertMaterial({ color: color });
            const poster = new THREE.Mesh(new THREE.PlaneGeometry(width, height), posterMat);
            poster.position.set(0, 0, 0.005);
            group.add(poster);

            // Abstract geometric elements (Afrikadaa style - bold, graphic)
            const accentMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
            const darkMat = new THREE.MeshLambertMaterial({ color: 0x000000 });

            // Diagonal stripe
            const stripe = new THREE.Mesh(new THREE.PlaneGeometry(width * 0.15, height * 1.2), accentMat);
            stripe.position.set(-width * 0.2, 0, 0.006);
            stripe.rotation.z = Math.PI / 6;
            group.add(stripe);

            // Circle element
            const circle = new THREE.Mesh(new THREE.CircleGeometry(width * 0.12, 24), darkMat);
            circle.position.set(width * 0.25, height * 0.2, 0.007);
            group.add(circle);

            // Small accent squares
            const sq1 = new THREE.Mesh(new THREE.PlaneGeometry(width * 0.08, width * 0.08), accentMat);
            sq1.position.set(width * 0.3, -height * 0.3, 0.007);
            group.add(sq1);

            const sq2 = new THREE.Mesh(new THREE.PlaneGeometry(width * 0.05, width * 0.05), darkMat);
            sq2.position.set(-width * 0.35, height * 0.35, 0.007);
            group.add(sq2);

            // Text bar at bottom (simulated text block)
            const textBar = new THREE.Mesh(new THREE.PlaneGeometry(width * 0.7, height * 0.08), darkMat);
            textBar.position.set(0, -height * 0.38, 0.008);
            group.add(textBar);

            // White text underline
            const textLine = new THREE.Mesh(new THREE.PlaneGeometry(width * 0.5, height * 0.015), accentMat);
            textLine.position.set(0, -height * 0.42, 0.009);
            group.add(textLine);

            return group;
        }

        // HEADPHONE STATION - Standing/wall mount
        function createHeadphoneStation() {
            const group = new THREE.Group();
            const metalMat = new THREE.MeshLambertMaterial({ color: 0x555555 });
            // Stand
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 1.2, 8), metalMat);
            pole.position.set(0, 0.6, 0);
            group.add(pole);
            // Base
            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 0.03, 16), metalMat);
            base.position.set(0, 0.015, 0);
            group.add(base);
            // Headphone hook
            const hook = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.02, 0.08), metalMat);
            hook.position.set(0, 1.1, 0.05);
            group.add(hook);
            // Headphones
            const hpMat = new THREE.MeshLambertMaterial({ color: 0x222222 });
            const hpBand = new THREE.Mesh(new THREE.TorusGeometry(0.08, 0.015, 8, 16, Math.PI), hpMat);
            hpBand.position.set(0, 1.08, 0.05);
            group.add(hpBand);
            return group;
        }

        // READING TABLE - Simple, robust, rectangular
        function createReadingTable() {
            const group = new THREE.Group();
            const woodMat = new THREE.MeshLambertMaterial({ color: 0xb5906c });
            const metalMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
            // Top
            const top = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.04, 0.9), woodMat);
            top.position.set(0, 0.72, 0);
            group.add(top);
            // Metal frame legs
            for (let x of [-0.85, 0.85]) {
                const legFrame = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.7, 0.8), metalMat);
                legFrame.position.set(x, 0.35, 0);
                group.add(legFrame);
            }
            // Cross bar
            const crossBar = new THREE.Mesh(new THREE.BoxGeometry(1.66, 0.03, 0.03), metalMat);
            crossBar.position.set(0, 0.15, 0);
            group.add(crossBar);
            return group;
        }

        // STACKABLE CHAIR - Simple, functional
        function createStackableChair() {
            const group = new THREE.Group();
            const woodMat = new THREE.MeshLambertMaterial({ color: 0xc4a77d });
            const metalMat = new THREE.MeshLambertMaterial({ color: 0x444444 });
            // Seat
            const seat = new THREE.Mesh(new THREE.BoxGeometry(0.42, 0.025, 0.4), woodMat);
            seat.position.set(0, 0.45, 0);
            group.add(seat);
            // Back
            const back = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.35, 0.02), woodMat);
            back.position.set(0, 0.7, -0.18);
            group.add(back);
            // Legs (metal tube)
            for (let x of [-0.18, 0.18]) {
                for (let z of [-0.15, 0.15]) {
                    const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.012, 0.45, 8), metalMat);
                    leg.position.set(x, 0.225, z);
                    group.add(leg);
                }
            }
            return group;
        }

        // WALL SHELF - For archives and books
        function createWallShelf() {
            const group = new THREE.Group();
            const woodMat = new THREE.MeshLambertMaterial({ color: 0xb5906c });
            const metalMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
            // Shelf
            const shelf = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.025, 0.25), woodMat);
            shelf.position.set(0, 0, 0);
            group.add(shelf);
            // Brackets
            const bracket1 = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.15, 0.2), metalMat);
            bracket1.position.set(-0.5, -0.075, 0);
            group.add(bracket1);
            const bracket2 = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.15, 0.2), metalMat);
            bracket2.position.set(0.5, -0.075, 0);
            group.add(bracket2);
            // Some books
            const bookColors = [0x8b0000, 0x1a3a5c, 0x2e7d32, 0xf57c00];
            for (let i = 0; i < 4; i++) {
                const book = new THREE.Mesh(
                    new THREE.BoxGeometry(0.15, 0.22, 0.03),
                    new THREE.MeshLambertMaterial({ color: bookColors[i] })
                );
                book.position.set(-0.4 + i * 0.25, 0.12, 0);
                group.add(book);
            }
            return group;
        }

        // LOW ARCHIVE CABINET
        function createLowArchiveCabinet() {
            const group = new THREE.Group();
            const woodMat = new THREE.MeshLambertMaterial({ color: 0xa08060 });
            // Main body
            const body = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.6, 0.4), woodMat);
            body.position.set(0, 0.3, 0);
            group.add(body);
            // Drawer lines
            const lineMat = new THREE.MeshLambertMaterial({ color: 0x5a4535 });
            for (let y of [0.15, 0.35, 0.55]) {
                const line = new THREE.Mesh(new THREE.BoxGeometry(0.96, 0.01, 0.01), lineMat);
                line.position.set(0, y, 0.2);
                group.add(line);
            }
            return group;
        }

        // SCREEN STAND - For video content
        function createScreenStand() {
            const group = new THREE.Group();
            const metalMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const screenMat = new THREE.MeshLambertMaterial({ color: 0x111111 });
            // Pole
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 1.5, 8), metalMat);
            pole.position.set(0, 0.75, 0);
            group.add(pole);
            // Base
            const base = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.03, 0.4), metalMat);
            base.position.set(0, 0.015, 0);
            group.add(base);
            // Screen
            const screen = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.35, 0.03), screenMat);
            screen.position.set(0, 1.4, 0);
            group.add(screen);
            // Screen content (placeholder)
            const content = new THREE.Mesh(
                new THREE.PlaneGeometry(0.55, 0.3),
                new THREE.MeshLambertMaterial({ color: 0x2a4a6a })
            );
            content.position.set(0, 1.4, 0.02);
            group.add(content);
            return group;
        }

        // SIMPLE STOOL - For viewing areas
        function createSimpleStool() {
            const group = new THREE.Group();
            const woodMat = new THREE.MeshLambertMaterial({ color: 0xb5906c });
            const metalMat = new THREE.MeshLambertMaterial({ color: 0x444444 });
            // Seat
            const seat = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 0.03, 16), woodMat);
            seat.position.set(0, 0.45, 0);
            group.add(seat);
            // Legs
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.012, 0.44, 8), metalMat);
                leg.position.set(Math.cos(angle) * 0.1, 0.22, Math.sin(angle) * 0.1);
                group.add(leg);
            }
            return group;
        }

        // SIMPLE PENDANT LIGHT - Functional, not decorative
        function createSimplePendant() {
            const group = new THREE.Group();
            const metalMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const lightMat = new THREE.MeshLambertMaterial({ color: 0xffffee, emissive: 0x444422 });
            // Cord
            const cord = new THREE.Mesh(new THREE.CylinderGeometry(0.005, 0.005, 0.3, 8), metalMat);
            cord.position.set(0, 0.15, 0);
            group.add(cord);
            // Shade
            const shade = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.2, 0.15, 16, 1, true), metalMat);
            shade.position.set(0, -0.05, 0);
            group.add(shade);
            // Bulb
            const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.05, 12, 12), lightMat);
            bulb.position.set(0, -0.02, 0);
            group.add(bulb);
            return group;
        }

        // OLIVE VELVET SOFA - Low-profile tufted sofa
        function createOliveSofa() {
            const group = new THREE.Group();
            const mat = new THREE.MeshLambertMaterial({ color: 0x6b8e23 }); // Olive green
            // Seat
            const seat = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.25, 0.9), mat);
            seat.position.set(0, 0.2, 0);
            group.add(seat);
            // Low back
            const back = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.35, 0.15), mat);
            back.position.set(0, 0.45, -0.4);
            group.add(back);
            // Rounded arms
            const armMat = new THREE.MeshLambertMaterial({ color: 0x5a7d1a });
            const armL = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.9, 12), armMat);
            armL.rotation.x = Math.PI / 2;
            armL.position.set(-0.95, 0.3, 0);
            group.add(armL);
            const armR = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.9, 12), armMat);
            armR.rotation.x = Math.PI / 2;
            armR.position.set(0.95, 0.3, 0);
            group.add(armR);
            // Tufting buttons
            for (let x = -0.6; x <= 0.6; x += 0.4) {
                for (let z = -0.2; z <= 0.2; z += 0.4) {
                    const btn = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.02, 0.02, 0.02, 8),
                        new THREE.MeshLambertMaterial({ color: 0x333333 })
                    );
                    btn.position.set(x, 0.34, z);
                    group.add(btn);
                }
            }
            return group;
        }

        // PINK VELVET ARMCHAIR
        function createPinkArmchair() {
            const group = new THREE.Group();
            const mat = new THREE.MeshLambertMaterial({ color: 0xe91e63 }); // Pink
            // Seat
            const seat = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.2, 0.7), mat);
            seat.position.set(0, 0.25, 0);
            group.add(seat);
            // Back - curved
            const back = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.6, 0.1), mat);
            back.position.set(0, 0.6, -0.3);
            group.add(back);
            // Arms
            const armL = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.3, 0.6), mat);
            armL.position.set(-0.35, 0.4, 0);
            group.add(armL);
            const armR = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.3, 0.6), mat);
            armR.position.set(0.35, 0.4, 0);
            group.add(armR);
            // Legs - wooden
            const legMat = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
            [[-0.25, -0.25], [-0.25, 0.25], [0.25, -0.25], [0.25, 0.25]].forEach(([x, z]) => {
                const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.02, 0.15, 8), legMat);
                leg.position.set(x, 0.075, z);
                group.add(leg);
            });
            return group;
        }

        // BOOK DISPLAYS & STORAGE
        function createWallBookcase() {
            const group = new THREE.Group();
            const woodMat = new THREE.MeshLambertMaterial({ color: 0xd4a76a });
            // Back panel
            const back = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.8, 0.03), woodMat);
            back.position.set(0, 0.9, -0.15);
            group.add(back);
            // Shelves
            for (let y = 0.15; y <= 1.65; y += 0.3) {
                const shelf = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.03, 0.3), woodMat);
                shelf.position.set(0, y, 0);
                group.add(shelf);
                // Add some books
                const bookColors = [0xc41e3a, 0x1a3a5c, 0xfdd835, 0x4caf50, 0x9c27b0];
                for (let i = 0; i < 5; i++) {
                    const book = new THREE.Mesh(
                        new THREE.BoxGeometry(0.05 + Math.random() * 0.03, 0.2 + Math.random() * 0.05, 0.15),
                        new THREE.MeshLambertMaterial({ color: bookColors[i % bookColors.length] })
                    );
                    book.position.set(-0.45 + i * 0.2, y + 0.12, 0);
                    group.add(book);
                }
            }
            // Sides
            const sideL = new THREE.Mesh(new THREE.BoxGeometry(0.03, 1.8, 0.3), woodMat);
            sideL.position.set(-0.6, 0.9, 0);
            group.add(sideL);
            const sideR = new THREE.Mesh(new THREE.BoxGeometry(0.03, 1.8, 0.3), woodMat);
            sideR.position.set(0.6, 0.9, 0);
            group.add(sideR);
            return group;
        }

        function createBookCubby() {
            const group = new THREE.Group();
            const woodMat = new THREE.MeshLambertMaterial({ color: 0xdeb887 }); // Light wood
            // Create cubby grid
            const cubbies = 3;
            const cubbySize = 0.35;
            for (let x = 0; x < cubbies; x++) {
                for (let y = 0; y < cubbies; y++) {
                    // Cubby box
                    const box = new THREE.Mesh(
                        new THREE.BoxGeometry(cubbySize, cubbySize, 0.3),
                        woodMat
                    );
                    box.position.set((x - 1) * (cubbySize + 0.02), y * (cubbySize + 0.02) + cubbySize/2, 0);
                    group.add(box);
                    // Random content
                    if (Math.random() > 0.3) {
                        const content = new THREE.Mesh(
                            new THREE.BoxGeometry(cubbySize * 0.8, cubbySize * 0.7, 0.15),
                            new THREE.MeshLambertMaterial({ color: [0xc41e3a, 0x1a3a5c, 0xfdd835, 0x4caf50][Math.floor(Math.random() * 4)] })
                        );
                        content.position.set((x - 1) * (cubbySize + 0.02), y * (cubbySize + 0.02) + cubbySize/2, 0.05);
                        group.add(content);
                    }
                }
            }
            return group;
        }

        function createMagazineRack() {
            const group = new THREE.Group();
            const wireMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
            // Wire frame
            for (let i = 0; i < 4; i++) {
                const wire = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.01, 0.01, 0.6, 8),
                    wireMat
                );
                wire.rotation.z = Math.PI / 6;
                wire.position.set(-0.15 + i * 0.1, 0.35, 0);
                group.add(wire);
            }
            // Base
            const base = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.02, 0.2), wireMat);
            base.position.set(0, 0.02, 0);
            group.add(base);
            // Magazines
            const magColors = [0xff6b6b, 0x45b7d1, 0xfdd835, 0x4caf50];
            for (let i = 0; i < 4; i++) {
                const mag = new THREE.Mesh(
                    new THREE.BoxGeometry(0.02, 0.28, 0.2),
                    new THREE.MeshLambertMaterial({ color: magColors[i] })
                );
                mag.rotation.z = Math.PI / 6;
                mag.position.set(-0.12 + i * 0.08, 0.25 + i * 0.03, 0);
                group.add(mag);
            }
            return group;
        }

        function createBookStack() {
            const group = new THREE.Group();
            const colors = [0xc41e3a, 0x1a3a5c, 0xfdd835, 0x4caf50, 0x9c27b0, 0xff6b6b];
            let y = 0;
            for (let i = 0; i < 5; i++) {
                const book = new THREE.Mesh(
                    new THREE.BoxGeometry(0.2 + Math.random() * 0.05, 0.03 + Math.random() * 0.02, 0.15),
                    new THREE.MeshLambertMaterial({ color: colors[i % colors.length] })
                );
                book.position.set((Math.random() - 0.5) * 0.03, y + 0.015, 0);
                book.rotation.y = (Math.random() - 0.5) * 0.2;
                group.add(book);
                y += 0.035;
            }
            return group;
        }

        function createColorDisplay(color) {
            const group = new THREE.Group();
            const mat = new THREE.MeshLambertMaterial({ color });
            // Pedestal display
            const base = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.6, 0.4), mat);
            base.position.set(0, 0.3, 0);
            group.add(base);
            // Books on top
            const bookMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
            for (let i = 0; i < 3; i++) {
                const book = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.04, 0.12), bookMat);
                book.position.set(-0.1 + i * 0.1, 0.62 + i * 0.04, 0);
                book.rotation.y = (Math.random() - 0.5) * 0.3;
                group.add(book);
            }
            return group;
        }

        function createLeaningShelf() {
            const group = new THREE.Group();
            const woodMat = new THREE.MeshLambertMaterial({ color: 0xd4a76a });
            // Leaning frame
            const angle = Math.PI / 12;
            for (let side = -1; side <= 1; side += 2) {
                const leg = new THREE.Mesh(new THREE.BoxGeometry(0.04, 1.5, 0.04), woodMat);
                leg.position.set(side * 0.4, 0.7, -0.1);
                leg.rotation.x = -angle;
                group.add(leg);
            }
            // Shelves
            for (let i = 0; i < 4; i++) {
                const shelf = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.02, 0.25), woodMat);
                shelf.position.set(0, 0.2 + i * 0.35, -0.05 - i * 0.08);
                group.add(shelf);
            }
            return group;
        }

        // RUGS - Layered Persian & African
        function createLayeredRug(width, depth, color) {
            const group = new THREE.Group();
            const rugMat = new THREE.MeshLambertMaterial({ color });
            const rug = new THREE.Mesh(new THREE.BoxGeometry(width, 0.02, depth), rugMat);
            rug.position.set(0, 0.01, 0);
            group.add(rug);
            // Border
            const borderMat = new THREE.MeshLambertMaterial({ color: darkenColor(color, 0.3) });
            const borderW = 0.08;
            const borderT = new THREE.Mesh(new THREE.BoxGeometry(width, 0.025, borderW), borderMat);
            borderT.position.set(0, 0.012, depth/2 - borderW/2);
            group.add(borderT);
            const borderB = new THREE.Mesh(new THREE.BoxGeometry(width, 0.025, borderW), borderMat);
            borderB.position.set(0, 0.012, -depth/2 + borderW/2);
            group.add(borderB);
            const borderL = new THREE.Mesh(new THREE.BoxGeometry(borderW, 0.025, depth), borderMat);
            borderL.position.set(-width/2 + borderW/2, 0.012, 0);
            group.add(borderL);
            const borderR = new THREE.Mesh(new THREE.BoxGeometry(borderW, 0.025, depth), borderMat);
            borderR.position.set(width/2 - borderW/2, 0.012, 0);
            group.add(borderR);
            return group;
        }

        function darkenColor(color, amount) {
            const r = ((color >> 16) & 255) * (1 - amount);
            const g = ((color >> 8) & 255) * (1 - amount);
            const b = (color & 255) * (1 - amount);
            return (Math.floor(r) << 16) | (Math.floor(g) << 8) | Math.floor(b);
        }

        // NATTE PLASTIQUE - Senegalese woven plastic mat (checkered pattern)
        function createAfricanNatte() {
            const group = new THREE.Group();
            const width = 2.2, depth = 1.6;
            // Base mat
            const baseMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
            const base = new THREE.Mesh(new THREE.BoxGeometry(width, 0.015, depth), baseMat);
            base.position.set(0, 0.008, 0);
            group.add(base);
            // Checkered pattern (like Senegalese nattes plastiques)
            const colors = [0xff1493, 0x00ced1, 0xffd700, 0xf5f0e8, 0xff6b6b, 0x32cd32];
            const squareSize = 0.15;
            const cols = Math.floor(width / squareSize);
            const rows = Math.floor(depth / squareSize);
            for (let x = 0; x < cols; x++) {
                for (let z = 0; z < rows; z++) {
                    if ((x + z) % 2 === 0) {
                        const color = colors[(x + z * 2) % colors.length];
                        const square = new THREE.Mesh(
                            new THREE.BoxGeometry(squareSize * 0.9, 0.018, squareSize * 0.9),
                            new THREE.MeshLambertMaterial({ color })
                        );
                        square.position.set(
                            -width/2 + squareSize/2 + x * squareSize,
                            0.01,
                            -depth/2 + squareSize/2 + z * squareSize
                        );
                        group.add(square);
                    }
                }
            }
            return group;
        }

        function createCheckeredRug(color1, color2) {
            const group = new THREE.Group();
            const size = 0.3;
            const count = 6;
            for (let x = 0; x < count; x++) {
                for (let z = 0; z < count; z++) {
                    const color = (x + z) % 2 === 0 ? color1 : color2;
                    const tile = new THREE.Mesh(
                        new THREE.BoxGeometry(size, 0.02, size),
                        new THREE.MeshLambertMaterial({ color })
                    );
                    tile.position.set((x - count/2 + 0.5) * size, 0.01, (z - count/2 + 0.5) * size);
                    group.add(tile);
                }
            }
            return group;
        }

        function createWaxPrintRug(color1, color2) {
            const group = new THREE.Group();
            const width = 2.0, depth = 1.5;
            // Base
            const base = new THREE.Mesh(
                new THREE.BoxGeometry(width, 0.02, depth),
                new THREE.MeshLambertMaterial({ color: color1 })
            );
            base.position.set(0, 0.01, 0);
            group.add(base);
            // African wax print pattern - circular motifs
            for (let x = -0.6; x <= 0.6; x += 0.4) {
                for (let z = -0.4; z <= 0.4; z += 0.4) {
                    const circle = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.12, 0.12, 0.025, 16),
                        new THREE.MeshLambertMaterial({ color: color2 })
                    );
                    circle.position.set(x, 0.012, z);
                    group.add(circle);
                    // Inner circle
                    const inner = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.06, 0.06, 0.027, 12),
                        new THREE.MeshLambertMaterial({ color: color1 })
                    );
                    inner.position.set(x, 0.014, z);
                    group.add(inner);
                }
            }
            return group;
        }

        function createGeometricRug() {
            const group = new THREE.Group();
            const width = 2.2, depth = 1.6;
            // Base - cream
            const base = new THREE.Mesh(
                new THREE.BoxGeometry(width, 0.02, depth),
                new THREE.MeshLambertMaterial({ color: 0xf5f0e8 })
            );
            base.position.set(0, 0.01, 0);
            group.add(base);
            // Black geometric triangles
            const triMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
            const triShape = new THREE.Shape();
            triShape.moveTo(0, 0.15);
            triShape.lineTo(-0.1, 0);
            triShape.lineTo(0.1, 0);
            triShape.lineTo(0, 0.15);
            const triGeo = new THREE.ShapeGeometry(triShape);
            for (let x = -0.7; x <= 0.7; x += 0.35) {
                for (let z = -0.5; z <= 0.5; z += 0.3) {
                    const tri = new THREE.Mesh(triGeo, triMat);
                    tri.rotation.x = -Math.PI / 2;
                    tri.position.set(x, 0.012, z);
                    if (Math.random() > 0.5) tri.rotation.z = Math.PI;
                    group.add(tri);
                }
            }
            return group;
        }

        function createTieDyeCloth() {
            const group = new THREE.Group();
            // Table-sized cloth
            const cloth = new THREE.Mesh(
                new THREE.BoxGeometry(1.8, 0.01, 0.8),
                new THREE.MeshLambertMaterial({ color: 0x4169e1 })
            );
            cloth.position.set(0, 0.72, 0);
            group.add(cloth);
            // Tie-dye circles
            const dyeColors = [0xffffff, 0x9c27b0, 0x00bcd4];
            for (let i = 0; i < 5; i++) {
                const circle = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1 + Math.random() * 0.1, 0.1, 0.015, 12),
                    new THREE.MeshLambertMaterial({ color: dyeColors[i % dyeColors.length] })
                );
                circle.position.set(-0.6 + i * 0.3, 0.725, (Math.random() - 0.5) * 0.4);
                group.add(circle);
            }
            return group;
        }

        // LIGHTING - Ethiopian & Disco
        function createEthiopianLamp() {
            const group = new THREE.Group();
            // Woven basket shade
            const shadeMat = new THREE.MeshLambertMaterial({ color: 0xd4a76a, side: THREE.DoubleSide });
            const shade = new THREE.Mesh(
                new THREE.ConeGeometry(0.25, 0.35, 12, 1, true),
                shadeMat
            );
            shade.position.set(0, 0, 0);
            shade.rotation.x = Math.PI;
            group.add(shade);
            // Beaded fringe
            const beadMat = new THREE.MeshLambertMaterial({ color: 0xc41e3a });
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                for (let j = 0; j < 4; j++) {
                    const bead = new THREE.Mesh(
                        new THREE.SphereGeometry(0.015, 6, 6),
                        j % 2 === 0 ? beadMat : new THREE.MeshLambertMaterial({ color: 0xfdd835 })
                    );
                    bead.position.set(
                        Math.cos(angle) * 0.23,
                        -0.38 - j * 0.04,
                        Math.sin(angle) * 0.23
                    );
                    group.add(bead);
                }
            }
            // Cord
            const cord = new THREE.Mesh(
                new THREE.CylinderGeometry(0.01, 0.01, 0.5, 8),
                new THREE.MeshLambertMaterial({ color: 0x8b4513 })
            );
            cord.position.set(0, 0.42, 0);
            group.add(cord);
            return group;
        }

        function createBeadedLamp() {
            const group = new THREE.Group();
            // Cylinder shade
            const shadeMat = new THREE.MeshLambertMaterial({ color: 0xf5f5dc, side: THREE.DoubleSide });
            const shade = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.2, 0.3, 12, 1, true),
                shadeMat
            );
            shade.position.set(0, 0, 0);
            group.add(shade);
            // Colorful beads hanging
            const beadColors = [0xc41e3a, 0xfdd835, 0x4caf50, 0x2196f3, 0x9c27b0];
            for (let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2;
                const color = beadColors[i % beadColors.length];
                for (let j = 0; j < 6; j++) {
                    const bead = new THREE.Mesh(
                        new THREE.SphereGeometry(0.012, 6, 6),
                        new THREE.MeshLambertMaterial({ color })
                    );
                    bead.position.set(
                        Math.cos(angle) * 0.18,
                        -0.18 - j * 0.025,
                        Math.sin(angle) * 0.18
                    );
                    group.add(bead);
                }
            }
            // Cord
            const cord = new THREE.Mesh(
                new THREE.CylinderGeometry(0.01, 0.01, 0.4, 8),
                new THREE.MeshLambertMaterial({ color: 0x333333 })
            );
            cord.position.set(0, 0.35, 0);
            group.add(cord);
            return group;
        }

        function createDiscoBallCluster() {
            const group = new THREE.Group();
            const ballMat = new THREE.MeshLambertMaterial({ color: 0xc0c0c0 });
            const cordMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
            // Multiple balls at different heights
            const positions = [
                { x: 0, y: 0, z: 0, size: 0.15, cordLen: 0.3 },
                { x: 0.25, y: 0.15, z: 0.1, size: 0.1, cordLen: 0.15 },
                { x: -0.2, y: 0.1, z: -0.1, size: 0.12, cordLen: 0.2 },
                { x: 0.1, y: -0.1, z: 0.2, size: 0.08, cordLen: 0.4 }
            ];
            positions.forEach(p => {
                const ball = new THREE.Mesh(new THREE.SphereGeometry(p.size, 12, 12), ballMat);
                ball.position.set(p.x, p.y, p.z);
                group.add(ball);
                const cord = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.008, 0.008, p.cordLen, 8),
                    cordMat
                );
                cord.position.set(p.x, p.y + p.size + p.cordLen/2, p.z);
                group.add(cord);
            });
            return group;
        }

        function createStringLights() {
            const group = new THREE.Group();
            const wireMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const bulbColors = [0xfdd835, 0xff6b6b, 0x4caf50, 0x2196f3, 0x9c27b0];
            // Wire
            const points = [];
            for (let i = 0; i <= 10; i++) {
                points.push(new THREE.Vector3(
                    -1.5 + i * 0.3,
                    Math.sin(i * 0.5) * 0.1,
                    0
                ));
            }
            // Bulbs along the wire
            for (let i = 0; i < 10; i++) {
                const bulb = new THREE.Mesh(
                    new THREE.SphereGeometry(0.03, 8, 8),
                    new THREE.MeshLambertMaterial({ color: bulbColors[i % bulbColors.length], emissive: bulbColors[i % bulbColors.length], emissiveIntensity: 0.3 })
                );
                bulb.position.set(-1.5 + i * 0.3, Math.sin(i * 0.5) * 0.1 - 0.05, 0);
                group.add(bulb);
                // Wire segment
                if (i < 9) {
                    const wire = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.005, 0.005, 0.3, 6),
                        wireMat
                    );
                    wire.position.set(-1.35 + i * 0.3, Math.sin(i * 0.5 + 0.25) * 0.1, 0);
                    wire.rotation.z = Math.PI / 2;
                    group.add(wire);
                }
            }
            return group;
        }

        function createPaperLantern() {
            const group = new THREE.Group();
            const lanternMat = new THREE.MeshLambertMaterial({
                color: 0xfff8e1,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.9
            });
            const lantern = new THREE.Mesh(
                new THREE.SphereGeometry(0.2, 16, 12),
                lanternMat
            );
            lantern.scale.set(1, 1.2, 1);
            lantern.position.set(0, 0, 0);
            group.add(lantern);
            // Wire frame rings
            const wireMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
            for (let i = -0.15; i <= 0.15; i += 0.1) {
                const ring = new THREE.Mesh(
                    new THREE.TorusGeometry(0.18, 0.005, 8, 16),
                    wireMat
                );
                ring.position.set(0, i, 0);
                ring.rotation.x = Math.PI / 2;
                group.add(ring);
            }
            // Cord
            const cord = new THREE.Mesh(
                new THREE.CylinderGeometry(0.01, 0.01, 0.3, 8),
                wireMat
            );
            cord.position.set(0, 0.38, 0);
            group.add(cord);
            return group;
        }

        // PLANTS & AFRICAN DECOR
        function createPalmPlant() {
            const group = new THREE.Group();
            // Pot
            const potMat = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
            const pot = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.12, 0.25, 12), potMat);
            pot.position.set(0, 0.125, 0);
            group.add(pot);
            // Soil
            const soil = new THREE.Mesh(
                new THREE.CylinderGeometry(0.14, 0.14, 0.03, 12),
                new THREE.MeshLambertMaterial({ color: 0x3e2723 })
            );
            soil.position.set(0, 0.24, 0);
            group.add(soil);
            // Palm fronds
            const leafMat = new THREE.MeshLambertMaterial({ color: 0x2e7d32, side: THREE.DoubleSide });
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const leaf = new THREE.Mesh(
                    new THREE.BoxGeometry(0.08, 0.5, 0.01),
                    leafMat
                );
                leaf.position.set(
                    Math.cos(angle) * 0.1,
                    0.5,
                    Math.sin(angle) * 0.1
                );
                leaf.rotation.x = -0.5;
                leaf.rotation.y = angle;
                leaf.rotation.z = 0.3;
                group.add(leaf);
            }
            return group;
        }

        function createHangingPlant() {
            const group = new THREE.Group();
            // Macrame holder
            const cordMat = new THREE.MeshLambertMaterial({ color: 0xf5f5dc });
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const cord = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.008, 0.008, 0.4, 6),
                    cordMat
                );
                cord.position.set(Math.cos(angle) * 0.1, 0.2, Math.sin(angle) * 0.1);
                group.add(cord);
            }
            // Pot
            const pot = new THREE.Mesh(
                new THREE.CylinderGeometry(0.12, 0.1, 0.15, 12),
                new THREE.MeshLambertMaterial({ color: 0xd4a76a })
            );
            pot.position.set(0, 0, 0);
            group.add(pot);
            // Trailing vines
            const vineMat = new THREE.MeshLambertMaterial({ color: 0x4caf50 });
            for (let i = 0; i < 5; i++) {
                const angle = (i / 5) * Math.PI * 2;
                for (let j = 0; j < 4; j++) {
                    const leaf = new THREE.Mesh(
                        new THREE.SphereGeometry(0.025, 6, 6),
                        vineMat
                    );
                    leaf.position.set(
                        Math.cos(angle) * (0.12 + j * 0.03),
                        -0.1 - j * 0.08,
                        Math.sin(angle) * (0.12 + j * 0.03)
                    );
                    group.add(leaf);
                }
            }
            return group;
        }

        function createPothosVine() {
            const group = new THREE.Group();
            // Small pot
            const pot = new THREE.Mesh(
                new THREE.CylinderGeometry(0.08, 0.06, 0.1, 10),
                new THREE.MeshLambertMaterial({ color: 0xffffff })
            );
            pot.position.set(0, 0.05, 0);
            group.add(pot);
            // Trailing vine with heart-shaped leaves
            const leafMat = new THREE.MeshLambertMaterial({ color: 0x66bb6a });
            const vineMat = new THREE.MeshLambertMaterial({ color: 0x2e7d32 });
            for (let v = 0; v < 3; v++) {
                const angle = (v / 3) * Math.PI * 2;
                for (let i = 0; i < 6; i++) {
                    // Vine segment
                    const vine = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.005, 0.005, 0.08, 6),
                        vineMat
                    );
                    vine.position.set(
                        Math.cos(angle) * 0.06 + Math.sin(i) * 0.02,
                        -i * 0.06,
                        Math.sin(angle) * 0.06
                    );
                    vine.rotation.z = 0.3;
                    group.add(vine);
                    // Leaf
                    const leaf = new THREE.Mesh(
                        new THREE.SphereGeometry(0.03, 6, 6),
                        leafMat
                    );
                    leaf.scale.set(1, 0.3, 1.2);
                    leaf.position.set(
                        Math.cos(angle) * 0.08 + Math.sin(i) * 0.03,
                        -i * 0.06 - 0.02,
                        Math.sin(angle) * 0.08
                    );
                    group.add(leaf);
                }
            }
            return group;
        }

        function createWovenBasket() {
            const group = new THREE.Group();
            const basketMat = new THREE.MeshLambertMaterial({ color: 0xd4a76a });
            const basket = new THREE.Mesh(
                new THREE.CylinderGeometry(0.2, 0.15, 0.25, 16),
                basketMat
            );
            basket.position.set(0, 0.125, 0);
            group.add(basket);
            // Weave pattern stripes
            const stripeMat = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
            for (let i = 0; i < 4; i++) {
                const stripe = new THREE.Mesh(
                    new THREE.TorusGeometry(0.17 - i * 0.01, 0.01, 8, 16),
                    stripeMat
                );
                stripe.position.set(0, 0.05 + i * 0.05, 0);
                stripe.rotation.x = Math.PI / 2;
                group.add(stripe);
            }
            return group;
        }

        function createAfricanPottery() {
            const group = new THREE.Group();
            // Rounded pot with narrow neck
            const potMat = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
            const body = new THREE.Mesh(
                new THREE.SphereGeometry(0.15, 12, 12),
                potMat
            );
            body.scale.set(1, 0.8, 1);
            body.position.set(0, 0.12, 0);
            group.add(body);
            const neck = new THREE.Mesh(
                new THREE.CylinderGeometry(0.06, 0.1, 0.1, 12),
                potMat
            );
            neck.position.set(0, 0.27, 0);
            group.add(neck);
            // Geometric pattern
            const patternMat = new THREE.MeshLambertMaterial({ color: 0xf5f0e8 });
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const dot = new THREE.Mesh(
                    new THREE.SphereGeometry(0.015, 6, 6),
                    patternMat
                );
                dot.position.set(
                    Math.cos(angle) * 0.14,
                    0.12,
                    Math.sin(angle) * 0.14
                );
                group.add(dot);
            }
            return group;
        }

        function createWoodSculpture() {
            const group = new THREE.Group();
            const woodMat = new THREE.MeshLambertMaterial({ color: 0x5d4037 });
            // Abstract figure
            const base = new THREE.Mesh(
                new THREE.CylinderGeometry(0.08, 0.1, 0.05, 12),
                woodMat
            );
            base.position.set(0, 0.025, 0);
            group.add(base);
            const body = new THREE.Mesh(
                new THREE.CylinderGeometry(0.04, 0.06, 0.3, 8),
                woodMat
            );
            body.position.set(0, 0.2, 0);
            group.add(body);
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.06, 10, 10),
                woodMat
            );
            head.scale.set(1, 1.3, 0.8);
            head.position.set(0, 0.42, 0);
            group.add(head);
            // Arms
            const armL = new THREE.Mesh(
                new THREE.CylinderGeometry(0.015, 0.015, 0.15, 6),
                woodMat
            );
            armL.position.set(-0.08, 0.25, 0);
            armL.rotation.z = 0.5;
            group.add(armL);
            const armR = new THREE.Mesh(
                new THREE.CylinderGeometry(0.015, 0.015, 0.15, 6),
                woodMat
            );
            armR.position.set(0.08, 0.25, 0);
            armR.rotation.z = -0.5;
            group.add(armR);
            return group;
        }

        // ============ NEW PANAFRICAN LIBRARY FURNITURE ============

        // BANQUETTE-SHELF UNIT - Integrated wall seating with book display
        // Now featuring African textile patterned cushions instead of solid color
        function createBanquetteShelfUnit(length = 2.4, startPatternIndex = null) {
            const group = new THREE.Group();

            // Materials
            const whiteMat = new THREE.MeshLambertMaterial({ color: 0xf5f5f5 }); // White structure

            // Base/platform - white
            const baseHeight = 0.08;
            const base = new THREE.Mesh(
                new THREE.BoxGeometry(length, baseHeight, 0.55),
                whiteMat
            );
            base.position.set(0, baseHeight / 2, 0);
            group.add(base);

            // Create individual seat cushions with different African textile patterns
            const cushionWidth = 0.5; // Each cushion is ~50cm wide
            const numCushions = Math.max(1, Math.floor(length / cushionWidth));
            const actualCushionWidth = (length - 0.04) / numCushions;
            const seatHeight = 0.12;

            // Random starting pattern if not specified
            const patternStart = startPatternIndex !== null ? startPatternIndex : Math.floor(Math.random() * 10);

            for (let i = 0; i < numCushions; i++) {
                // Each cushion gets a different pattern
                const patternIndex = (patternStart + i) % 10;
                const texture = getTextileTexture(patternIndex);
                const cushionMat = new THREE.MeshLambertMaterial({
                    map: texture
                });

                const cushion = new THREE.Mesh(
                    new THREE.BoxGeometry(actualCushionWidth - 0.02, seatHeight, 0.48),
                    cushionMat
                );
                const cushionX = -length / 2 + 0.02 + actualCushionWidth / 2 + i * actualCushionWidth;
                cushion.position.set(cushionX, baseHeight + seatHeight / 2, 0);
                group.add(cushion);
            }

            // Backrest cushions - also with textile patterns
            const backrestHeight = 0.4;
            const numBackCushions = Math.max(1, Math.floor(length / 0.6));
            const actualBackWidth = (length - 0.04) / numBackCushions;

            for (let i = 0; i < numBackCushions; i++) {
                // Offset pattern from seat cushions for variety
                const patternIndex = (patternStart + i + 3) % 10;
                const texture = getTextileTexture(patternIndex);
                const backMat = new THREE.MeshLambertMaterial({
                    map: texture
                });

                const backCushion = new THREE.Mesh(
                    new THREE.BoxGeometry(actualBackWidth - 0.02, backrestHeight, 0.1),
                    backMat
                );
                const backX = -length / 2 + 0.02 + actualBackWidth / 2 + i * actualBackWidth;
                backCushion.position.set(backX, baseHeight + seatHeight + backrestHeight / 2, -0.22);
                group.add(backCushion);
            }

            // Shelf bracket/support - white vertical panel
            const shelfSupportHeight = 0.5;
            const shelfSupport = new THREE.Mesh(
                new THREE.BoxGeometry(length, shelfSupportHeight, 0.03),
                whiteMat
            );
            shelfSupport.position.set(0, baseHeight + seatHeight + backrestHeight + shelfSupportHeight / 2, -0.25);
            group.add(shelfSupport);

            // Main shelf for books - white
            const shelfDepth = 0.25;
            const shelf = new THREE.Mesh(
                new THREE.BoxGeometry(length, 0.025, shelfDepth),
                whiteMat
            );
            const shelfY = baseHeight + seatHeight + backrestHeight + 0.15;
            shelf.position.set(0, shelfY, -0.12);
            group.add(shelf);

            // Add face-out books/magazines on shelf
            const bookColors = [0xe74c3c, 0x3498db, 0x2ecc71, 0xf39c12, 0x9b59b6, 0x1abc9c, 0xe91e63, 0x00bcd4];
            const numBooks = Math.floor(length / 0.22);
            const bookSpacing = (length - 0.2) / numBooks;
            const startX = -length / 2 + 0.15;

            for (let i = 0; i < numBooks; i++) {
                const bookColor = bookColors[i % bookColors.length];
                const bookMat = new THREE.MeshLambertMaterial({ color: bookColor });

                // Book/magazine - face out (thin, tall rectangle)
                const bookWidth = 0.16;
                const bookHeight = 0.22;
                const bookDepth = 0.015;
                const book = new THREE.Mesh(
                    new THREE.BoxGeometry(bookWidth, bookHeight, bookDepth),
                    bookMat
                );
                book.position.set(startX + i * bookSpacing, shelfY + 0.025 + bookHeight / 2, -0.05);
                group.add(book);
            }

            // Small lip at front of shelf to hold books
            const lip = new THREE.Mesh(
                new THREE.BoxGeometry(length, 0.03, 0.02),
                whiteMat
            );
            lip.position.set(0, shelfY + 0.015, 0.01);
            group.add(lip);

            return group;
        }

        // CARDBOARD CUBE STOOL - Cube covered with printed images
        function createCardboardCubeStool(imageType = 'branches') {
            const group = new THREE.Group();

            // Base cardboard color
            const cardboardMat = new THREE.MeshLambertMaterial({ color: 0xc4a76a }); // Tan cardboard

            // Different "printed" patterns based on type
            let topColor, sideColor;
            switch(imageType) {
                case 'branches':
                    topColor = 0xd4c4a4; // Cream with brown branches pattern
                    sideColor = 0x8b7355; // Brown tones
                    break;
                case 'african-pattern':
                    topColor = 0x1a1a1a; // Black with white kente pattern
                    sideColor = 0xf5f5f5; // White geometric
                    break;
                case 'text':
                    topColor = 0xfdd835; // Yellow with black text
                    sideColor = 0x1a1a1a; // Black text side
                    break;
                case 'benin':
                    topColor = 0x8b4513; // Bronze color for Benin heads
                    sideColor = 0x654321; // Darker bronze
                    break;
                default:
                    topColor = 0xd4c4a4;
                    sideColor = 0xc4a76a;
            }

            const topMat = new THREE.MeshLambertMaterial({ color: topColor });
            const sideMat = new THREE.MeshLambertMaterial({ color: sideColor });

            // Cube dimensions
            const size = 0.4;

            // Main cube body
            const cube = new THREE.Mesh(
                new THREE.BoxGeometry(size, size, size),
                cardboardMat
            );
            cube.position.set(0, size / 2, 0);
            group.add(cube);

            // Top face with pattern
            const topFace = new THREE.Mesh(
                new THREE.PlaneGeometry(size - 0.01, size - 0.01),
                topMat
            );
            topFace.rotation.x = -Math.PI / 2;
            topFace.position.set(0, size + 0.001, 0);
            group.add(topFace);

            // Front face with pattern
            const frontFace = new THREE.Mesh(
                new THREE.PlaneGeometry(size - 0.01, size - 0.01),
                sideMat
            );
            frontFace.position.set(0, size / 2, size / 2 + 0.001);
            group.add(frontFace);

            // Add subtle edge lines to show cardboard construction
            const edgeMat = new THREE.MeshLambertMaterial({ color: 0x8b7355 });
            const edgeSize = 0.01;

            // Top edges
            const edgeTop1 = new THREE.Mesh(new THREE.BoxGeometry(size, edgeSize, edgeSize), edgeMat);
            edgeTop1.position.set(0, size, size / 2);
            group.add(edgeTop1);

            const edgeTop2 = new THREE.Mesh(new THREE.BoxGeometry(size, edgeSize, edgeSize), edgeMat);
            edgeTop2.position.set(0, size, -size / 2);
            group.add(edgeTop2);

            return group;
        }

        // VINYL RECORD TABLE - Square table with African record label graphic
        function createVinylRecordTable(labelType = 'ngoma') {
            const group = new THREE.Group();

            // White pedestal base
            const whiteMat = new THREE.MeshLambertMaterial({ color: 0xf5f5f5 });

            // Base foot
            const baseWidth = 0.35;
            const base = new THREE.Mesh(
                new THREE.BoxGeometry(baseWidth, 0.04, baseWidth),
                whiteMat
            );
            base.position.set(0, 0.02, 0);
            group.add(base);

            // Pedestal column
            const columnHeight = 0.65;
            const column = new THREE.Mesh(
                new THREE.BoxGeometry(0.08, columnHeight, 0.08),
                whiteMat
            );
            column.position.set(0, 0.04 + columnHeight / 2, 0);
            group.add(column);

            // Tabletop - square
            const topSize = 0.6;
            const topThickness = 0.03;
            const tabletop = new THREE.Mesh(
                new THREE.BoxGeometry(topSize, topThickness, topSize),
                whiteMat
            );
            tabletop.position.set(0, 0.04 + columnHeight + topThickness / 2, 0);
            group.add(tabletop);

            // Vinyl record graphic on top
            // Different colors based on label type
            let labelColor, innerColor;
            switch(labelType) {
                case 'ngoma':
                    labelColor = 0xc41e3a; // Red Ngoma label
                    innerColor = 0x1a1a1a;
                    break;
                case 'bantou':
                    labelColor = 0x1a3a5c; // Blue Ban Tou label
                    innerColor = 0xf5f5f5;
                    break;
                case 'african-jazz':
                    labelColor = 0xfdd835; // Yellow
                    innerColor = 0x1a1a1a;
                    break;
                case 'pathe':
                    labelColor = 0x2e7d32; // Green
                    innerColor = 0xf5f5f5;
                    break;
                default:
                    labelColor = 0x1a1a1a;
                    innerColor = 0xc41e3a;
            }

            const recordMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a }); // Black vinyl
            const labelMat = new THREE.MeshLambertMaterial({ color: labelColor });
            const innerMat = new THREE.MeshLambertMaterial({ color: innerColor });

            // Record disc
            const recordRadius = 0.25;
            const record = new THREE.Mesh(
                new THREE.CylinderGeometry(recordRadius, recordRadius, 0.005, 32),
                recordMat
            );
            record.position.set(0, 0.04 + columnHeight + topThickness + 0.003, 0);
            group.add(record);

            // Label circle in center
            const labelRadius = 0.1;
            const label = new THREE.Mesh(
                new THREE.CylinderGeometry(labelRadius, labelRadius, 0.006, 32),
                labelMat
            );
            label.position.set(0, 0.04 + columnHeight + topThickness + 0.005, 0);
            group.add(label);

            // Inner hole
            const holeRadius = 0.015;
            const hole = new THREE.Mesh(
                new THREE.CylinderGeometry(holeRadius, holeRadius, 0.008, 16),
                innerMat
            );
            hole.position.set(0, 0.04 + columnHeight + topThickness + 0.006, 0);
            group.add(hole);

            // Grooves on record (subtle rings)
            for (let r = 0.12; r < recordRadius; r += 0.025) {
                const groove = new THREE.Mesh(
                    new THREE.TorusGeometry(r, 0.001, 4, 32),
                    new THREE.MeshLambertMaterial({ color: 0x2a2a2a })
                );
                groove.rotation.x = Math.PI / 2;
                groove.position.set(0, 0.04 + columnHeight + topThickness + 0.006, 0);
                group.add(groove);
            }

            return group;
        }

        // AFRICAN PRINT FABRIC POUF - Soft cube with colorful pattern
        function createAfricanPrintPouf(patternType = 'leopard') {
            const group = new THREE.Group();

            let color1, color2;
            switch(patternType) {
                case 'leopard':
                    color1 = 0xd4a76a; // Tan
                    color2 = 0x4a3728; // Brown spots
                    break;
                case 'wax-blue':
                    color1 = 0x1a3a5c; // Deep blue
                    color2 = 0xfdd835; // Yellow accents
                    break;
                case 'wax-pink':
                    color1 = 0xc2185b; // Magenta
                    color2 = 0xf5f5f5; // White
                    break;
                case 'kente':
                    color1 = 0xfdd835; // Yellow
                    color2 = 0x2e7d32; // Green
                    break;
                case 'mudcloth':
                    color1 = 0xf5f0e8; // Cream
                    color2 = 0x1a1a1a; // Black
                    break;
                default:
                    color1 = 0xe91e63;
                    color2 = 0xfdd835;
            }

            const mat1 = new THREE.MeshLambertMaterial({ color: color1 });
            const mat2 = new THREE.MeshLambertMaterial({ color: color2 });

            // Soft cube shape - slightly rounded edges
            const size = 0.4;
            const height = 0.38;

            // Main body
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(size, height, size),
                mat1
            );
            body.position.set(0, height / 2, 0);
            group.add(body);

            // Top cushion (slightly domed)
            const top = new THREE.Mesh(
                new THREE.BoxGeometry(size - 0.02, 0.04, size - 0.02),
                mat1
            );
            top.position.set(0, height + 0.02, 0);
            group.add(top);

            // Pattern stripes/accents
            const stripeWidth = 0.05;
            for (let i = -1; i <= 1; i += 2) {
                const stripe = new THREE.Mesh(
                    new THREE.BoxGeometry(stripeWidth, height + 0.01, size + 0.01),
                    mat2
                );
                stripe.position.set(i * (size / 3), height / 2, 0);
                group.add(stripe);
            }

            return group;
        }

        // BENIN BRONZE HEAD SCULPTURE
        function createBeninHead() {
            const group = new THREE.Group();

            const bronzeMat = new THREE.MeshLambertMaterial({ color: 0x8b4513 }); // Bronze color
            const darkBronzeMat = new THREE.MeshLambertMaterial({ color: 0x654321 });

            // Base pedestal
            const baseSize = 0.15;
            const base = new THREE.Mesh(
                new THREE.BoxGeometry(baseSize, 0.05, baseSize),
                darkBronzeMat
            );
            base.position.set(0, 0.025, 0);
            group.add(base);

            // Neck/collar
            const neck = new THREE.Mesh(
                new THREE.CylinderGeometry(0.06, 0.07, 0.1, 12),
                bronzeMat
            );
            neck.position.set(0, 0.1, 0);
            group.add(neck);

            // Head - elongated oval
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.08, 16, 16),
                bronzeMat
            );
            head.scale.set(0.85, 1.2, 0.9);
            head.position.set(0, 0.24, 0);
            group.add(head);

            // Crown/headdress
            const crown = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.08, 0.08, 12),
                darkBronzeMat
            );
            crown.position.set(0, 0.35, 0);
            group.add(crown);

            // Crown top ornament
            const ornament = new THREE.Mesh(
                new THREE.SphereGeometry(0.025, 8, 8),
                bronzeMat
            );
            ornament.position.set(0, 0.41, 0);
            group.add(ornament);

            // Eyes (indented)
            const eyeMat = new THREE.MeshLambertMaterial({ color: 0x3a2a1a });
            [-0.025, 0.025].forEach(x => {
                const eye = new THREE.Mesh(
                    new THREE.SphereGeometry(0.012, 8, 8),
                    eyeMat
                );
                eye.position.set(x, 0.26, 0.065);
                group.add(eye);
            });

            // Nose
            const nose = new THREE.Mesh(
                new THREE.BoxGeometry(0.015, 0.03, 0.02),
                bronzeMat
            );
            nose.position.set(0, 0.23, 0.07);
            group.add(nose);

            // Collar rings
            for (let y = 0.06; y < 0.14; y += 0.015) {
                const ring = new THREE.Mesh(
                    new THREE.TorusGeometry(0.065, 0.004, 6, 24),
                    darkBronzeMat
                );
                ring.rotation.x = Math.PI / 2;
                ring.position.set(0, y, 0);
                group.add(ring);
            }

            return group;
        }

        // ============ MOUSE INTERACTION FOR DECORATOR ============
        let isMouseDraggingItem = false;
        let mouseDownTime = 0;
        let mouseDownPos = { x: 0, y: 0 };

        // Mousedown - start potential drag or selection
        container.addEventListener('mousedown', function(event) {
            if (!decoratorMode) return;
            if (event.button !== 0) return; // Left click only

            mouseDownTime = Date.now();
            mouseDownPos = { x: event.clientX, y: event.clientY };

            const rect = container.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Check if clicking on existing placed item
            const itemIntersects = raycaster.intersectObjects(placedItems, true);
            if (itemIntersects.length > 0) {
                let obj = itemIntersects[0].object;
                while (obj.parent && !obj.userData.isPlacedItem) obj = obj.parent;
                if (obj.userData.isPlacedItem) {
                    selectedPlacedItem = obj;
                    selectedFurnitureType = null;
                    document.querySelectorAll('.item-card').forEach(c => c.classList.remove('selected'));
                    updateSelectedInfo();
                    isMouseDraggingItem = true;
                    isCameraOrbitBlocked = true; // BLOCK camera orbit while dragging furniture
                    container.style.cursor = 'grabbing';
                    event.preventDefault();
                    event.stopPropagation();
                    return;
                }
            }
        });

        // Mousemove - drag selected item (STRICT: only moves within room bounds)
        let mouseDragLastValidPos = null;
        container.addEventListener('mousemove', function(event) {
            if (!decoratorMode || !isMouseDraggingItem || !selectedPlacedItem) return;

            const rect = container.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const floorPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const intersectPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(floorPlane, intersectPoint);

            if (intersectPoint) {
                intersectPoint.y = 0;
                const constrained = constrainToRoom(intersectPoint);
                if (constrained) {
                    // VALID position - move item
                    selectedPlacedItem.position.x = constrained.x;
                    selectedPlacedItem.position.z = constrained.z;
                    if (!selectedPlacedItem.userData.isWallArt) {
                        selectedPlacedItem.position.y = 0;
                    }
                    mouseDragLastValidPos = selectedPlacedItem.position.clone();
                }
                // If constrained returns null, item stays at last valid position
            }
        });

        // Mouseup - end drag or click to place new item
        container.addEventListener('mouseup', function(event) {
            const wasDragging = isMouseDraggingItem;
            const clickDuration = Date.now() - mouseDownTime;
            const moveDistance = Math.sqrt(
                Math.pow(event.clientX - mouseDownPos.x, 2) +
                Math.pow(event.clientY - mouseDownPos.y, 2)
            );

            isMouseDraggingItem = false;
            isCameraOrbitBlocked = false; // UNBLOCK camera orbit
            container.style.cursor = '';

            // If we were dragging an item, don't place a new one
            if (wasDragging) return;

            // Short click with minimal movement = place new item
            if (clickDuration < 300 && moveDistance < 10 && selectedFurnitureType) {
                const rect = container.getBoundingClientRect();
                const screenX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                const screenY = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                placeItemAtScreenPos(selectedFurnitureType, screenX, screenY);
            }
        });

        // Click on empty space to deselect
        container.addEventListener('click', function(event) {
            if (!decoratorMode) return;

            const rect = container.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // If click didn't hit any placed item and we have no furniture selected, deselect
            const itemIntersects = raycaster.intersectObjects(placedItems, true);
            if (itemIntersects.length === 0 && !selectedFurnitureType) {
                selectedPlacedItem = null;
                updateSelectedInfo();
            }
        });

        // Initialize canvas drag-drop on load
        setupCanvasDragDrop();

        // ============================================================
        // STRICT ROOM BOUNDARY RULES - NO EXCEPTIONS
        // Items can ONLY be placed INSIDE rooms. Period.
        // ============================================================
        function constrainToRoom(pos, assetId = null) {
            const x = pos.x;
            const z = pos.z;

            // STRICT Three Star boundaries (west/left room)
            const threeStarBounds = ROOM_GEOMETRY['THREE_STAR'].bounds;
            const threeStarDoor = ROOM_GEOMETRY['THREE_STAR'].doorZone;
            const WALL_MARGIN = 0.3; // Keep items 30cm from walls
            const threeStarLeft = threeStarBounds.minX + WALL_MARGIN;
            const threeStarRight = threeStarBounds.maxX - WALL_MARGIN;
            const threeStarFront = threeStarBounds.maxZ - WALL_MARGIN;
            const threeStarBack = threeStarBounds.minZ + WALL_MARGIN;

            // STRICT Special Special boundaries (east/right room)
            const specialSpecialBounds = ROOM_GEOMETRY['SPECIAL_SPECIAL'].bounds;
            const specialSpecialDoor = ROOM_GEOMETRY['SPECIAL_SPECIAL'].doorZone;
            const specialSpecialLeft = specialSpecialBounds.minX + WALL_MARGIN;
            const specialSpecialRight = specialSpecialBounds.maxX - WALL_MARGIN;
            const specialSpecialFront = specialSpecialBounds.maxZ - WALL_MARGIN;
            const specialSpecialBack = specialSpecialBounds.minZ + WALL_MARGIN;

            // STRICT CHECK: Is position INSIDE Three Star?
            const inThreeStar = x >= threeStarLeft && x <= threeStarRight &&
                           z >= threeStarBack && z <= threeStarFront;

            // STRICT CHECK: Is position INSIDE Special Special?
            const inSpecialSpecial = x >= specialSpecialLeft && x <= specialSpecialRight &&
                           z >= specialSpecialBack && z <= specialSpecialFront;

            // RULE: If not inside ANY room, REJECT placement entirely
            if (!inThreeStar && !inSpecialSpecial) {
                console.warn('REJECTED: Placement outside room boundaries at', x.toFixed(2), z.toFixed(2));
                return null; // REJECT - cannot place outside rooms
            }

            // Helper: Check if position is in door zone (blocked area)
            function isInDoorZone(px, pz, doorZone) {
                return px >= doorZone.minX - 0.2 && px <= doorZone.maxX + 0.2 &&
                       pz >= doorZone.minZ && pz <= doorZone.maxZ + 0.3;
            }

            // If in Three Star
            if (inThreeStar) {
                if (isInDoorZone(x, z, threeStarDoor)) {
                    const safeZ = threeStarDoor.maxZ + 0.4;
                    if (safeZ <= threeStarFront) {
                        return new THREE.Vector3(x, 0, safeZ);
                    }
                    console.warn('REJECTED: Too close to Three Star door');
                    return null;
                }
                return new THREE.Vector3(x, 0, z);
            }

            // If in Special Special
            if (inSpecialSpecial) {
                if (isInDoorZone(x, z, specialSpecialDoor)) {
                    const safeZ = specialSpecialDoor.maxZ + 0.4;
                    if (safeZ <= specialSpecialFront) {
                        return new THREE.Vector3(x, 0, safeZ);
                    }
                    console.warn('REJECTED: Too close to Special Special door');
                    return null;
                }
                return new THREE.Vector3(x, 0, z);
            }

            // Should never reach here, but safety fallback
            return null;
        }

        // Check if a new placement would be valid (no collisions)
        function wouldCollideWithExisting(newPosition, newAssetId, excludeItem = null) {
            const asset = ASSET_WHITELIST[newAssetId];
            if (!asset) return false; // Unknown asset, allow placement

            // Create temporary placement to check
            const tempPlacement = {
                assetId: newAssetId,
                roomId: getObjectRoom({ position: newPosition }) || 'SPECIAL_SPECIAL',
                x: newPosition.x,
                z: newPosition.z,
                rotation: 0
            };

            const newAABB = getAABBWithClearance(tempPlacement);
            if (!newAABB) return false;

            // Check against all existing placed items
            for (const item of placedItems) {
                if (item === excludeItem) continue;

                const itemAssetId = item.userData.assetId || 'unknown';
                const itemPlacement = objectToPlacement(item, itemAssetId, getObjectRoom(item) || 'SPECIAL_SPECIAL');
                const existingAABB = getAABBWithClearance(itemPlacement);

                if (existingAABB && aabbsOverlap(newAABB, existingAABB)) {
                    console.log(`Collision detected: ${newAssetId} would collide with ${itemAssetId}`);
                    return true;
                }
            }

            return false;
        }

        // Visual feedback for invalid placement
        let invalidPlacementTimeout = null;
        function showInvalidPlacementFeedback(position) {
            // Create a red indicator at the position
            const indicator = new THREE.Mesh(
                new THREE.RingGeometry(0.3, 0.5, 16),
                new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.5 })
            );
            indicator.rotation.x = -Math.PI / 2;
            indicator.position.set(position.x, 0.01, position.z);
            scene.add(indicator);

            // Remove after 1 second
            setTimeout(() => {
                scene.remove(indicator);
            }, 1000);
        }

        window.moveItem = function(dx, dz) {
            if (selectedPlacedItem) {
                const newPos = selectedPlacedItem.position.clone();
                newPos.x += dx;
                newPos.z += dz;
                const constrained = constrainToRoom(newPos);
                if (constrained) {
                    selectedPlacedItem.position.x = constrained.x;
                    selectedPlacedItem.position.z = constrained.z;
                    selectedPlacedItem.position.y = 0; // Snap to floor
                }
            }
        };

        window.rotateItem = function(degrees) {
            if (selectedPlacedItem) {
                selectedPlacedItem.rotation.y += degrees * Math.PI / 180;
            }
        };

        window.deleteItem = function() {
            if (selectedPlacedItem) {
                if (transformControls) transformControls.detach();
                scene.remove(selectedPlacedItem);
                placedItems = placedItems.filter(i => i !== selectedPlacedItem);
                selectedPlacedItem = null;
                updateSelectedInfo();
            }
        };

        // Keyboard shortcuts for transform modes (when decorator mode active)
        document.addEventListener('keydown', (e) => {
            if (!decoratorMode || !transformControls) return;

            switch(e.key.toLowerCase()) {
                case 'g': // Grab/translate mode
                case 't':
                    transformControls.setMode('translate');
                    break;
                case 'r': // Rotate mode
                    transformControls.setMode('rotate');
                    break;
                case 'delete':
                case 'backspace':
                    if (selectedPlacedItem) {
                        e.preventDefault();
                        deleteItem();
                    }
                    break;
                case 'escape':
                    deselectAll();
                    break;
            }
        });

        window.saveLayout = async function() {
            const layout = placedItems.map(item => ({
                type: item.userData.itemType,
                position: { x: item.position.x, y: item.position.y, z: item.position.z },
                rotation: { y: item.rotation.y }
            }));

            // Save to localStorage as backup
            localStorage.setItem('panafricanLibraryLayout', JSON.stringify(layout));

            // Also save to Vercel Blob for persistent shared storage
            try {
                const response = await fetch('/api/layout', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(layout)
                });
                const result = await response.json();
                if (result.success) {
                    alert('Layout saved! This layout will be visible to all visitors.');
                } else {
                    alert('Layout saved locally. Cloud sync failed: ' + (result.error || 'Unknown error'));
                }
            } catch (err) {
                console.error('Cloud save error:', err);
                alert('Layout saved locally. Cloud sync unavailable.');
            }
        };

        window.loadLayout = async function() {
            try {
                // First try to load from Vercel Blob (shared layout)
                const response = await fetch('/api/layout');
                const result = await response.json();

                if (result.success && result.layout && result.layout.length > 0) {
                    applyLayout(result.layout);
                    alert('Shared layout loaded from cloud!');
                    return;
                }
            } catch (err) {
                console.error('Cloud load error:', err);
            }

            // Fallback to localStorage
            const saved = localStorage.getItem('panafricanLibraryLayout');
            if (saved) {
                const layout = JSON.parse(saved);
                applyLayout(layout);
                alert('Layout loaded from local storage.');
            } else {
                alert('No saved layout found.');
            }
        };

        function applyLayout(layout) {
            // Clear existing placed items
            placedItems.forEach(item => scene.remove(item));
            placedItems = [];
            // Recreate items
            layout.forEach(data => {
                const item = createFurnitureItem(data.type);
                item.position.set(data.position.x, data.position.y, data.position.z);
                item.rotation.y = data.rotation.y;
                scene.add(item);
                placedItems.push(item);
            });
        }

        // Auto-load shared layout on page load
        async function autoLoadLayout() {
            try {
                const response = await fetch('/api/layout');
                const result = await response.json();

                if (result.success && result.layout && result.layout.length > 0) {
                    applyLayout(result.layout);
                    console.log('Auto-loaded shared layout from cloud');
                }
            } catch (err) {
                // Silently fail - just use empty layout
                console.log('No shared layout available');
            }
        }

        // Call autoLoadLayout after scene is ready
        setTimeout(autoLoadLayout, 1000);

        window.resetLayout = function() {
            if (confirm('Reset to default layout? This will remove all placed items.')) {
                placedItems.forEach(item => scene.remove(item));
                placedItems = [];
                deselectAll();
            }
        };

        window.exportLayout = function() {
            const layout = placedItems.map(item => ({
                type: item.userData.itemType,
                position: { x: item.position.x, y: item.position.y, z: item.position.z },
                rotation: { y: item.rotation.y }
            }));
            const blob = new Blob([JSON.stringify(layout, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'panafrican-library-layout.json';
            a.click();
        };

        // Wall visibility based on camera position
        function updateWallVisibility() {
            if (!hideNearWall) {
                // Show all walls
                Object.values(threeStarRoomWalls).forEach(w => { if (w) w.visible = true; });
                Object.values(specialSpecialRoomWalls).forEach(w => { if (w) w.visible = true; });
                return;
            }

            // Determine which wall is closest to camera
            const camX = camera.position.x;
            const camZ = camera.position.z;

            // Room S202 walls
            // FRONT wall (windows) - hide when camera is in front (positive Z)
            if (threeStarRoomWalls.front) threeStarRoomWalls.front.visible = camZ < THREE_STAR_DEPTH / 4;

            // BACK wall (corridor entry) - hide when camera is behind (negative Z)
            // Also hide entire vestibule (all corridor walls) when hiding back area
            const hideBackArea = camZ < -THREE_STAR_DEPTH / 4;
            if (threeStarRoomWalls.back) threeStarRoomWalls.back.visible = !hideBackArea;
            if (threeStarRoomWalls.vestibuleGroup) threeStarRoomWalls.vestibuleGroup.visible = !hideBackArea;

            // LEFT wall (Pan-African Library door) - hide when camera is to the left
            if (threeStarRoomWalls.left) threeStarRoomWalls.left.visible = camX > THREE_STAR_X - THREE_STAR_WIDTH / 2;

            // RIGHT wall (solid shared wall with S203) - hide when camera is to the right
            if (threeStarRoomWalls.right) threeStarRoomWalls.right.visible = camX < THREE_STAR_X + THREE_STAR_WIDTH / 2;

            // Room S203 walls
            // FRONT wall (windows) - hide when camera is in front
            if (specialSpecialRoomWalls.front) specialSpecialRoomWalls.front.visible = camZ < SPECIAL_SPECIAL_DEPTH / 4;

            // BACK wall (corridor entry + poster wall) - hide when camera is behind
            if (specialSpecialRoomWalls.back) specialSpecialRoomWalls.back.visible = camZ > -SPECIAL_SPECIAL_DEPTH / 4;

            // LEFT wall (SHARED MIDDLE WALL with S202) - ALWAYS VISIBLE
            // This is the dividing wall between the two rooms, never hide it
            if (specialSpecialRoomWalls.left) specialSpecialRoomWalls.left.visible = true;

            // RIGHT wall (solid exterior) - hide when camera is to the right
            if (specialSpecialRoomWalls.right) specialSpecialRoomWalls.right.visible = camX < SPECIAL_SPECIAL_X + SPECIAL_SPECIAL_WIDTH / 2;
        }

        // Auto ceiling visibility based on camera height
        function updateCeilingVisibility() {
            const camY = camera.position.y;
            const isAbove = camY > CEILING_HEIGHT + 1;

            if (showCeiling) {
                // Auto-hide ceiling when viewing from above
                scene.traverse((obj) => {
                    if (obj.userData.isCeiling) {
                        obj.visible = !isAbove;
                    }
                });
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            currentRotationX += (targetRotationX - currentRotationX) * 0.05;
            currentRotationY += (targetRotationY - currentRotationY) * 0.05;

            if (keys['w']) cameraTarget.z -= 0.1;
            if (keys['s']) cameraTarget.z += 0.1;
            if (keys['a']) cameraTarget.x -= 0.1;
            if (keys['d']) cameraTarget.x += 0.1;

            camera.position.x = cameraTarget.x + Math.sin(currentRotationX) * Math.cos(currentRotationY) * cameraDistance;
            camera.position.y = cameraTarget.y + Math.sin(currentRotationY) * cameraDistance;
            camera.position.z = cameraTarget.z + Math.cos(currentRotationX) * Math.cos(currentRotationY) * cameraDistance;
            camera.lookAt(cameraTarget);

            updateWallVisibility();
            updateCeilingVisibility();

            renderer.render(scene, camera);
        }
        animate();

        // Initialize transform controls for visual editing gizmos
        initTransformControls();

        // Initialize drag-drop systems
        setupCanvasDragDrop();
        setupLibraryDragDrop();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ========== ADMIN SYSTEM ==========
        let adminUser = null;
        let adminToken = null;
        let selectedRenderStyle = 'photorealistic';

        // Check for saved admin session
        const savedAdmin = localStorage.getItem('panafricanAdmin');
        if (savedAdmin) {
            try {
                const data = JSON.parse(savedAdmin);
                adminUser = data.email;
                adminToken = data.token;
                // Hide login button, show profile badge
                document.getElementById('admin-btn').style.display = 'none';
                document.getElementById('admin-profile').style.display = 'flex';
                document.getElementById('admin-name').textContent = 'üë§ ' + (data.name || 'Admin');
            } catch(e) {}
        }

        window.toggleAdminLogin = function() {
            if (adminUser) {
                toggleAdminPanel();
            } else {
                document.getElementById('login-modal').classList.add('visible');
                document.getElementById('login-email').focus();
            }
        };

        window.closeLoginModal = function() {
            document.getElementById('login-modal').classList.remove('visible');
            document.getElementById('login-email').value = '';
            document.getElementById('login-error').textContent = '';
        };

        window.attemptLogin = async function() {
            const email = document.getElementById('login-email').value.trim();
            if (!email) {
                document.getElementById('login-error').textContent = 'Please enter your email';
                return;
            }

            try {
                const response = await fetch('/api/auth', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ email })
                });
                const result = await response.json();

                if (result.success && result.isAdmin) {
                    adminUser = result.email;
                    adminToken = result.token;
                    localStorage.setItem('panafricanAdmin', JSON.stringify({
                        email: result.email,
                        token: result.token,
                        name: result.name
                    }));
                    // Hide login button, show profile badge
                    document.getElementById('admin-btn').style.display = 'none';
                    document.getElementById('admin-profile').style.display = 'flex';
                    document.getElementById('admin-name').textContent = 'üë§ ' + result.name;
                    document.getElementById('admin-user-name').textContent = 'Logged in as: ' + result.name;
                    closeLoginModal();
                    toggleAdminPanel();
                    loadAdminConfigs();
                } else {
                    document.getElementById('login-error').textContent = 'Not an authorized admin email';
                }
            } catch (err) {
                document.getElementById('login-error').textContent = 'Login failed: ' + err.message;
            }
        };

        window.logoutAdmin = function() {
            adminUser = null;
            adminToken = null;
            localStorage.removeItem('panafricanAdmin');
            // Show login button, hide profile badge
            document.getElementById('admin-btn').style.display = 'block';
            document.getElementById('admin-profile').style.display = 'none';
            document.getElementById('admin-panel').classList.remove('open');
        };

        window.toggleAdminPanel = function() {
            if (!adminUser) {
                toggleAdminLogin();
                return;
            }
            const panel = document.getElementById('admin-panel');
            panel.classList.toggle('open');
            if (panel.classList.contains('open')) {
                loadAdminConfigs();
                updateCameraPositionDisplay();
            }
        };

        window.switchAdminTab = function(tab) {
            document.querySelectorAll('.admin-tab').forEach(t => t.classList.remove('active'));
            event.currentTarget.classList.add('active');
            document.querySelectorAll('.admin-content').forEach(c => c.style.display = 'none');
            document.getElementById('admin-tab-' + tab).style.display = 'block';
        };

        function updateCameraPositionDisplay() {
            const display = document.getElementById('camera-position-display');
            if (display) {
                display.innerHTML = `Position: (${camera.position.x.toFixed(2)}, ${camera.position.y.toFixed(2)}, ${camera.position.z.toFixed(2)})<br>Target: (${cameraTarget.x.toFixed(2)}, ${cameraTarget.y.toFixed(2)}, ${cameraTarget.z.toFixed(2)})<br>Distance: ${cameraDistance.toFixed(2)} | RotX: ${currentRotationX.toFixed(2)} | RotY: ${currentRotationY.toFixed(2)}`;
            }
        }

        setInterval(() => {
            if (document.getElementById('admin-panel').classList.contains('open')) {
                updateCameraPositionDisplay();
            }
        }, 500);

        async function loadAdminConfigs() {
            try {
                const layoutRes = await fetch('/api/config?type=layout');
                const layoutData = await layoutRes.json();
                renderConfigList('saved-layouts-list', layoutData.configs || [], 'layout');
            } catch (e) {
                document.getElementById('saved-layouts-list').innerHTML = '<div style="color:#666;font-size:12px;padding:10px;">Failed to load</div>';
            }
            try {
                const viewRes = await fetch('/api/config?type=view');
                const viewData = await viewRes.json();
                renderConfigList('saved-views-list', viewData.configs || [], 'view');
            } catch (e) {
                document.getElementById('saved-views-list').innerHTML = '<div style="color:#666;font-size:12px;padding:10px;">Failed to load</div>';
            }
            try {
                const moodRes = await fetch('/api/config?type=mood');
                const moodData = await moodRes.json();
                renderConfigList('saved-mood-list', moodData.configs || [], 'mood');
            } catch (e) {
                document.getElementById('saved-mood-list').innerHTML = '<div style="color:#666;font-size:12px;padding:10px;">Failed to load</div>';
            }
        }

        function renderConfigList(containerId, configs, type) {
            const container = document.getElementById(containerId);
            if (configs.length === 0) {
                container.innerHTML = '<div style="color:#666;font-size:12px;padding:10px;">No saved ' + type + 's yet</div>';
                return;
            }
            container.innerHTML = configs.map(cfg => `
                <div class="saved-config-item">
                    <div>
                        <div class="saved-config-name">${cfg.name}</div>
                        <div class="saved-config-meta">By ${cfg.author} ‚Ä¢ ${new Date(cfg.createdAt).toLocaleDateString()}</div>
                    </div>
                    <div class="saved-config-actions">
                        <button class="saved-config-btn" onclick="loadConfig('${type}', '${cfg.name}')">Load</button>
                        <button class="saved-config-btn danger" onclick="deleteConfig('${type}', '${cfg.name}')">‚úï</button>
                    </div>
                </div>
            `).join('');
        }

        // ============ LOCAL STORAGE BASED CONFIG MANAGEMENT ============
        // Fallback to localStorage when API is unavailable

        let savedLayouts = JSON.parse(localStorage.getItem('savedLayouts')) || [];
        let savedViews = JSON.parse(localStorage.getItem('savedViews')) || [];
        let draggedConfigIndex = null;
        let draggedConfigType = null;

        function saveLayoutsToStorage() {
            localStorage.setItem('savedLayouts', JSON.stringify(savedLayouts));
        }

        function saveViewsToStorage() {
            localStorage.setItem('savedViews', JSON.stringify(savedViews));
        }

        window.saveAdminLayout = function() {
            const name = document.getElementById('layout-name').value.trim();
            const description = document.getElementById('layout-description')?.value.trim() || '';
            if (!name) { alert('Please enter a layout name'); return; }

            const layout = placedItems.map(item => ({
                type: item.userData.itemType,
                position: { x: item.position.x, y: item.position.y, z: item.position.z },
                rotation: { y: item.rotation.y }
            }));

            const layoutEntry = {
                id: Date.now(),
                name: name,
                description: description,
                data: layout,
                author: adminUser || 'Admin',
                createdAt: new Date().toISOString()
            };

            savedLayouts.push(layoutEntry);
            saveLayoutsToStorage();

            document.getElementById('layout-name').value = '';
            if (document.getElementById('layout-description')) {
                document.getElementById('layout-description').value = '';
            }

            renderLayoutsList();
            alert('Layout saved!');
        };

        window.saveAdminView = function() {
            const name = document.getElementById('view-name').value.trim();
            const description = document.getElementById('view-description').value.trim();
            if (!name) { alert('Please enter a view name'); return; }

            const viewEntry = {
                id: Date.now(),
                name: name,
                description: description,
                data: {
                    position: { x: camera.position.x, y: camera.position.y, z: camera.position.z },
                    target: { x: cameraTarget.x, y: cameraTarget.y, z: cameraTarget.z },
                    distance: cameraDistance,
                    rotationX: currentRotationX,
                    rotationY: currentRotationY
                },
                author: adminUser || 'Admin',
                createdAt: new Date().toISOString()
            };

            savedViews.push(viewEntry);
            saveViewsToStorage();

            document.getElementById('view-name').value = '';
            document.getElementById('view-description').value = '';

            renderViewsList();
            alert('View saved!');
        };

        window.loadLayout = function(index) {
            const layout = savedLayouts[index];
            if (layout && layout.data) {
                applyLayout(layout.data);
                alert(`Layout "${layout.name}" loaded!`);
            }
        };

        window.loadView = function(index) {
            const view = savedViews[index];
            if (view && view.data) {
                const data = view.data;
                cameraTarget.set(data.target.x, data.target.y, data.target.z);
                cameraDistance = data.distance;
                targetRotationX = data.rotationX;
                targetRotationY = data.rotationY;
                currentRotationX = data.rotationX;
                currentRotationY = data.rotationY;
                alert(`View "${view.name}" applied!`);
            }
        };

        window.deleteLayout = function(index, event) {
            event.stopPropagation();
            const layout = savedLayouts[index];
            if (confirm(`Delete layout "${layout.name}"?`)) {
                savedLayouts.splice(index, 1);
                saveLayoutsToStorage();
                renderLayoutsList();
            }
        };

        window.deleteView = function(index, event) {
            event.stopPropagation();
            const view = savedViews[index];
            if (confirm(`Delete view "${view.name}"?`)) {
                savedViews.splice(index, 1);
                saveViewsToStorage();
                renderViewsList();
            }
        };

        window.editLayout = function(index, event) {
            event.stopPropagation();
            const layout = savedLayouts[index];
            const newName = prompt('Edit layout name:', layout.name);
            if (newName && newName.trim()) {
                const newDesc = prompt('Edit description:', layout.description || '');
                savedLayouts[index].name = newName.trim();
                savedLayouts[index].description = newDesc || '';
                saveLayoutsToStorage();
                renderLayoutsList();
            }
        };

        window.editView = function(index, event) {
            event.stopPropagation();
            const view = savedViews[index];
            const newName = prompt('Edit view name:', view.name);
            if (newName && newName.trim()) {
                const newDesc = prompt('Edit description:', view.description || '');
                savedViews[index].name = newName.trim();
                savedViews[index].description = newDesc || '';
                saveViewsToStorage();
                renderViewsList();
            }
        };

        window.updateViewPosition = function(index, event) {
            event.stopPropagation();
            const view = savedViews[index];
            if (confirm(`Update "${view.name}" with current camera position?`)) {
                savedViews[index].data = {
                    position: { x: camera.position.x, y: camera.position.y, z: camera.position.z },
                    target: { x: cameraTarget.x, y: cameraTarget.y, z: cameraTarget.z },
                    distance: cameraDistance,
                    rotationX: currentRotationX,
                    rotationY: currentRotationY
                };
                saveViewsToStorage();
                renderViewsList();
                alert('View position updated!');
            }
        };

        function renderLayoutsList() {
            const container = document.getElementById('saved-layouts-list');
            const countEl = document.getElementById('layouts-count');
            if (countEl) countEl.textContent = `(${savedLayouts.length})`;

            if (savedLayouts.length === 0) {
                container.innerHTML = '<div style="color: #666; font-size: 12px; padding: 10px;">No layouts saved yet</div>';
                return;
            }

            container.innerHTML = savedLayouts.map((layout, idx) => `
                <div class="saved-config-item" draggable="true" data-index="${idx}" data-type="layout"
                     onclick="loadLayout(${idx})">
                    <div class="saved-config-info">
                        <div class="saved-config-name">${layout.name}</div>
                        <div class="saved-config-meta">${layout.description || ''} ‚Ä¢ ${new Date(layout.createdAt).toLocaleDateString()}</div>
                    </div>
                    <div class="saved-config-actions">
                        <button class="saved-config-btn move" title="Drag to reorder">‚ãÆ‚ãÆ</button>
                        <button class="saved-config-btn edit" onclick="editLayout(${idx}, event)" title="Edit">‚úèÔ∏è</button>
                        <button class="saved-config-btn danger" onclick="deleteLayout(${idx}, event)" title="Delete">‚úï</button>
                    </div>
                </div>
            `).join('');

            setupConfigDragDrop('layout');
        }

        function renderViewsList() {
            const container = document.getElementById('saved-views-list');
            const countEl = document.getElementById('views-count');
            if (countEl) countEl.textContent = `(${savedViews.length})`;

            if (savedViews.length === 0) {
                container.innerHTML = '<div style="color: #666; font-size: 12px; padding: 10px;">No views saved yet</div>';
                return;
            }

            container.innerHTML = savedViews.map((view, idx) => `
                <div class="saved-config-item" draggable="true" data-index="${idx}" data-type="view"
                     onclick="loadView(${idx})">
                    <div class="saved-config-info">
                        <div class="saved-config-name">${view.name}</div>
                        <div class="saved-config-meta">${view.description || ''} ‚Ä¢ ${new Date(view.createdAt).toLocaleDateString()}</div>
                    </div>
                    <div class="saved-config-actions">
                        <button class="saved-config-btn move" title="Drag to reorder">‚ãÆ‚ãÆ</button>
                        <button class="saved-config-btn" onclick="updateViewPosition(${idx}, event)" title="Update to current">üìç</button>
                        <button class="saved-config-btn edit" onclick="editView(${idx}, event)" title="Edit">‚úèÔ∏è</button>
                        <button class="saved-config-btn danger" onclick="deleteView(${idx}, event)" title="Delete">‚úï</button>
                    </div>
                </div>
            `).join('');

            setupConfigDragDrop('view');
        }

        function setupConfigDragDrop(type) {
            const container = document.getElementById(type === 'layout' ? 'saved-layouts-list' : 'saved-views-list');
            const items = container.querySelectorAll('.saved-config-item');

            items.forEach(item => {
                item.addEventListener('dragstart', (e) => {
                    draggedConfigIndex = parseInt(item.dataset.index);
                    draggedConfigType = type;
                    item.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                });

                item.addEventListener('dragend', () => {
                    item.classList.remove('dragging');
                    draggedConfigIndex = null;
                    draggedConfigType = null;
                    items.forEach(i => i.classList.remove('drag-over'));
                });

                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    items.forEach(i => i.classList.remove('drag-over'));
                    item.classList.add('drag-over');
                });

                item.addEventListener('drop', (e) => {
                    e.preventDefault();
                    const targetIndex = parseInt(item.dataset.index);
                    if (draggedConfigIndex !== null && draggedConfigIndex !== targetIndex && draggedConfigType === type) {
                        reorderConfig(type, draggedConfigIndex, targetIndex);
                    }
                    items.forEach(i => i.classList.remove('drag-over'));
                });
            });
        }

        function reorderConfig(type, fromIndex, toIndex) {
            const arr = type === 'layout' ? savedLayouts : savedViews;
            const item = arr.splice(fromIndex, 1)[0];
            arr.splice(toIndex, 0, item);

            if (type === 'layout') {
                saveLayoutsToStorage();
                renderLayoutsList();
            } else {
                saveViewsToStorage();
                renderViewsList();
            }
        }

        window.exportLayoutFile = function() {
            const layout = placedItems.map(item => ({
                type: item.userData.itemType,
                position: { x: item.position.x, y: item.position.y, z: item.position.z },
                rotation: { y: item.rotation.y }
            }));
            const blob = new Blob([JSON.stringify(layout, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'panafrican-library-layout-' + new Date().toISOString().slice(0,10) + '.json';
            a.click();
        };

        window.importLayoutFile = function() {
            document.getElementById('import-layout-input').click();
        };

        window.handleLayoutImport = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    if (Array.isArray(data)) {
                        const name = prompt('Name for imported layout:', file.name.replace('.json', ''));
                        if (name) {
                            savedLayouts.push({
                                id: Date.now(),
                                name: name,
                                description: 'Imported from file',
                                data: data,
                                author: adminUser || 'Admin',
                                createdAt: new Date().toISOString()
                            });
                            saveLayoutsToStorage();
                            renderLayoutsList();
                            alert('Layout imported successfully!');
                        }
                    } else {
                        alert('Invalid layout file format');
                    }
                } catch (err) {
                    alert('Failed to parse layout file: ' + err.message);
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Reset file input
        };

        window.updateCameraDisplay = function() {
            const display = document.getElementById('camera-position-display');
            if (display) {
                display.innerHTML = `
                    Position: (${camera.position.x.toFixed(2)}, ${camera.position.y.toFixed(2)}, ${camera.position.z.toFixed(2)})<br>
                    Target: (${cameraTarget.x.toFixed(2)}, ${cameraTarget.y.toFixed(2)}, ${cameraTarget.z.toFixed(2)})<br>
                    Distance: ${cameraDistance.toFixed(2)}<br>
                    RotX: ${currentRotationX.toFixed(3)} | RotY: ${currentRotationY.toFixed(3)}
                `;
            }
        };

        // Initialize lists on admin panel open
        function initAdminLists() {
            renderLayoutsList();
            renderViewsList();
            updateCameraDisplay();
        }

        window.saveMoodEntry = async function() {
            const title = document.getElementById('mood-title').value.trim();
            const imageUrl = document.getElementById('mood-image-url').value.trim();
            const description = document.getElementById('mood-description').value.trim();
            const category = document.getElementById('mood-category').value;
            if (!title || !imageUrl) { alert('Please enter a title and image URL'); return; }

            // Add to moodboard images array
            moodboardImages.push({
                src: imageUrl,
                title: title + (description ? ' - ' + description : ''),
                category: category
            });
            saveMoodboardImages();

            document.getElementById('mood-title').value = '';
            document.getElementById('mood-image-url').value = '';
            document.getElementById('mood-description').value = '';

            alert('Added to mood board!');
        };

        // ========== AI RENDER SYSTEM ==========
        let capturedImageData = null;

        window.openRenderModal = function() {
            document.getElementById('render-modal').classList.add('visible');
            captureForRender();
        };

        window.closeRenderModal = function() {
            document.getElementById('render-modal').classList.remove('visible');
            capturedImageData = null;
        };

        window.selectRenderStyle = function(style, btn) {
            selectedRenderStyle = style;
            document.querySelectorAll('.render-style-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
        };

        function captureForRender() {
            renderer.render(scene, camera);
            const dataURL = renderer.domElement.toDataURL('image/png');
            capturedImageData = dataURL;
            document.getElementById('render-input-preview').innerHTML = `<img src="${dataURL}" alt="3D Scene">`;
        }

        window.generateRender = async function() {
            if (!capturedImageData) { alert('Please wait for capture'); return; }
            const btn = document.getElementById('generate-render-btn');
            const status = document.getElementById('render-status');
            const statusText = document.getElementById('render-status-text');
            const outputPreview = document.getElementById('render-output-preview');

            btn.disabled = true;
            status.style.display = 'block';
            statusText.textContent = 'Generating photorealistic render... This may take 10-30 seconds';
            outputPreview.innerHTML = '<span class="render-spinner"></span>';

            try {
                const customPrompt = document.getElementById('render-custom-prompt').value.trim();
                const response = await fetch('/api/render', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        imageBase64: capturedImageData,
                        style: selectedRenderStyle,
                        prompt: customPrompt
                    })
                });
                const result = await response.json();
                if (result.success && result.image) {
                    outputPreview.innerHTML = `<img src="${result.image}" alt="AI Render">`;
                    statusText.textContent = 'Render complete!';
                    setTimeout(() => {
                        status.innerHTML = `
                            <button class="admin-btn admin-btn-success" onclick="downloadRender()">üíæ Download Render</button>
                            <button class="admin-btn admin-btn-secondary" onclick="captureForRender()">üîÑ Capture New View</button>
                        `;
                    }, 1000);
                    window.lastRenderImage = result.image;
                } else {
                    throw new Error(result.error || result.text || 'Unknown error');
                }
            } catch (err) {
                statusText.textContent = 'Error: ' + err.message;
                outputPreview.innerHTML = 'Generation failed';
            } finally {
                btn.disabled = false;
            }
        };

        window.downloadRender = function() {
            if (!window.lastRenderImage) return;
            const a = document.createElement('a');
            a.href = window.lastRenderImage;
            a.download = 'panafrican-library-render-' + selectedRenderStyle + '-' + new Date().toISOString().slice(0,19).replace(/:/g, '-') + '.png';
            a.click();
        };

    </script>

    <!-- Mobile Footer Actions - Only visible on mobile -->
    <div id="mobile-footer-actions">
        <button onclick="captureScreenshot()" aria-label="Capture">üì∑</button>
        <button onclick="toggleMoodboard()" aria-label="Mood Board">üé®</button>
        <button onclick="toggleDecorator()" aria-label="Decorator">üõãÔ∏è</button>
        <button onclick="openRenderModal()" aria-label="AI Render">‚ú®</button>
        <button onclick="toggleAdminLogin()" aria-label="Admin">üîê</button>
    </div>
</body>
</html>
